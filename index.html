<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Kanit', sans-serif;
            background-color: #f3e8ff; /* Light lavender background */
        }
        .modal {
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #ede9fe; /* Lighter purple for modal content */
            color: #5b21b6; /* Dark purple text */
        }
        .btn-primary {
            background-color: #7c3aed; /* Purple-600 */
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #6d28d9; /* Purple-700 */
        }
        .btn-secondary {
            background-color: #a78bfa; /* Purple-400 */
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-secondary:hover {
            background-color: #8b5cf6; /* Purple-500 */
        }
        .section-title {
            color: #5b21b6;
            border-bottom: 2px solid #7c3aed;
            padding-bottom: 8px;
        }
        .tab-button {
            background-color: #ddd6fe; /* Lighter purple for inactive tabs */
            color: #5b21b6;
            border-color: #c4b5fd;
        }
        .tab-button.active {
            background-color: #7c3aed;
            color: white;
            border-color: #7c3aed;
        }
        .disabled-section {
            opacity: 0.5;
            pointer-events: none;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f3e8ff; }
        ::-webkit-scrollbar-thumb { background: #a78bfa; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #8b5cf6; }

        .pedigree-chart ul { padding-left: 20px; list-style-type: none; position: relative; }
        .pedigree-chart li { margin: 10px 0; position: relative; padding-left: 25px; }
        .pedigree-chart li::before, .pedigree-chart li::after { content: ''; position: absolute; left: 0; }
        .pedigree-chart li::before { border-top: 1px solid #7c3aed; top: 10px; width: 20px; height: 0; }
        .pedigree-chart li:not(:last-child)::after { border-left: 1px solid #7c3aed; height: 100%; width: 0px; top: 0px; }
        .pedigree-chart li:last-child::after { border-left: 1px solid #7c3aed; height: 10px; width: 0px; top: 0px; }
        .pedigree-node { background-color: #ede9fe; padding: 5px 10px; border-radius: 5px; border: 1px solid #c4b5fd; display: inline-block; }
        .pedigree-node.searched { background-color: #d8b4fe; /* Light purple for searched term */ }
        .pedigree-node.descendant { background-color: #c4b5fd; /* Lighter blue/purple for descendants */ }
        .pedigree-node.external-node { background-color: #e2e8f0; border-color: #cbd5e1; color: #4a5568; }
        
        .word-evolution-flow-container { display: flex; flex-direction: column; align-items: flex-start; }
        .evolution-era-row { display: flex; align-items: center; margin-bottom: 10px; }
        .evolution-era-node { background-color: #a78bfa; color: white; padding: 8px 12px; border-radius: 8px; margin: 0 5px; text-align: center; min-width: 150px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .evolution-era-node strong { display: block; font-size: 0.9em; margin-bottom: 3px; }
        .evolution-era-node .ortho { font-family: monospace; font-size: 1.1em;}
        .evolution-era-node .phonetic { font-family: monospace; font-size: 0.8em; color: #e9d5ff;}
        .evolution-arrow { color: #7c3aed; font-size: 1.8em; margin: 0 10px; }


        .animated-emoji { display: inline-block; animation: pulse 2.5s infinite ease-in-out; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }

        #hamburgerMenu { transition: transform 0.3s ease-in-out; }
        #hamburgerMenu.open { transform: translateX(0); }
        #hamburgerMenu.closed { transform: translateX(-100%); }

        .word-detail-popup-field:not(:empty) { padding-bottom: 0.5rem; margin-bottom: 0.5rem; border-bottom: 1px solid #d1d5db; }
        .word-detail-popup-field:last-child { border-bottom: none; margin-bottom: 0; }

        .autocomplete-suggestions { position: absolute; border: 1px solid #ddd; background-color: white; z-index: 1000; max-height: 150px; overflow-y: auto; }
        .autocomplete-suggestion { padding: 8px; cursor: pointer; }
        .autocomplete-suggestion:hover { background-color: #f0f0f0; }

        #languageSelector {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto; padding-right: 2.5em;
        }
        .table-sm th, .table-sm td { padding: 0.25rem 0.5rem; font-size: 0.875rem; }
        .ipa-table { border-collapse: collapse; margin: 10px 0; font-size: 0.9em; }
        .ipa-table th, .ipa-table td { border: 1px solid #c4b5fd; padding: 4px 8px; text-align: center; }
        .ipa-table th { background-color: #ddd6fe; }
        .ipa-table td span.highlighted-phoneme { background-color: #d8b4fe; padding: 2px 4px; border-radius: 3px; }
        .draggable-item { cursor: grab; }
        .draggable-item:active { cursor: grabbing; }
        .tone-sup { vertical-align: super; font-size: 0.75em; }
        .grapheme-mapping-display {
            padding: 0.5rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0.375rem; /* rounded-md */
            background-color: #f9fafb; /* gray-50 */
        }
        .grapheme-mapping-display strong {
            color: #4b5563; /* gray-600 */
        }
        .grapheme-mapping-display .mapping-type {
            font-size: 0.8em;
            color: #6b7280; /* gray-500 */
            display: block; margin-top:2px;
        }
        .grapheme-mapping-display .mapping-values-container { /* Container for multiple value items */
            font-family: monospace;
        }
        .grapheme-mapping-display .mapping-values-container .mapping-value-item { /* Individual grapheme item */
            background-color: #d8b4fe; /* Light purple */
            padding: 1px 3px;
            border-radius: 3px;
            font-family: monospace; /* Ensure monospace is inherited or set */
            margin: 0 1px; /* Optional: space between items */
        }
        .rule-step-item { /* Style for individual rule steps */
            transition: background-color 0.2s ease-in-out;
        }
        .rule-step-item:hover {
            background-color: #e0d8f0 !important; /* Slightly darker purple when hovered */
        }

        /* Styles for inflection category backgrounds in conjugation test table */
        .inflection-category-bg-0 { background-color: #f3e8ff; } /* Light Lavender */
        .inflection-category-bg-1 { background-color: #e9d5ff; } /* Lighter Purple */
        .inflection-category-bg-2 { background-color: #ddd6fe; } /* Even Lighter Purple */

    </style>
</head>
<body class="text-gray-800">

    <div id="languageNameModal" class="fixed inset-0 z-50 flex items-center justify-center modal hidden">
        <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-md relative">
            <button id="closeLanguageNameModalBtn" class="absolute top-3 right-4 text-2xl text-purple-500 hover:text-purple-700">&times;</button>
            <h2 class="text-2xl font-bold mb-4 text-center">üëã ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤!</h2>
            <p class="mb-4 text-center">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</p>
            <input type="text" id="languageNameInput" class="w-full p-2 border border-purple-300 rounded-md mb-4 focus:ring-2 focus:ring-purple-500 focus:border-transparent" placeholder="‡πÄ‡∏ä‡πà‡∏ô '‡πÄ‡∏≠‡∏•‡∏ü‡∏¥‡∏ä', '‡∏°‡∏±‡∏á‡∏Å‡∏£‡∏•‡∏¥‡πâ‡∏ô'">
            <button id="submitLanguageName" class="w-full btn-primary py-2 px-4 rounded-md font-semibold">‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤ ‚ú®</button>
        </div>
    </div>

    <div id="aboutModal" class="fixed inset-0 z-50 flex items-center justify-center modal hidden">
        <div class="modal-content p-8 rounded-lg shadow-xl w-full max-w-lg text-center">
            <h2 class="text-2xl font-bold mb-4">‡∏ô‡∏ß‡∏±‡∏ï‡∏Å‡∏£‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤</h2>
            <p class="mb-2 text-lg">‚Äú‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏ß‡∏¥‡∏ä‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÅ‡∏•‡∏∞‡∏†‡∏≤‡∏©‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‚Äù</p>
            <hr class="my-4 border-purple-300">
            <h3 class="text-xl font-semibold mb-2">‡∏à‡∏±‡∏î‡∏ó‡∏≥‡πÇ‡∏î‡∏¢</h3>
            <ul class="list-none mb-4">
                <li>‡∏ô‡∏≤‡∏¢‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ ‡∏´‡∏°‡∏≤‡∏¢‡∏°‡∏±‡πà‡∏ô</li><li>‡∏ô‡∏≤‡∏¢‡∏ä‡∏≤‡∏ï‡∏£‡∏µ ‡πÅ‡∏™‡∏ô‡∏¢‡∏≤‡∏Å‡∏∏‡∏•</li><li>‡∏ô‡∏≤‡∏¢‡∏ì‡∏±‡∏ê‡∏Å‡∏≤‡∏ô‡∏ï‡πå ‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡πÇ‡∏¢</li>
                <li>‡∏ô‡∏≤‡∏á‡∏™‡∏≤‡∏ß‡∏ô‡∏¥‡∏ä‡∏ô‡∏¥‡∏†‡∏≤ ‡∏û‡∏±‡πâ‡∏ß‡∏ó‡∏±‡∏î</li><li>‡∏ô‡∏≤‡∏á‡∏™‡∏≤‡∏ß‡∏ó‡∏¥‡∏û‡∏¢‡∏£‡∏±‡∏ï‡∏ô‡πå ‡πÅ‡∏™‡∏ô‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå</li>
            </ul>
            <h3 class="text-xl font-semibold mb-2">‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡∏ô‡∏ß‡∏±‡∏ï‡∏Å‡∏£‡∏£‡∏°</h3>
            <p class="mb-6">‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå ‡∏î‡∏£. ‡∏û‡∏£‡∏ó‡∏¥‡∏û‡∏¢‡πå ‡∏Ñ‡∏£‡∏≤‡∏°‡∏à‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</p>
             <h4 class="text-xl font-semibold mb-2">‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏£‡∏∞‡∏ö‡∏ö ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡πâ‡∏≤‡∏ö‡πâ‡∏≤‡∏á ‡∏Å‡πá‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏°‡∏≤ ‡∏ì ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ‡∏î‡πâ‡∏ß‡∏¢</h4>
             <p class="mb-6">‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ browser ‡∏à‡∏≤‡∏Å microsoft edge ‡∏´‡∏£‡∏∑‡∏≠ Google chrome ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£</p>
            <p class="mb-6">‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏•‡πá‡∏õ‡∏ó‡πá‡∏≠‡∏õ ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö</p>
            
            <button id="closeAboutModal" class="btn-secondary py-2 px-6 rounded-md font-semibold">‡∏õ‡∏¥‡∏î</button>
        </div>
    </div>

    <div id="wordDetailModal" class="fixed inset-0 z-50 flex items-center justify-center modal hidden p-4">
        <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 id="wordDetailTitle" class="text-2xl font-bold text-purple-700"></h3>
                <button id="closeWordDetailModal" class="text-purple-500 hover:text-purple-700 text-2xl">&times;</button>
            </div>
            <div id="wordDetailContent" class="space-y-3"></div>
            <div id="wordDetailButtons" class="mt-4 flex flex-wrap gap-2">
                 </div>
        </div>
    </div>

    <div id="genericModal" class="fixed inset-0 z-[60] flex items-center justify-center modal hidden p-4">
        <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 id="genericModalTitle" class="text-2xl font-bold text-purple-700"></h3>
                <button id="closeGenericModal" class="text-purple-500 hover:text-purple-700 text-2xl">&times;</button>
            </div>
            <div id="genericModalContent" class="space-y-3"></div>
            <div id="genericModalFooter" class="mt-6 flex justify-end space-x-3"></div>
        </div>
    </div>


    <div id="hamburgerMenu" class="fixed top-0 left-0 h-full w-64 bg-purple-700 text-white p-5 z-40 closed shadow-lg">
        <button id="closeHamburgerMenu" class="absolute top-3 right-3 text-2xl text-purple-200 hover:text-white">&times;</button>
        <h2 class="text-xl font-semibold mb-6 mt-8">‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</h2>
        <nav>
            <ul id="mainMenuNav"></ul>
        </nav>
    </div>

    <div id="appWrapper" class="min-h-screen flex flex-col">
        <header class="bg-purple-600 text-white p-4 shadow-md">
            <div class="container mx-auto flex justify-between items-center">
                <button id="openHamburgerMenu" class="text-2xl p-2 hover:bg-purple-500 rounded-md"><i class="fas fa-bars"></i></button>
                <h1 id="mainTitle" class="text-xl sm:text-3xl font-bold text-center flex-grow px-2">‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤ <span class="animated-emoji">üß†</span></h1>
                <div class="flex items-center space-x-2">
                    <div class="relative">
                        <select id="languageSelector" class="bg-purple-500 text-white py-2 pl-3 pr-8 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-purple-300 appearance-none">
                            <option value="" class="bg-white text-gray-700">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>
                        </select>
                    </div>
                    <button id="addNewLangButton" class="btn-secondary py-2 px-3 rounded-md font-semibold text-sm whitespace-nowrap"><i class="fas fa-plus-circle mr-1"></i> ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà</button>
                    <button id="deleteLangButton" class="btn-secondary py-2 px-3 rounded-md font-semibold text-sm whitespace-nowrap">
    <i class="fas fa-trash-alt mr-1"></i> ‡∏•‡∏ö‡∏†‡∏≤‡∏©‡∏≤
</button>
                    <button id="aboutButton" class="btn-secondary py-2 px-3 rounded-md font-semibold text-sm hidden sm:inline-block">üìú ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö</button>
                </div>
            </div>
        </header>

        <main id="mainContent" class="container mx-auto p-4 flex-grow disabled-section">
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-2xl font-semibold mb-2">‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: <span id="currentLanguageNameDisplay" class="text-purple-600">N/A</span></h2>
                <div class="mb-4 border-b border-gray-200">
                    <nav class="flex space-x-1 overflow-x-auto pb-2" aria-label="Tabs"></nav>
                </div>
                <div id="tabContent"></div>
            </div>
        </main>

        <footer class="bg-purple-700 text-white text-center p-4 mt-auto">
            <p>Developer: ‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ ‡∏´‡∏°‡∏≤‡∏¢‡∏°‡∏±‡πà‡∏ô ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ì‡∏∞</p>
            <p>‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡∏ô‡∏ß‡∏±‡∏ï‡∏Å‡∏£‡∏£‡∏°: ‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå ‡∏î‡∏£. ‡∏û‡∏£‡∏ó‡∏¥‡∏û‡∏¢‡πå ‡∏Ñ‡∏£‡∏≤‡∏°‡∏à‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</p>
             <p>‡∏Ñ‡∏ì‡∏∞‡∏Ñ‡∏£‡∏∏‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå ‡∏™‡∏≤‡∏Ç‡∏≤‡∏ß‡∏¥‡∏ä‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ ‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢‡∏£‡∏≤‡∏ä‡∏†‡∏±‡∏è‡∏û‡∏¥‡∏ö‡∏π‡∏•‡∏™‡∏á‡∏Ñ‡∏£‡∏≤‡∏°</p>
            <p>______________________________________________________________</p>
            <p>‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏£‡∏∞‡∏ö‡∏ö ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡πâ‡∏≤‡∏ö‡πâ‡∏≤‡∏á ‡∏Å‡πá‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏°‡∏≤ ‡∏ì ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ‡∏î‡πâ‡∏ß‡∏¢</p>
              <p>‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡πÄ‡∏ß‡πá‡∏õ‡πÑ‡∏ã‡∏ï‡πå ‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 20 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ</p>
             <p>‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡πâ‡∏ô‡πÅ‡∏ö‡∏ö: <a href="https://arthur2548.github.io/conlang-/" target="_blank" class="hover:underline">https://arthur2548.github.io/conlang-/</a></p>  
            <p>‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠: <a href="https://kruarthurclassroom.blogspot.com/" target="_blank" class="hover:underline">kruarthurclassroom.blogspot.com</a></p>
            <p>¬© 2025-2026 All Rights Reserved</p>
        </footer>
    </div>

    <script>
        // --- Global State and Data Structures ---
        const DEFAULT_LANGUAGE_STATE = Object.freeze({
            name: '',
            parentLangName: null,
            phonology: {
                consonants: ['p', 't', 'k'],
                vowels: ['a', 'e', 'i', 'o', 'u'],
                
                allowedInitialConsonants: [], 
                allowVowelInitial: false,
                forbiddenInitialSounds: [],

                allowedConsonantClusters: [], 
                forbiddenConsonantClusters: [],
                maxClusterLength: 2,

                allowedFinalConsonants: [], 
                allowNoCoda: true,
                forbiddenFinalSounds: [],
                allowClusterCoda: false, 
                allowedCodaClusters: [], 

                hasTones: false,
                tones: [], // { id: 'tone_1', name: '‡πÄ‡∏≠‡∏Å', symbol: '¬π', number: 1, representation: '\u00B9', hideInOrthography: false }
                
                tonePhonotactics: [], 

                graphemeMappings: [], 
                
                activeSoundChanges: [], 

                syllableStructures: ['CV', 'CVC', 'CCV', 'CCVC'],
                phonotactics: [ 
                    { rule: "‡∏´‡πâ‡∏≤‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ã‡πâ‡∏≠‡∏ô‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏´‡∏•‡∏±‡∏Å (‡πÄ‡∏ä‡πà‡∏ô CVC ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô CCVC)", type: "no_internal_cluster_in_base_syllable", enabled: true, custom: false, pattern: "" },
                ]
            },
            lexicon: [], // Words will have id, word (base phonemic form), customOrthography (optional), phonetics (detailed IPA), meaning, pos, gender, etymology, evolutionTimeline, dialectalForms, manualInflections
            grammar: {
                sentenceStructure: 'SVO',
                partsOfSpeech: ['‡∏ô‡∏≤‡∏°', '‡∏Å‡∏£‡∏¥‡∏¢‡∏≤', '‡∏ß‡∏¥‡πÄ‡∏®‡∏©‡∏ì‡πå', '‡∏Ñ‡∏∏‡∏ì‡∏®‡∏±‡∏û‡∏ó‡πå', '‡∏™‡∏£‡∏£‡∏û‡∏ô‡∏≤‡∏°', '‡∏™‡∏±‡∏ô‡∏ò‡∏≤‡∏ô', '‡∏ö‡∏∏‡∏û‡∏ö‡∏ó', '‡∏≠‡∏∏‡∏ó‡∏≤‡∏ô', ], 
                hasGender: false,
                genders: ['‡∏õ‡∏∏‡∏á‡∏•‡∏¥‡∏á‡∏Ñ‡πå', '‡∏≠‡∏¥‡∏ï‡∏ñ‡∏µ‡∏•‡∏¥‡∏á‡∏Ñ‡πå', '‡∏ô‡∏õ‡∏∏‡∏á‡∏™‡∏Å‡∏•‡∏¥‡∏á‡∏Ñ‡πå'],
                morphology: {
                    conjugationCategories: [
                        { id: 'cat_tense', name: '‡∏Å‡∏≤‡∏•', appliesToPOS: ['‡∏Å‡∏£‡∏¥‡∏¢‡∏≤'], options: ['‡∏≠‡∏î‡∏µ‡∏ï‡∏Å‡∏≤‡∏•', '‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Å‡∏≤‡∏•', '‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï‡∏Å‡∏≤‡∏•'] },
                        { id: 'cat_number', name: '‡∏û‡∏à‡∏ô‡πå', appliesToPOS: ['‡∏ô‡∏≤‡∏°', '‡∏Å‡∏£‡∏¥‡∏¢‡∏≤'], options: ['‡πÄ‡∏≠‡∏Å‡∏û‡∏à‡∏ô‡πå', '‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå'] }
                    ],
                    conjugationRules: [], // Each rule now has ruleSteps: [{id, order, ruleType, ruleValue}]
                    nounPluralization: { 
                        ruleSteps: [{ id: 'default_plural_step_1', order: 0, ruleType: 'suffix', value: 's' }] // 'value' for nounPluralization steps
                    }
                },
                particles: []
            },
            orthography: {
                writingSystem: 'latin',
                customSymbols: [], 
                displayTonesInOrthography: true, 
                direction: 'ltr'
            },
            evolution: { 
                baseEra: null, 
                wordEra: null, 
                eras: [ 
                    { id: 'era_proto', name: 'Proto-Language', order: 0, soundChangeRules: [] }, 
                    { id: 'era_old', name: 'Old Period', order: 1, soundChangeRules: [] },
                    { id: 'era_modern', name: 'Modern Period', order: 2, soundChangeRules: [] }
                ]
            },
            eras: [ 
                { id: 'era_proto', name: 'Proto-Language', order: 0, soundChangeRules: [] }, 
                { id: 'era_old', name: 'Old Period', order: 1, soundChangeRules: [] },
                { id: 'era_modern', name: 'Modern Period', order: 2, soundChangeRules: [] }
            ],
            regions: ['Standard', '‡∏ñ‡∏¥‡πà‡∏ô‡πÄ‡∏´‡∏ô‡∏∑‡∏≠', '‡∏ñ‡∏¥‡πà‡∏ô‡πÉ‡∏ï‡πâ', '‡∏ñ‡∏¥‡πà‡∏ô‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å', '‡∏ñ‡∏¥‡πà‡∏ô‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏ï‡∏Å'], 
            dialectSoundChanges: {}, 
            languageFamily: { 
                externalNodes: [] 
            },
            interLangSoundChangePairs: [], 
            theme: 'default'
        });

        let currentLanguage = JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE));
        let allLanguages = [];
        let globalInterLangRules = []; 

        let nextWordId = 1;
        let nextConjCategoryId = 1;
        let nextConjRuleId = 1;
        let nextRuleStepId = 1; // For unique IDs for rule steps (both general and plural)
        let nextExternalNodeId = 1;
        let nextInterLangPairId = 1;
        let nextActiveSoundChangeId = 1; 
        let nextToneId = 1;
        let nextTonePhonotacticId = 1;


        let activeTab = 'phonology';

        const localThaiMeaningsDatabase = [ 
            "‡πÄ‡∏î‡∏¥‡∏ô", "‡∏ß‡∏¥‡πà‡∏á", "‡∏Å‡∏¥‡∏ô", "‡∏ô‡∏≠‡∏ô", "‡∏û‡∏π‡∏î", "‡∏´‡∏±‡∏ß‡πÄ‡∏£‡∏≤‡∏∞", "‡∏£‡πâ‡∏≠‡∏á‡πÑ‡∏´‡πâ", "‡∏£‡∏±‡∏Å", "‡πÄ‡∏Å‡∏•‡∏µ‡∏¢‡∏î", "‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°", "‡∏´‡∏•‡πà‡∏≠‡πÄ‡∏´‡∏•‡∏≤",
            "‡∏ö‡πâ‡∏≤‡∏ô", "‡πÄ‡∏°‡∏∑‡∏≠‡∏á", "‡∏†‡∏π‡πÄ‡∏Ç‡∏≤", "‡πÅ‡∏°‡πà‡∏ô‡πâ‡∏≥", "‡∏ó‡∏∞‡πÄ‡∏•", "‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤", "‡∏î‡∏ß‡∏á‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå", "‡∏î‡∏ß‡∏á‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå", "‡∏î‡∏ß‡∏á‡∏î‡∏≤‡∏ß",
            "‡∏´‡∏¥‡∏ô", "‡∏î‡∏¥‡∏ô", "‡∏ó‡∏£‡∏≤‡∏¢", "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ", "‡∏î‡∏≠‡∏Å‡πÑ‡∏°‡πâ", "‡∏ú‡∏•‡πÑ‡∏°‡πâ", "‡∏™‡∏±‡∏ï‡∏ß‡πå", "‡∏ô‡∏Å", "‡∏õ‡∏•‡∏≤", "‡πÅ‡∏°‡∏•‡∏á",
            "‡∏ö‡∏¥‡∏î‡∏≤", "‡∏°‡∏≤‡∏£‡∏î‡∏≤", "‡∏û‡∏µ‡πà‡∏ä‡∏≤‡∏¢", "‡∏ô‡πâ‡∏≠‡∏á‡∏™‡∏≤‡∏ß", "‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô", "‡∏Ñ‡∏£‡∏π", "‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡πÅ‡∏û‡∏ó‡∏¢‡πå", "‡∏ó‡∏´‡∏≤‡∏£", "‡∏ï‡∏≥‡∏£‡∏ß‡∏à",
            "‡πÉ‡∏´‡∏ç‡πà", "‡πÄ‡∏•‡πá‡∏Å", "‡∏™‡∏π‡∏á", "‡∏ï‡πà‡∏≥", "‡∏¢‡∏≤‡∏ß", "‡∏™‡∏±‡πâ‡∏ô", "‡∏£‡πâ‡∏≠‡∏ô", "‡πÄ‡∏¢‡πá‡∏ô", "‡∏™‡∏ß‡πà‡∏≤‡∏á", "‡∏°‡∏∑‡∏î", "‡∏î‡∏µ", "‡πÄ‡∏•‡∏ß"
        ];
        let apiThaiMeaningsDatabase = []; 

        const API_URL = "https://script.google.com/macros/s/AKfycbyQt6pWFF_y0LZBA38C8VheADB-bud0PshyYiUehFTWZxWUqzB5d0n_EzmMA7MDwAYnwQ/exec";

        // --- UI Elements ---
        const languageNameModal = document.getElementById('languageNameModal');
        const closeLanguageNameModalButton = document.getElementById('closeLanguageNameModalBtn');
        const languageNameInput = document.getElementById('languageNameInput');
        const submitLanguageNameButton = document.getElementById('submitLanguageName');
        const mainContent = document.getElementById('mainContent');
        const currentLanguageNameDisplay = document.getElementById('currentLanguageNameDisplay');
        const aboutModal = document.getElementById('aboutModal');
        const aboutButton = document.getElementById('aboutButton');
        const closeAboutModalButton = document.getElementById('closeAboutModal');
        const tabContainer = document.querySelector('nav[aria-label="Tabs"]');
        const tabContentContainer = document.getElementById('tabContent');
        const addNewLangButton = document.getElementById('addNewLangButton');
        const languageSelector = document.getElementById('languageSelector');

        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const openHamburgerMenuButton = document.getElementById('openHamburgerMenu');
        const closeHamburgerMenuButton = document.getElementById('closeHamburgerMenu');
        const mainMenuNav = document.getElementById('mainMenuNav');

        const wordDetailModal = document.getElementById('wordDetailModal');
        const wordDetailTitle = document.getElementById('wordDetailTitle');
        const wordDetailContent = document.getElementById('wordDetailContent');
        const wordDetailButtons = document.getElementById('wordDetailButtons');
        const closeWordDetailModalButton = document.getElementById('closeWordDetailModal');

        const genericModal = document.getElementById('genericModal');
        const genericModalTitle = document.getElementById('genericModalTitle');
        const genericModalContent = document.getElementById('genericModalContent');
        const genericModalFooter = document.getElementById('genericModalFooter');
        const closeGenericModalButton = document.getElementById('closeGenericModal');


        // --- Tabs Configuration ---
        const tabs = [
            { id: 'phonology', name: 'üé∂ ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á', icon: 'fas fa-volume-up', contentFunc: renderPhonologyUI, menu: true },
            { id: 'wordGen', name: '‚úçÔ∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥', icon: 'fas fa-pencil-alt', contentFunc: renderWordGeneratorUI, menu: true },
            { id: 'grammar', name: 'üìñ ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå', icon: 'fas fa-book', contentFunc: renderGrammarUI, menu: true },
            { id: 'dictionary', name: 'üìö ‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°', icon: 'fas fa-atlas', contentFunc: renderDictionaryUI, menu: true },
            { id: 'orthography', name: 'üî§ ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏Å‡∏©‡∏£', icon: 'fas fa-spell-check', contentFunc: renderOrthographyUI, menu: true },
            { id: 'etymology', name: 'üå± ‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤', icon: 'fas fa-seedling', contentFunc: renderEtymologyUI, menu: true },
            { id: 'evolution', name: '‚è≥ ‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥', icon: 'fas fa-history', contentFunc: renderEvolutionUI, menu: true },
            { id: 'dialects', name: 'üó∫Ô∏è ‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô', icon: 'fas fa-map-signs', contentFunc: renderDialectsUI, menu: true },
            { id: 'langFamily', name: 'üå≥ ‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤', icon: 'fas fa-sitemap', contentFunc: renderLangFamilyUI, menu: true },
            { id: 'soundChanges', name: 'üîÑ ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤)', icon: 'fas fa-exchange-alt', contentFunc: renderSoundChangesInterLangUI, menu: true },
            { id: 'tools', name: 'üõ†Ô∏è ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠', icon: 'fas fa-tools', contentFunc: renderToolsUI, menu: true },
            { id: 'ipaProgram', name: 'üó£Ô∏è ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏™‡∏±‡∏ó‡∏≠‡∏±‡∏Å‡∏©‡∏£', icon: 'fas fa-microphone-alt', contentFunc: () => tabContentContainer.innerHTML = '<p>‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏±‡∏ó‡∏≠‡∏±‡∏Å‡∏©‡∏£ (‡∏£‡∏≠‡∏û‡∏±‡∏í‡∏ô‡∏≤)</p>', menu: true, disabled: true },
            { id: 'thaiApp', name: 'üáπüá≠ ‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢', icon: 'fas fa-chalkboard-teacher', contentFunc: () => tabContentContainer.innerHTML = '<p>‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ß‡∏¥‡∏ä‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (‡∏£‡∏≠‡∏û‡∏±‡∏í‡∏ô‡∏≤)</p>', menu: true, disabled: true },
        ];

        // --- API Functions ---
        async function fetchThaiMeaningsFromAPI() {
            try {
                const response = await fetch(`${API_URL}?action=findAllRegister`);
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                const result = await response.json();
                if (result.success && Array.isArray(result.data)) {
                    apiThaiMeaningsDatabase = result.data.map(item => item.‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå).filter(meaning => meaning && meaning.trim() !== '');
                    console.log(`Fetched ${apiThaiMeaningsDatabase.length} meanings from API.`);
                    if (apiThaiMeaningsDatabase.length === 0) {
                         console.warn("API returned no valid meanings. Falling back to local meanings.");
                    }
                } else {
                    console.error("API call was successful but data is not in expected format or success=false:", result.message, result.error);
                    apiThaiMeaningsDatabase = []; 
                }
            } catch (error) {
                console.error("Error fetching Thai meanings from API:", error);
                apiThaiMeaningsDatabase = []; 
            }
        }

        // --- Initialization ---
        window.onload = async () => {
            await fetchThaiMeaningsFromAPI();
            loadData(); 
            if (!currentLanguage.name && allLanguages.length === 0) {
                languageNameModal.classList.remove('hidden');
                mainContent.classList.add('disabled-section');
            } else if (!currentLanguage.name && allLanguages.length > 0) {
                switchLanguage(allLanguages[0].name); 
                mainContent.classList.remove('disabled-section');
            } else { 
                mainContent.classList.remove('disabled-section');
                currentLanguageNameDisplay.textContent = currentLanguage.name;
                 if (languageSelector.value !== currentLanguage.name) {
                   languageSelector.value = currentLanguage.name;
                }
                updateUI();
            }

            submitLanguageNameButton.addEventListener('click', handleNewLanguageNameSubmission);
            closeLanguageNameModalButton.addEventListener('click', () => {
                languageNameModal.classList.add('hidden');
                if (!currentLanguage.name && allLanguages.length === 0) {
                    // Stays disabled
                } else if (!currentLanguage.name && allLanguages.length > 0) {
                    const lastSelected = languageSelector.value;
                    if (lastSelected && allLanguages.some(l => l.name === lastSelected)) {
                        switchLanguage(lastSelected);
                    } else if(allLanguages.length > 0) {
                        switchLanguage(allLanguages[0].name);
                    }
                     mainContent.classList.remove('disabled-section');
                } else { 
                    mainContent.classList.remove('disabled-section');
                }
            });
            addNewLangButton.addEventListener('click', promptForNewLanguage);
            languageSelector.addEventListener('change', handleLanguageSelectionChange);

            aboutButton.addEventListener('click', () => aboutModal.classList.remove('hidden'));
            closeAboutModalButton.addEventListener('click', () => aboutModal.classList.add('hidden'));

            openHamburgerMenuButton.addEventListener('click', () => hamburgerMenu.classList.replace('closed', 'open') );
            closeHamburgerMenuButton.addEventListener('click', () => hamburgerMenu.classList.replace('open', 'closed') );

            closeWordDetailModalButton.addEventListener('click', () => wordDetailModal.classList.add('hidden'));
            closeGenericModalButton.addEventListener('click', () => genericModal.classList.add('hidden'));

            renderMainMenu();
            renderTabs();
            if (currentLanguage.name) {
                switchTab(activeTab);
            }
        };
        const deleteLangButton = document.getElementById('deleteLangButton');
deleteLangButton.addEventListener('click', () => {
    if (!currentLanguage.name) {
        alert("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà");
        return;
    }
    const confirmDelete = confirm(`‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏†‡∏≤‡∏©‡∏≤ "${currentLanguage.name}"? ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏∞‡∏´‡∏≤‡∏¢‡πÑ‡∏õ`);
    if (confirmDelete) {
        // ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å allLanguages
        allLanguages = allLanguages.filter(lang => lang.name !== currentLanguage.name);

        // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå currentLanguage
        currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE);

        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI
        localStorage.setItem('allLanguagesData', JSON.stringify(allLanguages));
        localStorage.removeItem('currentLanguageData');

        renderLanguageSelector();
        updateUI();
    }
});

        function ensureDeepStructure(langData, defaultStructure) {
            const newLangData = JSON.parse(JSON.stringify(defaultStructure)); 
        
            function merge(target, source, defaultSrc = defaultStructure) {
                for (const key in source) {
                    if (source.hasOwnProperty(key)) {
                        if (source[key] !== null && typeof source[key] === 'object' && !Array.isArray(source[key]) && key !== 'phonology' && key !== 'grammar' && key !== 'lexicon' && key !== 'orthography' /* etc, handle special structures below */ ) {
                             if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key])) {
                                target[key] = JSON.parse(JSON.stringify(defaultSrc[key] || {})); 
                            }
                            merge(target[key], source[key], defaultSrc[key] || {});
                        } else if (key === 'conjugationRules' && Array.isArray(source[key])) { // START MIGRATION LOGIC for conjugationRules
                            target[key] = source[key].map(rule => {
                                if (rule.hasOwnProperty('ruleType') && !rule.hasOwnProperty('ruleSteps')) { // Old format: ruleType/ruleValue directly on rule
                                    // Migrate to new format: ruleSteps array
                                    return {
                                        ...rule, // Keep id, description, pos, catId, catOpt
                                        ruleSteps: [{ 
                                            id: `step_${nextRuleStepId++}`, 
                                            order: 0, 
                                            ruleType: rule.ruleType, 
                                            ruleValue: rule.ruleValue 
                                        }],
                                        ruleType: undefined, // Remove old properties
                                        ruleValue: undefined // Remove old properties
                                    };
                                }
                                // Ensure all steps in the new format have IDs and order
                                if (rule.ruleSteps && Array.isArray(rule.ruleSteps)) {
                                    rule.ruleSteps = rule.ruleSteps.map((step, index) => ({
                                        id: step.id || `step_${nextRuleStepId++}`, // Assign ID if missing
                                        order: step.order !== undefined ? step.order : index, // Assign order if missing
                                        ...step
                                    }));
                                } else if (!rule.ruleSteps) { // If rule exists but ruleSteps is missing somehow
                                    rule.ruleSteps = [];
                                }
                                return rule;
                            }); // END MIGRATION LOGIC for conjugationRules
                        } else if (key === 'nounPluralization' && source[key] && typeof source[key] === 'object') { // START MIGRATION for nounPluralization
                             if (source[key].hasOwnProperty('rule') && !source[key].hasOwnProperty('ruleSteps')) { // Old format: rule/value directly
                                target[key] = {
                                    ruleSteps: [{
                                        id: `plural_step_${nextRuleStepId++}`,
                                        order: 0,
                                        ruleType: source[key].rule,
                                        value: source[key].value // 'value' for noun plural steps
                                    }]
                                };
                            } else if (source[key].ruleSteps && Array.isArray(source[key].ruleSteps)) { // New format from source
                                target[key] = {
                                    ruleSteps: source[key].ruleSteps.map((step, index) => ({
                                        id: step.id || `plural_step_${nextRuleStepId++}`,
                                        order: step.order !== undefined ? step.order : index,
                                        ruleType: step.ruleType,
                                        value: step.value // 'value' for noun plural steps
                                    }))
                                };
                            } else if (defaultSrc && defaultSrc[key] && defaultSrc[key].ruleSteps) { // Fallback to default if source is malformed
                                target[key] = JSON.parse(JSON.stringify(defaultSrc[key]));
                            } else { // Absolute fallback
                                target[key] = { ruleSteps: [{ id: `default_plural_step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', value: 's' }] };
                            } // END MIGRATION for nounPluralization
                        } else if (Array.isArray(source[key])) {
                             if (source[key].length > 0 || !target.hasOwnProperty(key) || target[key] === undefined) {
                                target[key] = JSON.parse(JSON.stringify(source[key]));
                            } else if (target[key] && target[key].length === 0 && source[key].length === 0 && defaultSrc[key] && defaultSrc[key].length > 0) {
                                // If target is empty array, source is empty array, but default has items, use default.
                                target[key] = JSON.parse(JSON.stringify(defaultSrc[key])); 
                            } else if (!target.hasOwnProperty(key) || target[key] === undefined) { // if target doesn't have key, copy from source
                                 target[key] = JSON.parse(JSON.stringify(source[key]));
                            } else { // Default case: target exists, source exists, copy from source
                                target[key] = JSON.parse(JSON.stringify(source[key]));
                             }
                        } else if (source[key] !== undefined) { // Handle primitive types or null
                            target[key] = source[key];
                        }
                    }
                }
                // Ensure all default keys are present if not in source
                for (const key in defaultSrc) {
                    if (defaultSrc.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                         if (key === 'grammar' || key === 'phonology' || key === 'lexicon' || key === 'orthography') { // Don't overwrite special structures if partially merged
                            // These are handled below
                         } else {
                            target[key] = JSON.parse(JSON.stringify(defaultSrc[key]));
                         }
                    }
                }
            }
        
            merge(newLangData, langData); 
        
            // Ensure specific nested structures exist and have all default keys
            newLangData.phonology = newLangData.phonology || { ...defaultStructure.phonology };
            const phonoKeys = ['consonants', 'vowels', 'allowedInitialConsonants', 'allowVowelInitial', 'forbiddenInitialSounds', 
                               'allowedConsonantClusters', 'forbiddenConsonantClusters', 'maxClusterLength', 
                               'allowedFinalConsonants', 'allowNoCoda', 'forbiddenFinalSounds', 'allowClusterCoda', 'allowedCodaClusters',
                               'hasTones', 'tones', 'tonePhonotactics', 'graphemeMappings', 
                               'activeSoundChanges', 'syllableStructures', 'phonotactics'];
            phonoKeys.forEach(key => {
                if (!newLangData.phonology.hasOwnProperty(key) || newLangData.phonology[key] === undefined) {
                    newLangData.phonology[key] = JSON.parse(JSON.stringify(defaultStructure.phonology[key]));
                }
                // Ensure arrays are arrays, booleans are booleans, etc.
                if(Array.isArray(defaultStructure.phonology[key]) && !Array.isArray(newLangData.phonology[key])) {
                    newLangData.phonology[key] = JSON.parse(JSON.stringify(defaultStructure.phonology[key]));
                }
                 if (typeof defaultStructure.phonology[key] === 'boolean' && typeof newLangData.phonology[key] !== 'boolean') {
                    newLangData.phonology[key] = defaultStructure.phonology[key];
                }
                if (typeof defaultStructure.phonology[key] === 'number' && typeof newLangData.phonology[key] !== 'number') {
                    newLangData.phonology[key] = defaultStructure.phonology[key];
                }
            });
             // If allowedInitialConsonants is empty after load but consonants are not, populate it from consonants (common scenario for older data)
             if (newLangData.phonology.allowedInitialConsonants.length === 0 && newLangData.phonology.consonants.length > 0) {
                 newLangData.phonology.allowedInitialConsonants = [...newLangData.phonology.consonants];
             }
             // Same for allowedFinalConsonants, populate with common finals if empty
             if (newLangData.phonology.allowedFinalConsonants.length === 0 && newLangData.phonology.consonants.length > 0) {
                 const commonFinals = ['m', 'n', '≈ã', 'p', 't', 'k', 's', 'l', 'r']; // Example common finals
                 newLangData.phonology.allowedFinalConsonants = newLangData.phonology.consonants.filter(c => commonFinals.includes(c));
             }


            newLangData.lexicon = (newLangData.lexicon || []).map(word => ({
                id: word.id || 0, 
                word: word.word || '',
                customOrthography: word.customOrthography || null,
                phonetics: word.phonetics || '',
                meaning: word.meaning || '',
                partOfSpeech: word.partOfSpeech || '',
                gender: word.gender || '', // Added gender field
                etymology: word.etymology || { roots: [], notes: '' },
                evolutionTimeline: word.evolutionTimeline || [],
                dialectalForms: word.dialectalForms || [],
                manualInflections: word.manualInflections || {},
                ...word 
            }));
            
            newLangData.grammar = newLangData.grammar || { ...defaultStructure.grammar };
            newLangData.grammar.morphology = newLangData.grammar.morphology || { ...defaultStructure.grammar.morphology };
            newLangData.grammar.morphology.conjugationCategories = (newLangData.grammar.morphology.conjugationCategories && newLangData.grammar.morphology.conjugationCategories.length > 0) ? newLangData.grammar.morphology.conjugationCategories : JSON.parse(JSON.stringify(defaultStructure.grammar.morphology.conjugationCategories));
            // ConjugationRules are handled by the merge function's specific logic
            if (!newLangData.grammar.morphology.conjugationRules) { // Ensure it's an array if merge didn't create it
                newLangData.grammar.morphology.conjugationRules = [];
            }
            // NounPluralization is handled by the merge function's specific logic
            if (!newLangData.grammar.morphology.nounPluralization || typeof newLangData.grammar.morphology.nounPluralization !== 'object' || !Array.isArray(newLangData.grammar.morphology.nounPluralization.ruleSteps)) {
                 console.warn("Re-initializing nounPluralization to default in ensureDeepStructure due to missing/invalid structure post-merge.");
                 newLangData.grammar.morphology.nounPluralization = JSON.parse(JSON.stringify(defaultStructure.grammar.morphology.nounPluralization));
            }
             // Ensure ruleSteps in nounPluralization have proper IDs and order after everything
            if (newLangData.grammar.morphology.nounPluralization.ruleSteps) {
                newLangData.grammar.morphology.nounPluralization.ruleSteps = newLangData.grammar.morphology.nounPluralization.ruleSteps.map((step, index) => ({
                    id: step.id || `plural_step_${nextRuleStepId++}`,
                    order: step.order !== undefined ? step.order : index,
                    ruleType: step.ruleType,
                    value: step.value // Noun plural steps use 'value'
                }));
            }


            newLangData.grammar.partsOfSpeech = (newLangData.grammar.partsOfSpeech && newLangData.grammar.partsOfSpeech.length > 0) ? newLangData.grammar.partsOfSpeech : JSON.parse(JSON.stringify(defaultStructure.grammar.partsOfSpeech));
            newLangData.grammar.genders = (newLangData.grammar.genders && newLangData.grammar.genders.length > 0) ? newLangData.grammar.genders : JSON.parse(JSON.stringify(defaultStructure.grammar.genders));


            newLangData.orthography = newLangData.orthography || { ...defaultStructure.orthography };
            newLangData.orthography.customSymbols = newLangData.orthography.customSymbols || [];
            if (newLangData.orthography.displayTonesInOrthography === undefined) { // Ensure boolean exists
                newLangData.orthography.displayTonesInOrthography = defaultStructure.orthography.displayTonesInOrthography;
            }
            
            newLangData.eras = (newLangData.eras && newLangData.eras.length > 0) ? newLangData.eras : JSON.parse(JSON.stringify(defaultStructure.eras));
            newLangData.eras.forEach(era => era.soundChangeRules = era.soundChangeRules || []);

            // Ensure evolution structure
            newLangData.evolution = newLangData.evolution || JSON.parse(JSON.stringify(defaultStructure.evolution));
            newLangData.evolution.eras = (newLangData.evolution.eras && newLangData.evolution.eras.length > 0) ? newLangData.evolution.eras : JSON.parse(JSON.stringify(defaultStructure.evolution.eras));
            if (!newLangData.evolution.baseEra && newLangData.evolution.eras.length > 0) newLangData.evolution.baseEra = newLangData.evolution.eras[0].id;
            if (!newLangData.evolution.wordEra && newLangData.evolution.eras.length > 0) newLangData.evolution.wordEra = newLangData.evolution.eras[0].id;


            newLangData.regions = (newLangData.regions && newLangData.regions.length > 0) ? newLangData.regions : JSON.parse(JSON.stringify(defaultStructure.regions));
            
            newLangData.dialectSoundChanges = newLangData.dialectSoundChanges || {};
            const currentRegions = newLangData.regions || defaultStructure.regions; // Use the ones actually in the lang data
            currentRegions.forEach(region => { // Ensure every current region has an entry in dialectSoundChanges
                if (!newLangData.dialectSoundChanges[region]) {
                    newLangData.dialectSoundChanges[region] = [];
                }
            });
            // Remove dialectSoundChanges for regions that no longer exist
            for (const regionInRules in newLangData.dialectSoundChanges) {
                if (!currentRegions.includes(regionInRules)) {
                    delete newLangData.dialectSoundChanges[regionInRules];
                }
            }

            newLangData.languageFamily = newLangData.languageFamily || { ...defaultStructure.languageFamily };
            newLangData.languageFamily.externalNodes = newLangData.languageFamily.externalNodes || [];

            newLangData.interLangSoundChangePairs = newLangData.interLangSoundChangePairs || [];

            // Recalculate nextRuleStepId based on the fully processed langData
            let maxStepIdNum = 0;
            (newLangData.grammar.morphology.conjugationRules || []).forEach(rule => {
                (rule.ruleSteps || []).forEach(step => {
                    if (step.id) {
                        const num = parseInt(String(step.id).replace(/^(step_|plural_step_)/, ''));
                        if (!isNaN(num)) maxStepIdNum = Math.max(maxStepIdNum, num);
                    }
                });
            });
            if (newLangData.grammar.morphology.nounPluralization && newLangData.grammar.morphology.nounPluralization.ruleSteps) {
                 newLangData.grammar.morphology.nounPluralization.ruleSteps.forEach(step => {
                     if (step.id) {
                        const num = parseInt(String(step.id).replace(/^(step_|plural_step_)/, ''));
                        if (!isNaN(num)) maxStepIdNum = Math.max(maxStepIdNum, num);
                    }
                 });
            }
            nextRuleStepId = maxStepIdNum + 1;


            return newLangData;
        }


        function renderMainMenu() {
            mainMenuNav.innerHTML = '';
            tabs.filter(tab => tab.menu).forEach(tab => {
                const li = document.createElement('li');
                li.className = 'mb-3';
                const a = document.createElement('a');
                a.href = '#';
                a.className = `hover:text-purple-300 block py-2 px-1 rounded ${tab.disabled ? 'text-gray-400 cursor-not-allowed' : ''}`;
                a.innerHTML = `<i class="${tab.icon} mr-2"></i> ${tab.name} ${tab.disabled ? '<span class="text-xs">(‡∏£‡∏≠‡∏û‡∏±‡∏í‡∏ô‡∏≤)</span>' : ''}`;
                if (!tab.disabled) {
                    a.onclick = (e) => {
                        e.preventDefault();
                        switchTab(tab.id);
                        hamburgerMenu.classList.replace('open', 'closed');
                    };
                } else {
                    a.onclick = (e) => { e.preventDefault(); alert(`${tab.name} (‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤)`); };
                }
                li.appendChild(a);
                mainMenuNav.appendChild(li);
            });
        }

        function handleNewLanguageNameSubmission() {
            const name = languageNameInput.value.trim();
            if (name) {
                if (allLanguages.some(lang => lang.name === name)) {
                    alert("‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏∑‡πà‡∏ô");
                    return;
                }
                if (currentLanguage.name === '') { // Initial creation for the session
                    currentLanguage.name = name;
                } else { // User clicked "Add New Language" button while another was active
                    currentLanguage = ensureDeepStructure({ name: name }, DEFAULT_LANGUAGE_STATE);
                }
                
                languageNameModal.classList.add('hidden');
                mainContent.classList.remove('disabled-section');
                currentLanguageNameDisplay.textContent = currentLanguage.name;
                
                 // Populate initial phonotactics for new language if needed
                 if (currentLanguage.phonology.allowedInitialConsonants.length === 0 && currentLanguage.phonology.consonants.length > 0) {
                    currentLanguage.phonology.allowedInitialConsonants = [...currentLanguage.phonology.consonants];
                }
                if (currentLanguage.phonology.allowedFinalConsonants.length === 0 && currentLanguage.phonology.consonants.length > 0) {
                    const commonFinals = ['m', 'n', '≈ã', 'p', 't', 'k', 's', 'l', 'r']; 
                    currentLanguage.phonology.allowedFinalConsonants = currentLanguage.phonology.consonants.filter(c => commonFinals.includes(c));
                }

                saveData(); // This will add/update it in allLanguages
                updateUI(); // This will re-render tabs, selector, etc.
            } else {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì');
            }
        }

        function promptForNewLanguage() {
            const confirmMsg = currentLanguage.name ? 
                '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß)' : 
                '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?';
            if (!confirm(confirmMsg)) {
                return;
            }

            if (currentLanguage.name) { // Save current before switching
                saveData(); // This updates `allLanguages`
            }

            currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE); // Reset to default for new lang
            nextWordId = 1; // Reset relevant counters FOR THIS NEW LANGUAGE CONTEXT
            nextActiveSoundChangeId = 1;
            nextToneId = 1;
            nextTonePhonotacticId = 1;
            nextConjCategoryId = 1;
            nextConjRuleId = 1;
            nextRuleStepId = 1; // Reset for the new language context
            nextExternalNodeId = 1; // This might need to be global if external nodes are shared, or per-language if not

            languageNameInput.value = ''; // Clear input for new name
            languageNameModal.classList.remove('hidden'); // Show modal
            mainContent.classList.add('disabled-section'); // Disable content until named
            currentLanguageNameDisplay.textContent = 'N/A';
            languageSelector.value = ""; // Reflect that no language is selected for current editing context

            tabContentContainer.innerHTML = ''; // Clear current tab content
            activeTab = tabs[0].id; // Reset to first tab
            renderTabs(); // Render tabs (they'll be mostly functionless until lang is named)
        }

        function handleLanguageSelectionChange(event) {
            const selectedLangName = event.target.value;
            if (selectedLangName && selectedLangName !== currentLanguage.name) {
                switchLanguage(selectedLangName);
            } else if (!selectedLangName) {
                // User selected "-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --"
                // If a language is currently active, revert selector to it.
                // Or, decide if this means "unload current language". For now, revert.
                if (currentLanguage.name) {
                    languageSelector.value = currentLanguage.name;
                }
            }
        }

        function switchLanguage(langName) {
            if (currentLanguage.name && currentLanguage.name !== langName) { // Save current language if it's named and different
                saveData();
            }
            const targetLanguageData = allLanguages.find(lang => lang.name === langName);
            if (targetLanguageData) {
                currentLanguage = ensureDeepStructure(JSON.parse(JSON.stringify(targetLanguageData)), DEFAULT_LANGUAGE_STATE);
                
                // Recalculate next IDs based on the loaded language's content
                nextWordId = calculateNextWordId(currentLanguage.lexicon);
                nextConjCategoryId = calculateNextId(currentLanguage.grammar.morphology.conjugationCategories || [], 'cat_');
                nextConjRuleId = calculateNextId(currentLanguage.grammar.morphology.conjugationRules || [], 'rule_');
                // nextRuleStepId is handled by ensureDeepStructure for the loaded language context
                nextExternalNodeId = calculateNextId(currentLanguage.languageFamily.externalNodes || [], 'ext_');
                nextActiveSoundChangeId = calculateNextId(currentLanguage.phonology.activeSoundChanges || [], 'asc_');
                nextToneId = calculateNextId(currentLanguage.phonology.tones || [], 'tone_');
                nextTonePhonotacticId = calculateNextId(currentLanguage.phonology.tonePhonotactics || [], 'tp_');


                currentLanguageNameDisplay.textContent = currentLanguage.name;
                if (languageSelector.value !== currentLanguage.name) {
                     languageSelector.value = currentLanguage.name; // Ensure selector matches
                }

                mainContent.classList.remove('disabled-section');
                localStorage.setItem('currentLanguageData', JSON.stringify(currentLanguage)); // Save as "active"
                updateUI(); // This will render tabs and switch to the active one.
                console.log(`Switched to language: ${currentLanguage.name}`);
            } else {
                console.error(`Language ${langName} not found.`);
                if (currentLanguage.name && languageSelector.value !== currentLanguage.name) {
                    languageSelector.value = currentLanguage.name; // Revert selector if switch failed
                }
            }
        }

        function saveData() {
            if (currentLanguage.name) { // Only save to allLanguages if current lang is named
                const existingLangIndex = allLanguages.findIndex(lang => lang.name === currentLanguage.name);
                const langToSave = JSON.parse(JSON.stringify(currentLanguage)); // Deep copy

                if (existingLangIndex > -1) {
                    allLanguages[existingLangIndex] = langToSave;
                } else {
                    allLanguages.push(langToSave);
                }
                renderLanguageSelector(); // Update dropdown if new lang added or name changed (though name change isn't UI implemented yet)
                localStorage.setItem('allLanguagesData', JSON.stringify(allLanguages));
            }
            localStorage.setItem('currentLanguageData', JSON.stringify(currentLanguage));
            localStorage.setItem('globalInterLangRules', JSON.stringify(globalInterLangRules)); // Save global rules
            console.log("Autosaved. Current lang:", currentLanguage.name, "All langs count:", allLanguages.length);
        }

        function loadData() {
            const savedAllLangs = localStorage.getItem('allLanguagesData');
            if (savedAllLangs) {
                const parsedAllLangs = JSON.parse(savedAllLangs);
                allLanguages = parsedAllLangs.map(lang => ensureDeepStructure(lang, DEFAULT_LANGUAGE_STATE));
            } else {
                allLanguages = [];
            }

            const savedGlobalRules = localStorage.getItem('globalInterLangRules');
            if (savedGlobalRules) {
                globalInterLangRules = JSON.parse(savedGlobalRules);
                nextInterLangPairId = calculateNextId(globalInterLangRules || [], 'il_pair_');
            } else {
                globalInterLangRules = [];
            }

            const savedLangData = localStorage.getItem('currentLanguageData');
            let langToLoad = null;

            if (savedLangData) {
                const parsedSavedLang = JSON.parse(savedLangData);
                if (parsedSavedLang.name) {
                    // Try to find the version from allLanguages first, as it might be more "canonical" if currentLanguageData was stale
                    const foundInAll = allLanguages.find(l => l.name === parsedSavedLang.name);
                    langToLoad = foundInAll ? JSON.parse(JSON.stringify(foundInAll)) : parsedSavedLang;
                } else { 
                    // If currentLanguageData has no name (e.g., user was creating new one and closed tab)
                    // load it as is, it will likely trigger the name modal or be overwritten if allLanguages has content.
                     langToLoad = parsedSavedLang; 
                }
            } else if (allLanguages.length > 0) {
                // No specific "current" language, load the first from allLanguages
                langToLoad = JSON.parse(JSON.stringify(allLanguages[0])); 
            }

            if (langToLoad) {
                 currentLanguage = ensureDeepStructure(langToLoad, DEFAULT_LANGUAGE_STATE);
            } else { // Absolutely no data anywhere
                currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE); // Fresh default state
            }
            
            // Initialize next IDs based on the loaded currentLanguage
            nextWordId = calculateNextWordId(currentLanguage.lexicon);
            nextConjCategoryId = calculateNextId(currentLanguage.grammar.morphology.conjugationCategories || [], 'cat_');
            nextConjRuleId = calculateNextId(currentLanguage.grammar.morphology.conjugationRules || [], 'rule_');
            // nextRuleStepId is recalculated within ensureDeepStructure based on the loaded language's content.
            nextExternalNodeId = calculateNextId(currentLanguage.languageFamily.externalNodes || [], 'ext_');
            nextActiveSoundChangeId = calculateNextId(currentLanguage.phonology.activeSoundChanges || [], 'asc_');
            nextToneId = calculateNextId(currentLanguage.phonology.tones || [], 'tone_');
            nextTonePhonotacticId = calculateNextId(currentLanguage.phonology.tonePhonotactics || [], 'tp_');


            console.log("Data loaded. Current Lang:", currentLanguage.name, "Next Word ID:", nextWordId, "Next RuleStep ID (after load):", nextRuleStepId);
            renderLanguageSelector(); // Populate dropdown
        }
        
        function calculateNextId(itemsArray = [], prefix = '') {
            if (!itemsArray || itemsArray.length === 0) return 1;
            const maxId = itemsArray.reduce((max, item) => {
                // Extract numeric part of ID, e.g., "cat_123" -> 123
                const numPart = item && item.id ? parseInt(String(item.id).replace(prefix, '').match(/\d+$/)?.[0]) : 0;
                return Math.max(max, isNaN(numPart) ? 0 : numPart);
            }, 0);
            return maxId + 1;
        }


        function calculateNextWordId(lexicon = []) {
            if (lexicon && lexicon.length > 0) {
                return lexicon.reduce((max, word) => Math.max(max, word.id || 0), 0) + 1;
            }
            return 1;
        }

        function renderLanguageSelector() {
            if (!languageSelector) return;
            const currentSelectedValue = languageSelector.value; // Preserve selection if possible
            languageSelector.innerHTML = '<option value="" class="bg-white text-gray-700">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>';
            allLanguages.forEach(lang => {
                if (lang.name) { // Only add named languages
                    const option = document.createElement('option');
                    option.value = lang.name;
                    option.textContent = lang.name;
                    option.className = "bg-white text-gray-700";
                    languageSelector.appendChild(option);
                }
            });
            // Try to re-select what was active or previously selected
            if (currentLanguage.name && allLanguages.some(l => l.name === currentLanguage.name)) {
                languageSelector.value = currentLanguage.name;
            } else if (currentSelectedValue && allLanguages.some(l => l.name === currentSelectedValue)) {
                 languageSelector.value = currentSelectedValue; // e.g. after deleting current, reselect previous
            } else if (allLanguages.length > 0 && !currentLanguage.name) { 
                 // If current lang is unnamed (being created) but others exist, selector should show none
                 languageSelector.value = ""; 
            } else { // No current lang name, no previous selection, or current not in list
                 languageSelector.value = "";
            }
        }

        function updateUI() {
            if (currentLanguage && currentLanguage.name) {
                 currentLanguageNameDisplay.textContent = currentLanguage.name;
                 if (languageSelector.value !== currentLanguage.name) languageSelector.value = currentLanguage.name;
                 mainContent.classList.remove('disabled-section');
                 renderTabs(); // Re-render tabs (buttons)
                 switchTab(activeTab); // Re-render content of current tab
            } else if (allLanguages.length === 0 && !currentLanguage.name) { // No languages exist, current is unnamed (fresh start)
                currentLanguageNameDisplay.textContent = 'N/A';
                mainContent.classList.add('disabled-section');
                if (languageNameModal.classList.contains('hidden')) { // If modal was closed somehow without naming
                     languageNameModal.classList.remove('hidden'); // Re-show it
                }
                tabContainer.innerHTML = ''; // No tabs to show
                tabContentContainer.innerHTML = ''; // No content
            } else { // Current language is unnamed (e.g. "Add New" clicked), but other languages might exist
                currentLanguageNameDisplay.textContent = 'N/A';
                if (!languageNameModal.classList.contains('hidden')) { // If name modal is up for the new lang
                    mainContent.classList.add('disabled-section');
                    tabContainer.innerHTML = ''; // No tabs until named
                    tabContentContainer.innerHTML = '';
                } else { // Name modal is hidden (e.g. user closed it, or selected "--‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤--")
                     mainContent.classList.remove('disabled-section'); // Allow interaction with header (like lang selector)
                     tabContainer.innerHTML = ''; // No tabs active for "no language" state
                     tabContentContainer.innerHTML = '<p class="text-center text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏°‡∏ô‡∏π‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà</p>';
                }
            }
        }

        function renderTabs() {
            tabContainer.innerHTML = '';
            tabs.filter(t => !t.disabled).forEach(tab => { // Only render non-disabled tabs
                const button = document.createElement('button');
                button.className = `tab-button py-2 px-4 font-medium text-sm rounded-t-lg border-b-2 whitespace-nowrap ${activeTab === tab.id ? 'active' : ''}`;
                button.innerHTML = `<i class="${tab.icon} mr-2"></i>${tab.name}`;
                button.addEventListener('click', () => switchTab(tab.id));
                tabContainer.appendChild(button);
            });
        }

        function switchTab(tabId) {
            // Prevent tab switching if language name modal is active and language is not yet named
            if (!currentLanguage.name && !languageNameModal.classList.contains('hidden')) {
                console.log("Language not named yet (modal visible), tab switch prevented.");
                return;
            }
             // If language is unnamed, modal is hidden, and no languages exist at all (first run, user closed modal)
             if (!currentLanguage.name && languageNameModal.classList.contains('hidden') && allLanguages.length === 0) {
                 tabContentContainer.innerHTML = '<p class="text-center text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÇ‡∏î‡∏¢‡∏Ñ‡∏•‡∏¥‡∏Å "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà" ‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô</p>';
                 activeTab = tabId; // Still update activeTab conceptually
                 renderTabs(); // Re-render tab buttons to reflect active state
                 return;
            }
             // If language is unnamed, modal is hidden, but other languages *do* exist (e.g. user hit "Add New" then closed modal)
             if (!currentLanguage.name && languageNameModal.classList.contains('hidden') && allLanguages.length > 0) {
                 tabContentContainer.innerHTML = '<p class="text-center text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà</p>';
                 activeTab = tabId;
                 renderTabs();
                 return;
             }


            activeTab = tabId;
            const currentTabDef = tabs.find(t => t.id === tabId);
            const actualContentContainer = document.getElementById('tabContent'); // Ensure we are using the correct one
            if (actualContentContainer) {
                 actualContentContainer.innerHTML = ''; // Clear previous content
                 if (currentTabDef) {
                    const titleEl = document.createElement('h3');
                    titleEl.className = "text-xl font-semibold mb-4 text-purple-700";
                    titleEl.innerHTML = `<i class="${currentTabDef.icon} mr-2"></i>${currentTabDef.name}`;
                    actualContentContainer.appendChild(titleEl);

                    if (typeof currentTabDef.contentFunc === 'function') {
                        currentTabDef.contentFunc(actualContentContainer); // Pass the content container
                    } else {
                        const errorP = document.createElement('p');
                        errorP.textContent = 'Error: Content function not found for this tab.';
                        actualContentContainer.appendChild(errorP);
                    }
                }
            }
            renderTabs(); // Re-render tab buttons to update active state
        }

        function createTextInput(container, label, id, value, placeholder = '', helpText = '', inputType = 'text', listId = null) {
            const div = document.createElement('div');
            div.className = 'mb-3';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-gray-700 mb-1';
            labelEl.setAttribute('for', id);
            labelEl.textContent = label;
            div.appendChild(labelEl);
            const inputEl = document.createElement(inputType === 'textarea' ? 'textarea' : 'input');
            inputEl.type = inputType === 'textarea' ? undefined : inputType;
            inputEl.id = id;
            inputEl.name = id;
            inputEl.className = 'w-full p-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500';
            inputEl.placeholder = placeholder;
            if (inputType === 'textarea') inputEl.rows = 3;
            if (listId) inputEl.setAttribute('list', listId);
            inputEl.value = value;
            div.appendChild(inputEl);
            if (helpText) {
                const helpEl = document.createElement('p');
                helpEl.className = 'mt-1 text-xs text-gray-500';
                helpEl.innerHTML = helpText; // Use innerHTML to allow for simple tags in helptext if needed
                div.appendChild(helpEl);
            }
            container.appendChild(div);
            return inputEl;
        }

        function createSelectInput(container, label, id, value, optionsArray, helpText = '', multiple = false) {
            const div = document.createElement('div');
            div.className = 'mb-3';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-gray-700 mb-1';
            labelEl.setAttribute('for', id);
            labelEl.textContent = label;
            div.appendChild(labelEl);
            const selectEl = document.createElement('select');
            selectEl.id = id;
            selectEl.name = id;
            selectEl.className = 'w-full p-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500';
            if (multiple) {
                selectEl.multiple = true;
                selectEl.size = Math.min(5, optionsArray.length); // Show a few items for multi-select
            }

            optionsArray.forEach(opt => {
                const option = document.createElement('option');
                if (typeof opt === 'string') {
                    option.value = opt;
                    option.textContent = opt;
                } else { // Expect {value: 'val', text: 'Display Text'}
                    option.value = opt.value;
                    option.textContent = opt.text;
                }
                selectEl.appendChild(option);
            });
            // Set selected value(s)
            if (multiple && Array.isArray(value)) {
                 Array.from(selectEl.options).forEach(opt => {
                    if (value.includes(opt.value)) {
                        opt.selected = true;
                    }
                });
            } else {
                selectEl.value = value;
            }
            div.appendChild(selectEl);
             if (helpText) {
                const helpEl = document.createElement('p');
                helpEl.className = 'mt-1 text-xs text-gray-500';
                helpEl.innerHTML = helpText;
                div.appendChild(helpEl);
            }
            container.appendChild(div);
            return selectEl;
        }
        
        function createCheckboxInput(container, label, id, checked, helpText = '', onChangeCallback = null) {
            const div = document.createElement('div');
            div.className = 'mb-3 flex items-center';
            const inputEl = document.createElement('input');
            inputEl.type = 'checkbox';
            inputEl.id = id;
            inputEl.name = id;
            inputEl.className = 'h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500 mr-2';
            inputEl.checked = checked;
            if (onChangeCallback) {
                inputEl.onchange = onChangeCallback;
            }
            div.appendChild(inputEl);
            const labelEl = document.createElement('label');
            labelEl.className = 'text-sm font-medium text-gray-700';
            labelEl.setAttribute('for', id);
            labelEl.textContent = label;
            div.appendChild(labelEl);
            if (helpText) {
                const helpEl = document.createElement('p');
                helpEl.className = 'ml-2 text-xs text-gray-500'; // Adjust margin if needed
                helpEl.innerHTML = helpText;
                div.appendChild(helpEl);
            }
            container.appendChild(div);
            return inputEl;
        }

        function createListInput(container, label, itemsArray, placeholder, addItemCallback, removeItemCallback, itemDisplayFunc = null, helpText = '', inputType = 'text', datalistId = null) {
            const section = document.createElement('div');
            section.className = 'mb-4 p-3 border border-purple-200 rounded-md bg-purple-50';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-purple-700 mb-1';
            labelEl.textContent = label;
            section.appendChild(labelEl);
            if (helpText) {
                const helpP = document.createElement('p');
                helpP.className = 'text-xs text-gray-500 mb-2';
                helpP.innerHTML = helpText;
                section.appendChild(helpP);
            }

            const listContainer = document.createElement('div');
            listContainer.className = 'flex flex-wrap gap-2 mb-2';
            (itemsArray || []).forEach((item, index) => {
                const chip = document.createElement('span');
                chip.className = 'bg-purple-500 text-white px-2 py-1 rounded-full text-xs flex items-center';
                chip.innerHTML = itemDisplayFunc ? itemDisplayFunc(item) : (typeof item === 'string' ? item : JSON.stringify(item));
                const removeBtn = document.createElement('button');
                removeBtn.className = 'ml-2 text-purple-200 hover:text-white';
                removeBtn.innerHTML = '&times;';
                removeBtn.onclick = (e) => { e.stopPropagation(); removeItemCallback(index); }; // Prevent form submission if inside form
                chip.appendChild(removeBtn);
                listContainer.appendChild(chip);
            });
            section.appendChild(listContainer);

            const inputGroup = document.createElement('div');
            inputGroup.className = 'flex gap-2';
            const inputEl = document.createElement('input');
            inputEl.type = inputType;
            if (datalistId) inputEl.setAttribute('list', datalistId);
            inputEl.className = 'w-full p-2 border border-purple-300 rounded-md focus:ring-purple-500 focus:border-transparent';
            inputEl.placeholder = placeholder;
            inputEl.onkeypress = (e) => { if (e.key === 'Enter') { addBtn.click(); e.preventDefault(); }}; // Add on Enter
            const addBtn = document.createElement('button');
            addBtn.type = "button"; // Ensure it doesn't submit forms by default
            addBtn.className = 'btn-secondary px-3 py-1 rounded-md text-sm';
            addBtn.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°';
            addBtn.onclick = () => {
                if (inputEl.value.trim()) {
                    addItemCallback(inputEl.value.trim());
                    inputEl.value = ''; // Clear after adding
                }
            };
            inputGroup.appendChild(inputEl);
            inputGroup.appendChild(addBtn);
            section.appendChild(inputGroup);
            container.appendChild(section);
            return section; // Return the whole section for further manipulation if needed
        }
        
        function createCheckboxList(container, label, allItems, selectedItems, updateCallback, helpText = '', options = {}) {
            const section = document.createElement('div');
            section.className = 'mb-4 p-3 border border-purple-200 rounded-md bg-purple-50';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex justify-between items-center mb-2';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-purple-700';
            labelEl.textContent = label;
            headerDiv.appendChild(labelEl);

            if (options.showSelectAll) {
                const selectButtonsDiv = document.createElement('div');
                selectButtonsDiv.className = 'flex gap-2';
                const selectAllBtn = document.createElement('button');
                selectAllBtn.type = "button";
                selectAllBtn.textContent = '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
                selectAllBtn.className = 'text-xs btn-secondary bg-purple-300 hover:bg-purple-400 text-purple-800 px-2 py-0.5 rounded';
                selectAllBtn.onclick = () => {
                    allItems.forEach(item => {
                        if (!selectedItems.includes(item)) {
                            updateCallback(item, true, true); // true for batch update
                        }
                    });
                    if (options.onSelectAllDeselectAll) options.onSelectAllDeselectAll(); // Call general refresh
                };
                selectButtonsDiv.appendChild(selectAllBtn);

                const deselectAllBtn = document.createElement('button');
                deselectAllBtn.type = "button";
                deselectAllBtn.textContent = '‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
                deselectAllBtn.className = 'text-xs btn-secondary bg-gray-300 hover:bg-gray-400 text-gray-800 px-2 py-0.5 rounded';
                deselectAllBtn.onclick = () => {
                    allItems.forEach(item => {
                        if (selectedItems.includes(item)) {
                             updateCallback(item, false, true); // true for batch update
                        }
                    });
                    if (options.onSelectAllDeselectAll) options.onSelectAllDeselectAll();
                };
                selectButtonsDiv.appendChild(deselectAllBtn);
                headerDiv.appendChild(selectButtonsDiv);
            }
            section.appendChild(headerDiv);

            if (helpText) {
                const helpP = document.createElement('p');
                helpP.className = 'text-xs text-gray-500 mb-2';
                helpP.innerHTML = helpText;
                section.appendChild(helpP);
            }

            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-2';
            
            allItems.forEach(item => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'flex items-center';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `chk_${label.replace(/\s+/g, '')}_${item.replace(/[^a-zA-Z0-9]/g, "")}`; // Make ID more robust
                checkbox.value = item;
                checkbox.className = 'h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500 mr-1.5';
                checkbox.checked = selectedItems.includes(item);
                checkbox.onchange = (e) => {
                    updateCallback(item, e.target.checked); // Individual update
                };
                
                const itemLabel = document.createElement('label');
                itemLabel.setAttribute('for', checkbox.id);
                itemLabel.className = 'text-sm text-gray-700';
                itemLabel.textContent = item;
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(itemLabel);
                gridContainer.appendChild(checkboxDiv);
            });
            section.appendChild(gridContainer);
            container.appendChild(section);
        }


        function renderPhonologyUI(container) {
            const phonology = currentLanguage.phonology;

            // Ensure all phonology sub-properties exist, defaulting from DEFAULT_LANGUAGE_STATE
            phonology.allowedInitialConsonants = phonology.allowedInitialConsonants || [...(DEFAULT_LANGUAGE_STATE.phonology.allowedInitialConsonants.length > 0 ? DEFAULT_LANGUAGE_STATE.phonology.allowedInitialConsonants : phonology.consonants)];
            phonology.allowVowelInitial = phonology.allowVowelInitial === undefined ? DEFAULT_LANGUAGE_STATE.phonology.allowVowelInitial : phonology.allowVowelInitial;
            phonology.forbiddenInitialSounds = phonology.forbiddenInitialSounds || [...DEFAULT_LANGUAGE_STATE.phonology.forbiddenInitialSounds];
            phonology.allowedConsonantClusters = phonology.allowedConsonantClusters || [...DEFAULT_LANGUAGE_STATE.phonology.allowedConsonantClusters];
            phonology.forbiddenConsonantClusters = phonology.forbiddenConsonantClusters || [...DEFAULT_LANGUAGE_STATE.phonology.forbiddenConsonantClusters];
            phonology.maxClusterLength = phonology.maxClusterLength || DEFAULT_LANGUAGE_STATE.phonology.maxClusterLength;
            phonology.allowedFinalConsonants = phonology.allowedFinalConsonants || [...(DEFAULT_LANGUAGE_STATE.phonology.allowedFinalConsonants.length > 0 ? DEFAULT_LANGUAGE_STATE.phonology.allowedFinalConsonants : phonology.consonants.filter(c => ['m','n','≈ã','p','t','k','s'].includes(c)))];
            phonology.allowNoCoda = phonology.allowNoCoda === undefined ? DEFAULT_LANGUAGE_STATE.phonology.allowNoCoda : phonology.allowNoCoda;
            phonology.forbiddenFinalSounds = phonology.forbiddenFinalSounds || [...DEFAULT_LANGUAGE_STATE.phonology.forbiddenFinalSounds];
            phonology.allowClusterCoda = phonology.allowClusterCoda === undefined ? DEFAULT_LANGUAGE_STATE.phonology.allowClusterCoda : phonology.allowClusterCoda;
            phonology.allowedCodaClusters = phonology.allowedCodaClusters || [...DEFAULT_LANGUAGE_STATE.phonology.allowedCodaClusters];
            phonology.hasTones = phonology.hasTones === undefined ? DEFAULT_LANGUAGE_STATE.phonology.hasTones : phonology.hasTones;
            phonology.tones = phonology.tones || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.tones));
             phonology.tones.forEach(tone => { // Ensure new property exists on old data
                if (tone.hideInOrthography === undefined) tone.hideInOrthography = false;
            });
            phonology.tonePhonotactics = phonology.tonePhonotactics || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.tonePhonotactics));
            phonology.graphemeMappings = phonology.graphemeMappings || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.graphemeMappings));
            phonology.activeSoundChanges = phonology.activeSoundChanges || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.activeSoundChanges));
            phonology.syllableStructures = phonology.syllableStructures || [...DEFAULT_LANGUAGE_STATE.phonology.syllableStructures];
            phonology.phonotactics = phonology.phonotactics || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.phonotactics));

            // Data cleaning: ensure selected phonemes/clusters exist in the main inventory
            const currentConsonants = phonology.consonants || [];
            const currentVowels = phonology.vowels || [];
            const allCurrentPhonemes = [...currentConsonants, ...currentVowels];

            phonology.allowedInitialConsonants = (phonology.allowedInitialConsonants || []).filter(c => currentConsonants.includes(c));
            phonology.forbiddenInitialSounds = (phonology.forbiddenInitialSounds || []).filter(s => allCurrentPhonemes.includes(s));
            phonology.allowedConsonantClusters = (phonology.allowedConsonantClusters || []).filter(cl => cl.split('').every(c => currentConsonants.includes(c)));
            
            phonology.allowedFinalConsonants = (phonology.allowedFinalConsonants || []).filter(c => currentConsonants.includes(c));
            phonology.forbiddenFinalSounds = (phonology.forbiddenFinalSounds || []).filter(s => allCurrentPhonemes.includes(s));
            phonology.allowedCodaClusters = (phonology.allowedCodaClusters || []).filter(cl => cl.split('').every(c => currentConsonants.includes(c)));
            
            phonology.graphemeMappings = (phonology.graphemeMappings || []).filter(gm => allCurrentPhonemes.includes(gm.sound));

            phonology.tonePhonotactics = (phonology.tonePhonotactics || []).map(tpRule => ({
                ...tpRule,
                initials: (tpRule.initials || []).filter(i => currentConsonants.includes(i)),
                finals: (tpRule.finals || []).filter(f => currentConsonants.includes(f))
            })).filter(tpRule => (tpRule.initials && tpRule.initials.length > 0) || (tpRule.finals && tpRule.finals.length > 0) || (tpRule.forbiddenTones && tpRule.forbiddenTones.length > 0) || (tpRule.description && tpRule.description.length > 0) ); // Keep if any part has data


            const phonologyContainerId = 'phonologyTabSpecificContent';
            let phonologyContainer = container.querySelector(`#${phonologyContainerId}`);
            if (!phonologyContainer) {
                phonologyContainer = document.createElement('div');
                phonologyContainer.id = phonologyContainerId;
                container.appendChild(phonologyContainer);
            }
            phonologyContainer.innerHTML = ''; // Clear for re-render

            // Datalist for phoneme suggestions
            const phonemeDatalistId = `phonemeDatalist_${Date.now()}`;
            let phonemeOptions = '';
            const allPhonemes = [...new Set([...phonology.consonants, ...phonology.vowels])];
            allPhonemes.forEach(p => phonemeOptions += `<option value="${p}"></option>`);
            phonologyContainer.innerHTML += `<datalist id="${phonemeDatalistId}">${phonemeOptions}</datalist>`;

            const basicPhonemesSection = document.createElement('div');
            basicPhonemesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            basicPhonemesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">1. ‡∏ä‡∏∏‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (Phonemic Inventory)</h4>`;
            createListInput(basicPhonemesSection, 'üó£Ô∏è ‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ (Consonants)', phonology.consonants, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ (‡πÄ‡∏ä‡πà‡∏ô p, t, k)",
                (item) => { phonology.consonants.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.consonants.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            createListInput(basicPhonemesSection, 'üé§ ‡∏™‡∏£‡∏∞ (Vowels)', phonology.vowels, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞ (‡πÄ‡∏ä‡πà‡∏ô a, i, u)",
                (item) => { phonology.vowels.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.vowels.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            phonologyContainer.appendChild(basicPhonemesSection);

            const ipaChartsSection = document.createElement('div');
            ipaChartsSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            ipaChartsSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">2. ‡∏ï‡∏≤‡∏£‡∏≤‡∏á IPA (‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•)</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><h5 class="font-medium text-purple-600 mb-1">‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ IPA</h5><div id="ipaConsonantChartContainerPhonology"></div></div>
                    <div><h5 class="font-medium text-purple-600 mb-1">‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏£‡∏∞ IPA</h5><div id="ipaVowelChartContainerPhonology"></div></div>
                </div>`;
            phonologyContainer.appendChild(ipaChartsSection);
            renderDynamicIPACharts(phonology.consonants, phonology.vowels); // Call to render charts

            const consonantRolesSection = document.createElement('div');
            consonantRolesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            consonantRolesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">3. ‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå</h4>`;
            
            const initialCSection = document.createElement('div');
            initialCSection.className = 'mb-3 p-2 border-t pt-3';
            createCheckboxList(initialCSection, '‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Allowed Initial Consonants):', phonology.consonants, phonology.allowedInitialConsonants, 
                (item, isChecked, batchUpdate) => {
                    if (isChecked) { if (!phonology.allowedInitialConsonants.includes(item)) phonology.allowedInitialConsonants.push(item); } 
                    else { phonology.allowedInitialConsonants = phonology.allowedInitialConsonants.filter(c => c !== item); }
                    if (!batchUpdate) { saveData(); renderPhonologyUI(container); } // Re-render only if not batch
                }, '', { showSelectAll: true, onSelectAllDeselectAll: () => { saveData(); renderPhonologyUI(container); } }
            );
            createCheckboxInput(initialCSection, '‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏™‡∏£‡∏∞ (Vowel-Initial Words)', 'allowVowelInitialPhonology', phonology.allowVowelInitial, '', (e) => {
                phonology.allowVowelInitial = e.target.checked; saveData();
            });
            createListInput(initialCSection, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≤‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô (Forbidden Initial Sounds)', phonology.forbiddenInitialSounds, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏ä‡πà‡∏ô ≈ã)",
                (item) => { phonology.forbiddenInitialSounds.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.forbiddenInitialSounds.splice(index, 1); renderPhonologyUI(container); saveData(); }, null, '', 'text', phonemeDatalistId
            );
            consonantRolesSection.appendChild(initialCSection);

            const clusterSection = document.createElement('div');
            clusterSection.className = 'mb-3 p-2 border-t pt-3';
            clusterSection.innerHTML = `<h5 class="font-medium text-purple-600 mb-2">‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥ (Consonant Clusters)</h5>`;
             createListInput(clusterSection, '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Allowed Clusters)', phonology.allowedConsonantClusters, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏° (‡πÄ‡∏ä‡πà‡∏ô kr, spl)",
                (item) => { phonology.allowedConsonantClusters.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.allowedConsonantClusters.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            createListInput(clusterSection, '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Forbidden Clusters)', phonology.forbiddenConsonantClusters, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏´‡πâ‡∏≤‡∏° (‡πÄ‡∏ä‡πà‡∏ô tl)",
                (item) => { phonology.forbiddenConsonantClusters.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.forbiddenConsonantClusters.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            const maxClusterLengthInput = createTextInput(clusterSection, '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥:', 'maxClusterLengthPhonology', phonology.maxClusterLength, '‡πÄ‡∏ä‡πà‡∏ô 2 ‡∏´‡∏£‡∏∑‡∏≠ 3', '', 'number');
            maxClusterLengthInput.min = 2; maxClusterLengthInput.max = 5; // Sensible limits
            maxClusterLengthInput.onchange = (e) => { phonology.maxClusterLength = parseInt(e.target.value) || 2; saveData(); };
            consonantRolesSection.appendChild(clusterSection);

            const finalCSection = document.createElement('div');
            finalCSection.className = 'mb-3 p-2 border-t pt-3';
            createCheckboxList(finalCSection, '‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Allowed Final Consonants):', phonology.consonants, phonology.allowedFinalConsonants,
                (item, isChecked, batchUpdate) => {
                    if (isChecked) { if (!phonology.allowedFinalConsonants.includes(item)) phonology.allowedFinalConsonants.push(item); }
                    else { phonology.allowedFinalConsonants = phonology.allowedFinalConsonants.filter(c => c !== item); }
                    if (!batchUpdate) { saveData(); renderPhonologyUI(container); }
                }, '', { showSelectAll: true, onSelectAllDeselectAll: () => { saveData(); renderPhonologyUI(container); } }
            );
            createCheckboxInput(finalCSection, '‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Allow No Coda / Open Syllables)', 'allowNoCodaPhonology', phonology.allowNoCoda, '', (e) => {
                phonology.allowNoCoda = e.target.checked; saveData();
            });
            createListInput(finalCSection, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Forbidden Final Sounds)', phonology.forbiddenFinalSounds, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏ä‡πà‡∏ô s ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ /s/ ‡∏™‡∏∞‡∏Å‡∏î)",
                (item) => { phonology.forbiddenFinalSounds.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.forbiddenFinalSounds.splice(index, 1); renderPhonologyUI(container); saveData(); }, null, '', 'text', phonemeDatalistId
            );
            createCheckboxInput(finalCSection, '‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Allow Consonant Clusters as Coda)', 'allowClusterCodaPhonology', phonology.allowClusterCoda, '', (e) => {
                phonology.allowClusterCoda = e.target.checked; renderPhonologyUI(container); saveData();
            });
            if (phonology.allowClusterCoda) {
                 createListInput(finalCSection, '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Allowed Coda Clusters)', phonology.allowedCodaClusters, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏° (‡πÄ‡∏ä‡πà‡∏ô nt, lk)",
                    (item) => { phonology.allowedCodaClusters.push(item); renderPhonologyUI(container); saveData(); },
                    (index) => { phonology.allowedCodaClusters.splice(index, 1); renderPhonologyUI(container); saveData(); }
                );
            }

            consonantRolesSection.appendChild(finalCSection);

            createListInput(consonantRolesSection, 'üß± ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå (Syllable Structures)', phonology.syllableStructures, "‡πÄ‡∏ä‡πà‡∏ô CV, CVC, CCVVC",
                (item) => { phonology.syllableStructures.push(item.toUpperCase()); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.syllableStructures.splice(index, 1); renderPhonologyUI(container); saveData(); },
                null, "C = ‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞, V = ‡∏™‡∏£‡∏∞"
            );
            phonologyContainer.appendChild(consonantRolesSection);


            const tonesSection = document.createElement('div');
            tonesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            tonesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">4. ‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå (Tones)</h4>`;
            createCheckboxInput(tonesSection, '‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå (Enable Tones)', 'hasTonesPhonology', phonology.hasTones, '', (e) => {
                phonology.hasTones = e.target.checked;
                renderPhonologyUI(container); saveData();
            });

            if (phonology.hasTones) {
                const toneManagementDiv = document.createElement('div');
                toneManagementDiv.id = 'toneManagementSectionPhonology';
                toneManagementDiv.className = 'mt-2 p-2 border-t';
                
                const tonesListDiv = document.createElement('div');
                tonesListDiv.className = 'mb-2 space-y-1';
                (phonology.tones || []).forEach(tone => {
                    const toneDisplay = document.createElement('div');
                    toneDisplay.className = 'flex justify-between items-center bg-white p-1.5 rounded border text-sm';
                    toneDisplay.innerHTML = `<span>${tone.name} (‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå: ${tone.representation || 'N/A'}, ‡πÄ‡∏•‡∏Ç: ${tone.number}) ${tone.hideInOrthography ? '<em class="text-xs text-gray-500">(‡∏ã‡πà‡∏≠‡∏ô‡∏£‡∏π‡∏õ)</em>' : ''}</span>
                                           <button class="text-red-500 hover:text-red-700 text-xs" onclick="removeTonePhonology('${tone.id}')">&times; ‡∏•‡∏ö</button>`;
                    tonesListDiv.appendChild(toneDisplay);
                });
                toneManagementDiv.appendChild(tonesListDiv);

                const addToneForm = document.createElement('div');
                addToneForm.className = 'grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2 items-end p-2 border bg-purple-100 rounded';
                addToneForm.innerHTML = `
                    <div class="flex-grow"><label class="text-xs">‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå:</label><input type="text" id="newToneNamePhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏≠‡∏Å" class="w-full p-1 border rounded text-sm"></div>
                    <div class="flex-grow"><label class="text-xs">‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå (‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•):</label><input type="text" id="newToneRepresentationPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô ¬π ‡∏´‡∏£‡∏∑‡∏≠ L" class="w-full p-1 border rounded text-sm"></div>
                    <div><label class="text-xs">‡πÄ‡∏•‡∏Ç‡πÅ‡∏ó‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á:</label>
                        <select id="newToneNumberPhonology" class="w-full p-1 border rounded text-sm">
                            <option value="0">0 (‡∏™‡∏≤‡∏°‡∏±‡∏ç/‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ)</option>
                            <option value="1">1 (‡πÄ‡∏≠‡∏Å)</option>
                            <option value="2">2 (‡πÇ‡∏ó)</option>
                            <option value="3">3 (‡∏ï‡∏£‡∏µ)</option>
                            <option value="4">4 (‡∏à‡∏±‡∏ï‡∏ß‡∏≤)</option>
                            <option value="5">5</option> <option value="6">6</option> <option value="7">7</option> <option value="8">8</option> <option value="9">9</option>
                        </select>
                    </div>
                     <div class="flex items-center mt-1 md:mt-0"><input type="checkbox" id="newToneHideInOrthographyPhonology" class="h-3.5 w-3.5 mr-1"><label for="newToneHideInOrthographyPhonology" class="text-xs">‡∏ã‡πà‡∏≠‡∏ô‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ</label></div>
                    <button id="addToneButtonPhonology" class="btn-secondary px-2 py-1 rounded text-sm self-end sm:col-span-2 md:col-auto">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå</button>
                `;
                toneManagementDiv.appendChild(addToneForm);
                tonesSection.appendChild(toneManagementDiv);

                const tonePhonotacticsDiv = document.createElement('div');
                tonePhonotacticsDiv.className = 'mt-3 p-2 border-t';
                tonePhonotacticsDiv.innerHTML = `<h5 class="font-medium text-purple-600 mb-2">‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå (Tone Phonotactics)</h5>
                     <div id="tonePhonotacticsListPhonology" class="max-h-40 overflow-y-auto space-y-1 mb-2"></div>
                     <div class="p-2 border bg-purple-100 rounded">
                         <h6 class="text-sm font-semibold mb-1">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡πÉ‡∏´‡∏°‡πà:</h6>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-2 items-end">
                             <div><label class="text-xs">‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô (‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="tpRuleInitials" placeholder="‡πÄ‡∏ä‡πà‡∏ô k,ph,t" class="w-full p-1 border rounded text-xs" list="${phonemeDatalistId}"></div>
                             <div><label class="text-xs">‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡πâ‡∏≤‡∏¢ (‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="tpRuleFinals" placeholder="‡πÄ‡∏ä‡πà‡∏ô m,≈ã" class="w-full p-1 border rounded text-xs" list="${phonemeDatalistId}"></div>
                             <div><label class="text-xs">‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏´‡πâ‡∏≤‡∏° (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£):</label><select id="tpRuleForbiddenTones" multiple class="w-full p-1 border rounded text-xs h-16"></select></div>
                             <div class="md:col-span-2"><label class="text-xs">‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏é:</label><input type="text" id="tpRuleDescription" placeholder="‡πÄ‡∏ä‡πà‡∏ô ‡∏Å-‡πÄ‡∏õ‡πá‡∏ô + ‡∏°-‡∏™‡∏∞‡∏Å‡∏î ‡∏´‡πâ‡∏≤‡∏°‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÇ‡∏ó" class="w-full p-1 border rounded text-xs"></div>
                         </div>
                         <button id="addTonePhonotacticRuleBtn" class="btn-secondary px-2 py-1 mt-2 rounded text-sm">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå</button>
                     </div>`;
                tonesSection.appendChild(tonePhonotacticsDiv);
                renderTonePhonotacticsList();
                populateTonePhonotacticToneSelect();
            }
            phonologyContainer.appendChild(tonesSection);


            const graphemeMappingSection = document.createElement('div');
            graphemeMappingSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            graphemeMappingSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">5. ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ (Grapheme Mappings)</h4>
                <p class="text-xs text-gray-500 mb-2">‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏•‡∏∞‡∏ï‡∏¥‡∏ô‡πÅ‡∏ï‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏∞‡∏Å‡∏î‡πÅ‡∏ö‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô</p>
                <p class="text-xs text-gray-500 mb-2">‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ (transliterate) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ ‡∏à‡∏∞‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡πâ‡∏ô‡∏Ñ‡∏≥ (Initial) ‡∏´‡∏£‡∏∑‡∏≠‡∏ó‡πâ‡∏≤‡∏¢‡∏Ñ‡∏≥ (Final) ‡∏Å‡πà‡∏≠‡∏ô ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Å‡∏•‡∏≤‡∏á‡∏Ñ‡∏≥ ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡πâ‡∏ô‡∏Ñ‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞ ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡∏∞ (Vowel) ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ ‡∏Å‡∏≤‡∏£‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏à‡∏∞‡∏ó‡∏≥‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÜ ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ô‡∏≥‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏Ç‡∏≠‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô‡∏°‡∏≤‡∏õ‡∏ô‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏Ç‡∏≠‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡πâ‡∏≤‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏∏‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÜ</p>
                <div id="graphemeMappingListPhonology" class="space-y-3 mb-3 max-h-72 overflow-y-auto p-2 bg-white rounded"></div>
                <div class="flex flex-wrap gap-2 items-end p-2 border bg-purple-100 rounded">
                    <div class="flex-grow min-w-[100px]"><label class="text-xs">‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phoneme):</label><input type="text" id="graphemeMapSoundPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô k, a" class="w-full p-1 border rounded text-sm" list="${phonemeDatalistId}"></div>
                    <div class="flex-grow"><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô (Initial Graphemes - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="graphemeMapInitialPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô k, c" class="w-full p-1 border rounded text-sm"></div>
                    <div class="flex-grow"><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡πâ‡∏≤‡∏¢ (Final Graphemes - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="graphemeMapFinalPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô ck, k" class="w-full p-1 border rounded text-sm"></div>
                     <div class="flex-grow"><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏£‡∏∞/‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ (Vowel/General Graphemes - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="graphemeMapVowelPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô a, ah" class="w-full p-1 border rounded text-sm"></div>
                    <button id="addGraphemeMapButtonPhonology" class="btn-secondary px-2 py-1 rounded text-sm self-end">‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà</button>
                </div>`;
            phonologyContainer.appendChild(graphemeMappingSection);
            renderGraphemeMappingsList();


            const activeSCRulesSection = document.createElement('div');
            activeSCRulesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            activeSCRulesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">6. ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Active Sound Change Rules)</h4>
                <p class="text-xs text-gray-500 mb-2">‡∏Å‡∏é‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏ú‡∏•‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏©‡∏≤</p>
                <p class="text-xs text-gray-500 mb-2">X ‚Üí Y / A _ B ‡∏≠‡πà‡∏≤‡∏ô‡∏ß‡πà‡∏≤ "‡πÄ‡∏™‡∏µ‡∏¢‡∏á X ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô Y ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á A ‡∏Å‡∏±‡∏ö B</p>
                <p class="text-xs text-gray-500 mb-2">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á</p>
                 <p class="text-xs text-gray-500 mb-2">/t/ ‚Üí [s] / _ i ‚Üí ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô /t/ ‡πÄ‡∏õ‡πá‡∏ô /s/ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡∏™‡∏£‡∏∞ /i/</p>
                  <p class="text-xs text-gray-500 mb-2">/n/ ‚Üí [≈ã] / _ k ‚Üí /n/ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô /≈ã/ ‡∏ñ‡πâ‡∏≤‡∏ï‡∏≤‡∏°‡∏î‡πâ‡∏ß‡∏¢ /k/</p>
</p>
                <div id="activeSoundChangesListPhonology" class="space-y-1 mb-3 max-h-72 overflow-y-auto"></div>
                <div class="p-2 border bg-purple-100 rounded">
                    <h5 class="font-medium text-purple-600 mb-1">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡πÉ‡∏´‡∏°‡πà:</h5>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-3 gap-y-2 items-end">
                        <div><label class="text-xs">‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (From X):</label><input type="text" id="activeSCFromPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô t" class="w-full p-1 border rounded text-sm" list="${phonemeDatalistId}"></div>
                        <div><label class="text-xs">‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á (To Y):</label><input type="text" id="activeSCToPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô s" class="w-full p-1 border rounded text-sm" list="${phonemeDatalistId}"></div>
                        <div><label class="text-xs">‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ (Context A_):</label><input type="text" id="activeSCContextPrePhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô # (word start), V (vowel)" class="w-full p-1 border rounded text-sm"></div>
                        <div><label class="text-xs">‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á (_B Context):</label><input type="text" id="activeSCContextPostPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô i, # (word end)" class="w-full p-1 border rounded text-sm"></div>
                        <div class="md:col-span-2"><label class="text-xs">‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏é:</label><input type="text" id="activeSCDescPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô t > s / _i" class="w-full p-1 border rounded text-sm"></div>
                    </div>
                    <button id="addActiveSCRuleButtonPhonology" class="btn-secondary px-3 py-1.5 rounded text-sm mt-2">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á</button>
                </div>
                <div class="mt-4 p-2 border-t">
                    <h5 class="font-medium text-purple-600 mb-1">‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏é:</h5>
                    <input type="text" id="testActiveSCWordPhonology" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏ó‡∏î‡∏™‡∏≠‡∏ö (‡∏£‡∏π‡∏õ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á)" class="w-full p-1.5 border rounded text-sm mb-1">
                    <button id="applyActiveSCRulesTestBtnPhonology" class="btn-primary px-3 py-1 rounded text-sm">‡∏ó‡∏î‡∏™‡∏≠‡∏ö</button>
                    <div id="testActiveSCResultPhonology" class="mt-2 p-2 bg-white rounded border text-sm min-h-[50px]">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà...</div>
                </div>`;
            phonologyContainer.appendChild(activeSCRulesSection);
            renderActiveSoundChangesList();

            const phonotacticsSection = document.createElement('div');
            phonotacticsSection.className = 'mb-4 p-4 border border-purple-300 rounded-lg bg-purple-50';
            phonotacticsSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">7. ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ (General Phonotactics)</h4>`;
            const rulesList = document.createElement('div');
            (phonology.phonotactics || []).forEach((rule, index) => {
                const ruleDiv = document.createElement('div');
                ruleDiv.className = 'flex items-center justify-between p-2 mb-1 bg-white rounded border border-purple-100';
                ruleDiv.innerHTML = `
                    <span class="text-sm ${rule.enabled ? 'text-green-600' : 'text-red-600'}">${rule.rule} ${rule.custom && rule.pattern ? `(${rule.pattern})` : ''}</span>
                    <div>
                        <button class="text-xs ${rule.enabled ? 'bg-yellow-400 hover:bg-yellow-500' : 'bg-green-400 hover:bg-green-500'} text-white px-2 py-1 rounded" onclick="togglePhonotacticRule(${index})">${rule.enabled ? '‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' : '‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'}</button>
                        ${rule.custom ? `<button class="text-xs bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded ml-1" onclick="removeCustomPhonotacticRule(${index})">‡∏•‡∏ö</button>` : ''}
                    </div>
                `;
                rulesList.appendChild(ruleDiv);
            });
            phonotacticsSection.appendChild(rulesList);

            const addRuleGroup = document.createElement('div');
            addRuleGroup.className = 'mt-3 flex gap-2 items-center flex-wrap p-2 border-t';
            const ruleDescInput = document.createElement('input');
            ruleDescInput.type = 'text';
            ruleDescInput.placeholder = "‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏é (‡πÄ‡∏ä‡πà‡∏ô ‡∏´‡πâ‡∏≤‡∏° m ‡∏™‡∏∞‡∏Å‡∏î)";
            ruleDescInput.className = 'flex-grow p-2 border border-purple-300 rounded-md min-w-[200px]';
            const rulePatternInput = document.createElement('input');
            rulePatternInput.type = 'text';
            rulePatternInput.placeholder = "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö (‡πÄ‡∏ä‡πà‡∏ô *m# ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö regex)"; 
            rulePatternInput.className = 'flex-grow p-2 border border-purple-300 rounded-md min-w-[150px]';
            const addRuleBtn = document.createElement('button');
            addRuleBtn.className = 'btn-secondary px-3 py-2 rounded-md text-sm';
            addRuleBtn.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡πÄ‡∏≠‡∏á';
            addRuleBtn.onclick = () => {
                const desc = ruleDescInput.value.trim();
                const pattern = rulePatternInput.value.trim();
                if (desc) {
                    phonology.phonotactics.push({ rule: desc, type: "custom_regex", enabled: true, custom: true, pattern: pattern });
                    ruleDescInput.value = ''; rulePatternInput.value = '';
                    renderPhonologyUI(container); saveData();
                }
            };
            addRuleGroup.appendChild(ruleDescInput); addRuleGroup.appendChild(rulePatternInput); addRuleGroup.appendChild(addRuleBtn);
            phonotacticsSection.appendChild(addRuleGroup);
            phonologyContainer.appendChild(phonotacticsSection);


            if (phonology.hasTones) {
                const addToneBtn = document.getElementById('addToneButtonPhonology');
                if (addToneBtn) addToneBtn.onclick = addTonePhonology;
                const addTonePhonotacticRuleBtn = document.getElementById('addTonePhonotacticRuleBtn');
                if(addTonePhonotacticRuleBtn) addTonePhonotacticRuleBtn.onclick = addTonePhonotacticRule;
            }
            const addGraphemeMapBtn = document.getElementById('addGraphemeMapButtonPhonology');
            if (addGraphemeMapBtn) addGraphemeMapBtn.onclick = addGraphemeMappingPhonology;
            
            const addActiveSCRuleBtn = document.getElementById('addActiveSCRuleButtonPhonology');
            if (addActiveSCRuleBtn) addActiveSCRuleBtn.onclick = addActiveSoundChangeRulePhonology;

            const testActiveSCBtn = document.getElementById('applyActiveSCRulesTestBtnPhonology');
            if (testActiveSCBtn) testActiveSCBtn.onclick = testApplyActiveSoundChangesPhonology;

        }

        function renderDynamicIPACharts(langConsonants = [], langVowels = []) {
            const consContainer = document.getElementById('ipaConsonantChartContainerPhonology');
            const vowelContainer = document.getElementById('ipaVowelChartContainerPhonology');

            const consPlaces = ["‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å", "‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å‡∏Å‡∏±‡∏ö‡∏ü‡∏±‡∏ô", "‡∏ü‡∏±‡∏ô", "‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å", "‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å", "‡∏õ‡∏•‡∏≤‡∏¢‡∏•‡∏¥‡πâ‡∏ô‡∏°‡πâ‡∏ß‡∏ô", "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡πÅ‡∏Ç‡πá‡∏á", "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡∏≠‡πà‡∏≠‡∏ô", "‡∏•‡∏¥‡πâ‡∏ô‡πÑ‡∏Å‡πà", "‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡∏≠"];
            const consPlaceSymbols = {
                "‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å": ['p', 'b', 'm', ' ô', '…∏', 'Œ≤'], "‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å‡∏Å‡∏±‡∏ö‡∏ü‡∏±‡∏ô": ['…±', '‚±±', 'f', 'v', ' ã'], "‡∏ü‡∏±‡∏ô": ['Œ∏', '√∞'],
                "‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å": ['t', 'd', 'n', 'r', '…æ', 's', 'z', '…¨', '…Æ', '…π', 'l'], "‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å": [' É', ' í'],
                "‡∏õ‡∏•‡∏≤‡∏¢‡∏•‡∏¥‡πâ‡∏ô‡∏°‡πâ‡∏ß‡∏ô": [' à', '…ñ', '…≥', '…Ω', ' Ç', ' ê', '…ª', '…≠'], "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡πÅ‡∏Ç‡πá‡∏á": ['c', '…ü', '…≤', '√ß', ' ù', 'j', ' é'],
                "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡∏≠‡πà‡∏≠‡∏ô": ['k', '…°', '≈ã', 'x', '…£', '…∞', ' ü'], "‡∏•‡∏¥‡πâ‡∏ô‡πÑ‡∏Å‡πà": ['q', '…¢', '…¥', ' Ä', 'œá', ' Å'], "‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡∏≠": [' î', 'h', '…¶']
            };
            const consManners = ["‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏Å", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ô‡∏≤‡∏™‡∏¥‡∏Å", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏£‡∏±‡∏ß", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏ö", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô"];
            const consMannerSymbols = {
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏Å": ['p', 'b', 't', 'd', ' à', '…ñ', 'c', '…ü', 'k', '…°', 'q', '…¢', ' î'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ô‡∏≤‡∏™‡∏¥‡∏Å": ['m', '…±', 'n', '…≥', '…≤', '≈ã', '…¥'],
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏£‡∏±‡∏ß": [' ô', 'r', ' Ä'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏ö": ['‚±±', '…æ', '…Ω'],
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å": ['…∏', 'Œ≤', 'f', 'v', 'Œ∏', '√∞', 's', 'z', ' É', ' í', ' Ç', ' ê', '√ß', ' ù', 'x', '…£', 'œá', ' Å', 'h', '…¶'],
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô": ['…¨', '…Æ'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î": [' ã', '…π', '…ª', 'j', '…∞'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô": ['l', '…≠', ' é', ' ü']
            };

            if (consContainer) {
                let tableHTML = '<table class="ipa-table w-full"><thead><tr><th></th>';
                consPlaces.forEach(place => tableHTML += `<th>${place}</th>`);
                tableHTML += '</tr></thead><tbody>';
                consManners.forEach(manner => {
                    tableHTML += `<tr><th>${manner}</th>`;
                    consPlaces.forEach(place => {
                        tableHTML += '<td>';
                        const cellSymbols = (consPlaceSymbols[place] || []).filter(psym => (consMannerSymbols[manner] || []).includes(psym));
                        let outputSymbols = [];
                        for(let i=0; i < cellSymbols.length; i++) {
                            let sym = cellSymbols[i]; let isPaired = false;
                            if (i + 1 < cellSymbols.length) {
                                let nextSym = cellSymbols[i+1];
                                const commonPairs = { 'p':'b', 't':'d', 'k':'…°', ' à':'…ñ', 'c':'…ü', 'q':'…¢', '…∏':'Œ≤', 'f':'v', 'Œ∏':'√∞', 's':'z', ' É':' í', ' Ç':' ê', '√ß':' ù', 'x':'…£', 'œá':' Å', 'h':'…¶', '…¨':'…Æ' };
                                if (commonPairs[sym] === nextSym) {
                                    const sym1Highlighted = langConsonants.includes(sym) ? `<span class="highlighted-phoneme">${sym}</span>` : sym;
                                    const sym2Highlighted = langConsonants.includes(nextSym) ? `<span class="highlighted-phoneme">${nextSym}</span>` : nextSym;
                                    outputSymbols.push(`${sym1Highlighted}&nbsp;${sym2Highlighted}`); i++; isPaired = true;
                                }
                            }
                            if (!isPaired) outputSymbols.push(langConsonants.includes(sym) ? `<span class="highlighted-phoneme">${sym}</span>` : sym);
                        }
                        tableHTML += outputSymbols.join('&nbsp;&nbsp;'); tableHTML += '</td>';
                    }); tableHTML += '</tr>';
                }); tableHTML += '</tbody></table>'; consContainer.innerHTML = tableHTML;
            }

            const vowelPositions = ["‡∏´‡∏ô‡πâ‡∏≤", "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á", "‡∏´‡∏•‡∏±‡∏á"]; 
            const vowelHeights = ["‡∏™‡∏π‡∏á", "‡∏Å‡∏∂‡πà‡∏á‡∏™‡∏π‡∏á", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏Å‡∏∂‡πà‡∏á‡∏ï‡πà‡∏≥", "‡∏ï‡πà‡∏≥"]; 
            const vowelChartSymbols = {
                "‡∏™‡∏π‡∏á":    { "‡∏´‡∏ô‡πâ‡∏≤": ["i","y"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…®"," â"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": ["…Ø","u"] },
                "‡∏Å‡∏∂‡πà‡∏á‡∏™‡∏π‡∏á": { "‡∏´‡∏ô‡πâ‡∏≤": ["e","√∏"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…ò","…µ"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": ["…§","o"] },
                "‡∏Å‡∏•‡∏≤‡∏á":   { "‡∏´‡∏ô‡πâ‡∏≤": [],        "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…ô"],    "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": [] },
                "‡∏Å‡∏∂‡πà‡∏á‡∏ï‡πà‡∏≥": { "‡∏´‡∏ô‡πâ‡∏≤": ["…õ","≈ì"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…ú","…û"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": [" å","…î"] },
                "‡∏ï‡πà‡∏≥":    { "‡∏´‡∏ô‡πâ‡∏≤": ["a","…∂"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": ["√¶"], "‡∏Å‡∏•‡∏≤‡∏á": ["…ê"],    "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": ["…ë","…í"] }
            };
            
            if (vowelContainer) {
                let tableHTML = '<table class="ipa-table w-full"><thead><tr><th>‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏•‡∏¥‡πâ‡∏ô\\‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏•‡∏¥‡πâ‡∏ô</th>';
                vowelPositions.forEach(pos => tableHTML += `<th>${pos}</th>`);
                tableHTML += '</tr></thead><tbody>';
                vowelHeights.forEach(height => {
                    tableHTML += `<tr><th>${height}</th>`;
                    vowelPositions.forEach(pos => {
                        tableHTML += '<td>';
                        const symbolsInCell = vowelChartSymbols[height]?.[pos] || [];
                        symbolsInCell.forEach((ipa, idx) => {
                            if (ipa) {
                                const isPresent = langVowels.includes(ipa);
                                tableHTML += isPresent ? `<span class="highlighted-phoneme">${ipa}</span>` : ipa;
                                if (idx < symbolsInCell.length - 1 && symbolsInCell.length > 1) tableHTML += '&nbsp;'; 
                            }
                        }); tableHTML += '</td>';
                    }); tableHTML += '</tr>';
                }); tableHTML += '</tbody></table>'; vowelContainer.innerHTML = tableHTML;
            }
        }


        function addTonePhonology() {
            const name = document.getElementById('newToneNamePhonology').value.trim();
            const representation = document.getElementById('newToneRepresentationPhonology').value.trim(); 
            const number = document.getElementById('newToneNumberPhonology').value; 
            const hideInOrthography = document.getElementById('newToneHideInOrthographyPhonology').checked;

            if (!name || number === "" ) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏•‡∏Ç‡πÅ‡∏ó‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á");
                return;
            }
            const toneId = `tone_${nextToneId++}`;
            currentLanguage.phonology.tones.push({ id: toneId, name, representation, number: parseInt(number), hideInOrthography });
            renderPhonologyUI(tabContentContainer);
            saveData();
        }

        window.removeTonePhonology = (toneId) => {
            currentLanguage.phonology.tones = currentLanguage.phonology.tones.filter(t => t.id !== toneId);
            currentLanguage.phonology.tonePhonotactics = currentLanguage.phonology.tonePhonotactics.map(rule => {
                rule.forbiddenTones = rule.forbiddenTones.filter(ftId => ftId !== toneId); 
                return rule;
            }).filter(rule => rule.forbiddenTones.length > 0 || (rule.initials.length === 0 && rule.finals.length === 0)); 
            renderPhonologyUI(tabContentContainer);
            saveData();
        };
        
        function renderTonePhonotacticsList() {
            const listContainer = document.getElementById('tonePhonotacticsListPhonology');
            if (!listContainer) return;
            listContainer.innerHTML = '';
            (currentLanguage.phonology.tonePhonotactics || []).forEach(rule => {
                const div = document.createElement('div');
                div.className = 'text-xs p-1.5 bg-white border rounded flex justify-between items-center';
                let forbiddenTonesStr = rule.forbiddenTones.map(tNum => {
                    const toneObj = currentLanguage.phonology.tones.find(t => t.number === tNum);
                    return toneObj ? toneObj.name : `‡πÄ‡∏™‡∏µ‡∏¢‡∏á ${tNum}`;
                }).join(', ');

                div.innerHTML = `<span>${rule.description || `‡∏ï‡πâ‡∏ô: [${rule.initials.join(',')}] + ‡∏ó‡πâ‡∏≤‡∏¢: [${rule.finals.join(',')}] ‡∏´‡πâ‡∏≤‡∏°: ${forbiddenTonesStr}`}</span>
                               <button class="text-red-500 hover:text-red-700 text-xs" onclick="removeTonePhonotacticRule('${rule.id}')">&times; ‡∏•‡∏ö</button>`;
                listContainer.appendChild(div);
            });
             if (!currentLanguage.phonology.tonePhonotactics || currentLanguage.phonology.tonePhonotactics.length === 0) {
                listContainer.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå</p>';
            }
        }

        function populateTonePhonotacticToneSelect() {
            const selectEl = document.getElementById('tpRuleForbiddenTones');
            if (!selectEl) return;
            selectEl.innerHTML = '';
            (currentLanguage.phonology.tones || []).forEach(tone => {
                selectEl.innerHTML += `<option value="${tone.number}">${tone.name} (${tone.representation || tone.number})</option>`;
            });
        }

        function addTonePhonotacticRule() {
            const initials = document.getElementById('tpRuleInitials').value.split(',').map(s=>s.trim()).filter(Boolean);
            const finals = document.getElementById('tpRuleFinals').value.split(',').map(s=>s.trim()).filter(Boolean);
            const forbiddenTonesSelect = document.getElementById('tpRuleForbiddenTones');
            const forbiddenTones = Array.from(forbiddenTonesSelect.selectedOptions).map(opt => parseInt(opt.value));
            const description = document.getElementById('tpRuleDescription').value.trim();

            if (forbiddenTones.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏´‡πâ‡∏≤‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"); return;
            }
             if (initials.length === 0 && finals.length === 0 && !description && !confirm("‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô/‡∏ó‡πâ‡∏≤‡∏¢ ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ ‡∏à‡∏∞‡∏°‡∏µ‡∏ú‡∏•‡∏Å‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏≥‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?")) {
                return;
            }

            const newRule = {
                id: `tp_${nextTonePhonotacticId++}`,
                ruleType: 'initial_final_tone', 
                initials, finals, forbiddenTones, description
            };
            currentLanguage.phonology.tonePhonotactics.push(newRule);
            renderPhonologyUI(tabContentContainer); 
            saveData();
            document.getElementById('tpRuleInitials').value = '';
            document.getElementById('tpRuleFinals').value = '';
            forbiddenTonesSelect.selectedIndex = -1;
            document.getElementById('tpRuleDescription').value = '';
        }

        window.removeTonePhonotacticRule = (ruleId) => {
            currentLanguage.phonology.tonePhonotactics = currentLanguage.phonology.tonePhonotactics.filter(r => r.id !== ruleId);
            renderPhonologyUI(tabContentContainer);
            saveData();
        }


        function renderGraphemeMappingsList() {
            const listContainer = document.getElementById('graphemeMappingListPhonology');
            if (!listContainer) return;
            listContainer.innerHTML = '';

            const createGraphemeSpans = (graphemes) => {
                if (!graphemes || graphemes.length === 0) return 'N/A';
                return graphemes.map(g => `<span class="mapping-value-item">${g}</span>`).join(', ');
            };
        
            (currentLanguage.phonology.graphemeMappings || []).forEach((gm, index) => {
                const div = document.createElement('div');
                div.className = 'grapheme-mapping-display text-sm'; 
                
                let content = `<strong>‡πÄ‡∏™‡∏µ‡∏¢‡∏á /${gm.sound}/:</strong>`;
                if ((gm.initialGraphemes && gm.initialGraphemes.length > 0) ||
                    (gm.finalGraphemes && gm.finalGraphemes.length > 0) ||
                    (gm.vowelGraphemes && gm.vowelGraphemes.length > 0)) {
                    content += `<div class="ml-4">`;
                    if (gm.initialGraphemes && gm.initialGraphemes.length > 0) {
                        content += `<span class="mapping-type">‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô:</span> <span class="mapping-values-container">${createGraphemeSpans(gm.initialGraphemes)}</span><br>`;
                    }
                    if (gm.finalGraphemes && gm.finalGraphemes.length > 0) {
                        content += `<span class="mapping-type">‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡πâ‡∏≤‡∏¢:</span> <span class="mapping-values-container">${createGraphemeSpans(gm.finalGraphemes)}</span><br>`;
                    }
                    if (gm.vowelGraphemes && gm.vowelGraphemes.length > 0) {
                        content += `<span class="mapping-type">‡∏™‡∏£‡∏∞/‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ:</span> <span class="mapping-values-container">${createGraphemeSpans(gm.vowelGraphemes)}</span>`;
                    }
                    content += `</div>`;
                } else {
                     content += `<span class="text-xs text-gray-400 ml-2">(‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î)</span>`;
                }
                
                const deleteButton = `<button class="text-red-500 hover:text-red-700 text-xs ml-auto" onclick="removeGraphemeMappingPhonology(${index})">&times; ‡∏•‡∏ö</button>`;
                
                div.innerHTML = `<div class="flex justify-between items-start">${content} ${deleteButton}</div>`;
                listContainer.appendChild(div);
            });
            if (!currentLanguage.phonology.graphemeMappings || currentLanguage.phonology.graphemeMappings.length === 0) {
                listContainer.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ</p>';
            }
        }


        function addGraphemeMappingPhonology() {
            const sound = document.getElementById('graphemeMapSoundPhonology').value.trim();
            const initial = document.getElementById('graphemeMapInitialPhonology').value.split(',').map(s => s.trim()).filter(s => s);
            const final = document.getElementById('graphemeMapFinalPhonology').value.split(',').map(s => s.trim()).filter(s => s);
            const vowel = document.getElementById('graphemeMapVowelPhonology').value.split(',').map(s => s.trim()).filter(s => s);

            if (!sound) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phoneme)");
                return;
            }
            if (initial.length === 0 && final.length === 0 && vowel.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô");
                return;
            }

            const existingMappingIndex = currentLanguage.phonology.graphemeMappings.findIndex(gm => gm.sound === sound);
            if (existingMappingIndex > -1) {
                currentLanguage.phonology.graphemeMappings[existingMappingIndex] = { sound, initialGraphemes: initial, finalGraphemes: final, vowelGraphemes: vowel };
            } else {
                currentLanguage.phonology.graphemeMappings.push({ sound, initialGraphemes: initial, finalGraphemes: final, vowelGraphemes: vowel });
            }
            renderGraphemeMappingsList();
            saveData();
            document.getElementById('graphemeMapSoundPhonology').value = '';
            document.getElementById('graphemeMapInitialPhonology').value = '';
            document.getElementById('graphemeMapFinalPhonology').value = '';
            document.getElementById('graphemeMapVowelPhonology').value = '';
        }

        window.removeGraphemeMappingPhonology = (index) => {
            currentLanguage.phonology.graphemeMappings.splice(index, 1);
            renderGraphemeMappingsList();
            saveData();
        }

        function renderActiveSoundChangesList() {
            const listContainer = document.getElementById('activeSoundChangesListPhonology');
            if (!listContainer) return;
            listContainer.innerHTML = '';
            (currentLanguage.phonology.activeSoundChanges || []).sort((a,b) => a.order - b.order).forEach(rule => {
                const div = document.createElement('div');
                div.className = 'draggable-item text-sm p-1.5 bg-white border rounded flex justify-between items-center';
                div.setAttribute('draggable', true);
                div.dataset.ruleId = rule.id;
                div.innerHTML = `
                    <span class="flex-grow">
                        <i class="fas fa-grip-vertical mr-2 text-gray-400"></i>
                        <strong>${rule.order + 1}.</strong> ${rule.description || `${rule.from} ‚Üí ${rule.to} / ${rule.contextPre}_${rule.contextPost}`}
                        (${rule.enabled ? '‡πÄ‡∏õ‡∏¥‡∏î' : '‡∏õ‡∏¥‡∏î'})
                    </span>
                    <span>
                        <button class="text-xs text-blue-500 hover:text-blue-700 mr-1" onclick="toggleActiveSoundChangeRuleEnablePhonology('${rule.id}')">${rule.enabled ? '‡∏õ‡∏¥‡∏î' : '‡πÄ‡∏õ‡∏¥‡∏î'}</button>
                        <button class="text-red-500 hover:text-red-700 text-xs" onclick="removeActiveSoundChangeRulePhonology('${rule.id}')">&times; ‡∏•‡∏ö</button>
                    </span>`;
                listContainer.appendChild(div);
            });
            if (!currentLanguage.phonology.activeSoundChanges || currentLanguage.phonology.activeSoundChanges.length === 0) {
                listContainer.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á</p>';
            }
            setupDragAndDropSort('activeSoundChangesListPhonology', currentLanguage.phonology.activeSoundChanges, renderActiveSoundChangesList, saveData);
        }

        function addActiveSoundChangeRulePhonology() {
            const from = document.getElementById('activeSCFromPhonology').value.trim();
            const to = document.getElementById('activeSCToPhonology').value.trim(); 
            const contextPre = document.getElementById('activeSCContextPrePhonology').value.trim();
            const contextPost = document.getElementById('activeSCContextPostPhonology').value.trim();
            const description = document.getElementById('activeSCDescPhonology').value.trim();

            if (!from) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏ '‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (From X)'"); return;
            }
            const newRule = {
                id: `asc_${nextActiveSoundChangeId++}`,
                from, to, contextPre, contextPost, description,
                order: currentLanguage.phonology.activeSoundChanges.length,
                enabled: true
            };
            currentLanguage.phonology.activeSoundChanges.push(newRule);
            renderActiveSoundChangesList();
            saveData();
            document.getElementById('activeSCFromPhonology').value = '';
            document.getElementById('activeSCToPhonology').value = '';
            document.getElementById('activeSCContextPrePhonology').value = '';
            document.getElementById('activeSCContextPostPhonology').value = '';
            document.getElementById('activeSCDescPhonology').value = '';
        }
        
        window.toggleActiveSoundChangeRuleEnablePhonology = (ruleId) => {
            const rule = currentLanguage.phonology.activeSoundChanges.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = !rule.enabled;
                renderActiveSoundChangesList();
                saveData();
            }
        };

        window.removeActiveSoundChangeRulePhonology = (ruleId) => {
            currentLanguage.phonology.activeSoundChanges = currentLanguage.phonology.activeSoundChanges.filter(r => r.id !== ruleId);
            currentLanguage.phonology.activeSoundChanges.sort((a,b) => a.order - b.order).forEach((r, i) => r.order = i);
            renderActiveSoundChangesList();
            saveData();
        };
        
        function applyActiveSoundChangeRule(word, rule) { 
            if (!rule.enabled) return word;
            
            let escFrom = rule.from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            let prePattern = "";
            // Ensure vowel/consonant lists are available for V/C context matching
            let VOWELS_REGEX_PART = (currentLanguage.phonology.vowels || []).map(v => v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
            let CONSONANTS_REGEX_PART = (currentLanguage.phonology.consonants || []).map(c => c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');


            if (rule.contextPre) {
                if (rule.contextPre === '#') prePattern = '^'; 
                else if (rule.contextPre === 'V') prePattern = `(?<=(${VOWELS_REGEX_PART}))`;
                else if (rule.contextPre === 'C') prePattern = `(?<=(${CONSONANTS_REGEX_PART}))`; 
                else prePattern = `(?<=${rule.contextPre.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;
            }

            let postPattern = "";
            if (rule.contextPost) {
                if (rule.contextPost === '#') postPattern = '$'; 
                else if (rule.contextPost === 'V') postPattern = `(?=(${VOWELS_REGEX_PART}))`; 
                else if (rule.contextPost === 'C') postPattern = `(?=(${CONSONANTS_REGEX_PART}))`; 
                else postPattern = `(?=${rule.contextPost.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;
            }
            
            try {
                // Prevent errors if V/C is used but inventory is empty
                if ((rule.contextPre === 'V' && !VOWELS_REGEX_PART) || (rule.contextPre === 'C' && !CONSONANTS_REGEX_PART) ||
                    (rule.contextPost === 'V' && !VOWELS_REGEX_PART) || (rule.contextPost === 'C' && !CONSONANTS_REGEX_PART)) {
                    console.warn("Skipping rule due to empty vowel/consonant inventory for context:", rule);
                    return word;
                }
                const finalRegex = new RegExp(prePattern + escFrom + postPattern, 'g');
                return word.replace(finalRegex, rule.to);
            } catch (e) {
                console.warn("Error in regex for rule:", rule, e, "Word:", word, "Pattern:", prePattern + escFrom + postPattern);
                return word; // Return original word on error
            }
        }

        function testApplyActiveSoundChangesPhonology() {
            const word = document.getElementById('testActiveSCWordPhonology').value.trim();
            const resultDiv = document.getElementById('testActiveSCResultPhonology');
            if (!word) { resultDiv.innerHTML = '<p class="text-red-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏ó‡∏î‡∏™‡∏≠‡∏ö</p>'; return; }

            let currentWordState = word;
            let historyHtml = `<p><strong>‡∏Ñ‡∏≥‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô:</strong> ${word}</p><ol class="list-decimal list-inside mt-1">`;
            
            const sortedRules = [...currentLanguage.phonology.activeSoundChanges].sort((a,b) => a.order - b.order);
            sortedRules.forEach(rule => {
                const wordBeforeRule = currentWordState;
                if (rule.enabled) {
                    currentWordState = applyActiveSoundChangeRule(currentWordState, rule);
                }
                const desc = rule.description || `${rule.from} ‚Üí ${rule.to} / ${rule.contextPre}_${rule.contextPost}`;
                const changed = wordBeforeRule !== currentWordState;
                historyHtml += `<li class="${!rule.enabled ? 'text-gray-400 italic' : (changed ? 'text-green-600 font-semibold' : '')}">
                                    ${desc} ${!rule.enabled ? '(‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)' : ''} ‚Üí ${currentWordState}
                                    ${changed && rule.enabled ? ` (‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å ${wordBeforeRule})` : ''}
                                </li>`;
            });
            historyHtml += `</ol><p class="mt-2"><strong>‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢:</strong> ${currentWordState}</p>`;
            resultDiv.innerHTML = historyHtml;
        }

        function setupDragAndDropSort(listContainerId, itemsArray, rerenderCallback, saveCallback) {
            const listContainer = document.getElementById(listContainerId);
            if (!listContainer) return;
            let draggedItem = null;

            listContainer.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('draggable-item')) {
                    draggedItem = e.target;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', e.target.dataset.ruleId); // Assuming ruleId for active sound changes
                    setTimeout(() => e.target.style.opacity = '0.5', 0);
                }
            });

            listContainer.addEventListener('dragend', (e) => {
                if (draggedItem) {
                    setTimeout(() => {
                        if (draggedItem) draggedItem.style.opacity = '1'; // Check if draggedItem still exists
                        draggedItem = null;
                    }, 0);
                    // Update order based on new DOM positions
                    const newOrder = Array.from(listContainer.children)
                                         .map(child => child.dataset.ruleId) // Use ruleId for active sound changes
                                         .filter(id => id); 
                    itemsArray.forEach(item => {
                        const newIdx = newOrder.indexOf(item.id);
                        if (newIdx !== -1) item.order = newIdx;
                    });
                    itemsArray.sort((a,b) => a.order - b.order); 
                    if (rerenderCallback) rerenderCallback(); 
                    if (saveCallback) saveCallback();
                }
            });

            listContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const targetItem = e.target.closest('.draggable-item');
                if (targetItem && draggedItem && targetItem !== draggedItem) {
                    const rect = targetItem.getBoundingClientRect();
                    const next = (e.clientY - rect.top) / (rect.bottom - rect.top) > 0.5;
                    if (next) {
                        listContainer.insertBefore(draggedItem, targetItem.nextSibling);
                    } else {
                        listContainer.insertBefore(draggedItem, targetItem);
                    }
                }
            });
        }


        window.togglePhonotacticRule = (index) => {
            currentLanguage.phonology.phonotactics[index].enabled = !currentLanguage.phonology.phonotactics[index].enabled;
            renderPhonologyUI(tabContentContainer); saveData();
        };
        window.removeCustomPhonotacticRule = (index) => {
            if (currentLanguage.phonology.phonotactics[index].custom) {
                currentLanguage.phonology.phonotactics.splice(index, 1);
                renderPhonologyUI(tabContentContainer); saveData();
            }
        };

        function renderWordGeneratorUI(container) {
            const section = document.createElement('div');
            section.className = 'space-y-4 p-3 border border-green-200 rounded-md bg-green-50';
            section.innerHTML = `
                <div>
                    <label class="block text-sm font-medium text-green-700">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏ï‡πà‡∏≠‡∏Ñ‡∏≥:</label>
                    <div class="flex items-center gap-2">
                        <input type="number" id="minSyllables" value="1" min="1" max="5" class="w-20 p-2 border border-green-300 rounded-md">
                        <span>‡∏ñ‡∏∂‡∏á</span>
                        <input type="number" id="maxSyllables" value="3" min="1" max="5" class="w-20 p-2 border border-green-300 rounded-md">
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-green-700">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á:</label>
                    <input type="number" id="numWordsToGenerate" value="5" min="1" max="20" class="w-20 p-2 border border-green-300 rounded-md">
                </div>
                <button id="generateWordsButton" class="btn-primary bg-green-500 hover:bg-green-600 py-2 px-4 rounded-md">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥ üé≤</button>
                <div id="generatedWordsArea" class="mt-4 p-3 bg-white rounded-md shadow">
                    <h4 class="font-semibold text-green-700">‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏î‡πâ:</h4>
                    <ul id="generatedWordsList" class="list-disc list-inside text-sm"></ul>
                </div>
            `;
            container.appendChild(section);
            document.getElementById('generateWordsButton').addEventListener('click', generateAndDisplayWords);
        }

        // Function to get orthographic form, with an option to use the first grapheme for deterministic output
        // (e.g., for consistent display in inflection tables)
        function getOrthographicForm(wordEntry, forDisplay = true, useFirstGraphemeForAutoInflection = false) {
            if (!wordEntry) return "";
            // If a custom orthography is defined for the word, always use it.
            if (wordEntry.customOrthography) {
                return wordEntry.customOrthography;
            }
            // Otherwise, transliterate the base phonemic form.
            // wordEntry.word is expected to be the base phonemic form including any tone markers.
            const basePhonemicForm = typeof wordEntry.word === 'string' ? wordEntry.word : '';
            // Pass the useFirstGraphemeForAutoInflection flag to transliterateWordToSymbols.
            return transliterateWordToSymbols(basePhonemicForm, forDisplay, useFirstGraphemeForAutoInflection);
        }


        // Function to transliterate a phonemic word string into its orthographic representation based on current language settings.
        // Parameters:
        // - wordString: The phonemic string to transliterate.
        // - forDisplay: Boolean, if true, considers displayTonesInOrthography. (Currently always true when called from getOrthographicForm)
        // - useFirstGraphemeOnly: Boolean, if true, selects the first available grapheme from mappings for determinism. Otherwise, selects randomly.
        function transliterateWordToSymbols(wordString, forDisplay = true, useFirstGraphemeOnly = false) {
            if (!wordString && typeof wordString !== 'string') return ""; 
            const { writingSystem, customSymbols, displayTonesInOrthography } = currentLanguage.orthography;
            const { graphemeMappings, tones: definedTones, hasTones, consonants, vowels } = currentLanguage.phonology;
        
            let baseWord = String(wordString);
            let toneMarker = "";
        
            // Extract tone from the end of the phonemic string if tones are enabled and defined.
            if (hasTones && definedTones && definedTones.length > 0) {
                const numericSuperscripts = ["‚Å∞", "¬π", "¬≤", "¬≥", "‚Å¥", "‚Åµ", "‚Å∂", "‚Å∑", "‚Å∏", "‚Åπ"];
                // Sort tone representations by length (longest first) to handle multi-character representations correctly.
                const toneRepresentationsSorted = definedTones
                    .map(t => ({rep: t.representation, tone: t}))
                    .filter(item => item.rep && typeof item.rep === 'string') 
                    .sort((a,b) => b.rep.length - a.rep.length); 

                 for (const item of toneRepresentationsSorted) {
                    if (item.rep && baseWord.endsWith(item.rep)) { 
                        // Assign tone marker if forDisplay is true, displayTonesInOrthography is true, and tone is not hidden.
                        toneMarker = (forDisplay && displayTonesInOrthography && !item.tone.hideInOrthography) ? item.rep : "";
                        baseWord = baseWord.slice(0, -item.rep.length); // Remove tone from baseWord
                        break;
                    }
                }
                // If no complex tone found, check for simple numeric superscript.
                if (!toneMarker) {
                    for (let i = 0; i < numericSuperscripts.length; i++) {
                        if (baseWord.endsWith(numericSuperscripts[i])) {
                            const foundToneNumber = i;
                            const matchedTone = definedTones.find(t => t.number === foundToneNumber);
                            if (matchedTone) {
                                 toneMarker = (forDisplay && displayTonesInOrthography && !matchedTone.hideInOrthography) ? (matchedTone.representation || numericSuperscripts[i]) : "";
                            } else { // Unmapped numeric tone, still display if allowed.
                                 toneMarker = (forDisplay && displayTonesInOrthography) ? numericSuperscripts[i] : "";
                            }
                            baseWord = baseWord.slice(0, -1); // Remove tone from baseWord
                            break;
                        }
                    }
                }
            }
        
            let transliterated = '';
            let remainingWord = baseWord;
        
            // Handle custom writing system first.
            if (writingSystem === 'custom' && customSymbols && customSymbols.length > 0) {
                const sortedSymbols = [...customSymbols].sort((a, b) => b.sound.length - a.sound.length); // Longest sound first for matching.
                while (remainingWord.length > 0) {
                    let foundMatch = false;
                    for (const sym of sortedSymbols) {
                        if (remainingWord.startsWith(sym.sound)) {
                            transliterated += sym.symbol;
                            remainingWord = remainingWord.substring(sym.sound.length);
                            foundMatch = true;
                            break;
                        }
                    }
                    if (!foundMatch) { // If no custom symbol matches, append the character as is.
                        transliterated += remainingWord[0];
                        remainingWord = remainingWord.substring(1);
                    }
                }
            } else if (writingSystem === 'latin' && graphemeMappings && graphemeMappings.length > 0) {
                // Handle Latin-based system with grapheme mappings.
                // Sort mappings by sound length (longest first) to ensure correct matching (e.g., "sh" before "s").
                const sortedMappings = [...graphemeMappings].sort((a, b) => b.sound.length - a.sound.length);
                let currentOriginalPos = 0; // Track position in the original baseWord for context (initial/final).
                
                while (remainingWord.length > 0) {
                    let foundMatch = false;
                    for (const gm of sortedMappings) { // Iterate through each grapheme mapping.
                        if (remainingWord.startsWith(gm.sound)) { // If the current sound in mapping matches the start of remainingWord.
                            let potentialGraphemes = []; // List of possible graphemes to choose from for this sound.
                            
                            // Determine context of the sound.
                            const isInitial = currentOriginalPos === 0;
                            const isFinal = (currentOriginalPos + gm.sound.length === baseWord.length);
                            const isConsonantSound = (currentLanguage.phonology.consonants || []).includes(gm.sound);
                            const isVowelSound = (currentLanguage.phonology.vowels || []).includes(gm.sound);

                            // Select appropriate grapheme list based on sound type and position.
                            // This implements the "‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏¢‡∏Å‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô‡∏Å‡∏±‡∏ö‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏™‡∏∞‡∏Å‡∏î ‡∏´‡πâ‡∏≤‡∏°‡∏ô‡∏≥‡∏°‡∏≤‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ô"
                            if (isConsonantSound) {
                                if (isInitial && gm.initialGraphemes && gm.initialGraphemes.length > 0) {
                                    potentialGraphemes = gm.initialGraphemes;
                                } else if (isFinal && gm.finalGraphemes && gm.finalGraphemes.length > 0) {
                                    potentialGraphemes = gm.finalGraphemes;
                                } else if (gm.initialGraphemes && gm.initialGraphemes.length > 0) { // Medial consonant: prefer initial form.
                                    potentialGraphemes = gm.initialGraphemes;
                                } else if (gm.vowelGraphemes && gm.vowelGraphemes.length > 0) { // Unlikely fallback for consonant.
                                    potentialGraphemes = gm.vowelGraphemes;
                                } else if (gm.finalGraphemes && gm.finalGraphemes.length > 0) { // Further fallback.
                                     potentialGraphemes = gm.finalGraphemes;
                                }
                            } else if (isVowelSound) {
                                if (gm.vowelGraphemes && gm.vowelGraphemes.length > 0) {
                                    potentialGraphemes = gm.vowelGraphemes;
                                } else if (isInitial && gm.initialGraphemes && gm.initialGraphemes.length > 0) { // Vowel with initial form (e.g., /a/ as 'ha').
                                    potentialGraphemes = gm.initialGraphemes;
                                } else if (isFinal && gm.finalGraphemes && gm.finalGraphemes.length > 0) { // Vowel with final form (e.g., /a/ as 'ah').
                                    potentialGraphemes = gm.finalGraphemes;
                                } else if (gm.initialGraphemes && gm.initialGraphemes.length > 0) { // Medial vowel fallback if no specific vowelGraphemes.
                                     potentialGraphemes = gm.initialGraphemes;
                                }
                            }

                            // If no specific positional graphemes were chosen, use any graphemes defined for the sound.
                            if (potentialGraphemes.length === 0) {
                                const allDefined = [
                                    ...(gm.initialGraphemes || []),
                                    ...(gm.vowelGraphemes || []),
                                    ...(gm.finalGraphemes || [])
                                ].filter(Boolean); // filter(Boolean) removes empty strings if any.
                                if (allDefined.length > 0) {
                                    potentialGraphemes = allDefined;
                                }
                            }
                            
                            let chosenGrapheme = null;
                            if (potentialGraphemes.length > 0) {
                                // Implement "‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ô‡∏±‡πâ‡∏ô‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏ß‡∏¥‡∏ò‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏£‡∏Å‡πÄ‡∏™‡∏°‡∏≠"
                                if (useFirstGraphemeOnly) {
                                    chosenGrapheme = potentialGraphemes[0]; // Select the first grapheme for deterministic output.
                                } else {
                                    chosenGrapheme = potentialGraphemes[Math.floor(Math.random() * potentialGraphemes.length)]; // Otherwise, select randomly.
                                }
                            }

                            if (chosenGrapheme) {
                                transliterated += chosenGrapheme;
                                remainingWord = remainingWord.substring(gm.sound.length);
                                currentOriginalPos += gm.sound.length; 
                                foundMatch = true;
                                break; // Move to next segment of remainingWord.
                            }
                        }
                    }
                    if (!foundMatch) { // If no grapheme mapping applies or sound not in mappings, append char as is.
                        transliterated += remainingWord[0];
                        remainingWord = remainingWord.substring(1);
                        currentOriginalPos += 1;
                    }
                }
            } else { // If neither custom nor Latin with mappings, assume direct phoneme-to-grapheme (usually just the phoneme itself).
                transliterated = baseWord;
            }
        
            return transliterated + toneMarker; // Append the determined tone marker.
        }


        function generateAndDisplayWords() {
            const minSyllables = parseInt(document.getElementById('minSyllables').value);
            const maxSyllables = parseInt(document.getElementById('maxSyllables').value);
            const numWords = parseInt(document.getElementById('numWordsToGenerate').value);
            const listElement = document.getElementById('generatedWordsList');
            listElement.innerHTML = '';

            if (minSyllables > maxSyllables) { alert("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î"); return; }
            if (currentLanguage.phonology.consonants.length === 0 || currentLanguage.phonology.vowels.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏™‡∏£‡∏∞‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô"); return;
            }

            for (let i = 0; i < numWords; i++) {
                const numSyllToGenerate = Math.floor(Math.random() * (maxSyllables - minSyllables + 1)) + minSyllables;
                let rawWordFormBeforeActiveChanges = ''; 
                let finalPhoneticWord = ''; 

                for (let j = 0; j < numSyllToGenerate; j++) {
                    const syllableParts = generateSyllable(); 
                    rawWordFormBeforeActiveChanges += syllableParts.base; 
                    finalPhoneticWord += syllableParts.phonetic; 
                }
                
                const detailedPhonetics = autoFormatDetailedPhonetics(finalPhoneticWord, currentLanguage.phonology);
                 // For word generation, use random grapheme selection (default behavior of getOrthographicForm)
                const displayWord = getOrthographicForm({word: finalPhoneticWord, customOrthography: null});


                let randomMeaning = "";
                if (apiThaiMeaningsDatabase.length > 0) {
                    randomMeaning = apiThaiMeaningsDatabase[Math.floor(Math.random() * apiThaiMeaningsDatabase.length)];
                } else if (localThaiMeaningsDatabase.length > 0) { 
                    randomMeaning = localThaiMeaningsDatabase[Math.floor(Math.random() * localThaiMeaningsDatabase.length)];
                }

                const listItem = document.createElement('li');
                listItem.className = 'p-2 my-1 bg-gray-50 hover:bg-green-50 rounded flex justify-between items-center flex-wrap';

                const wordDisplaySpan = document.createElement('span');
                wordDisplaySpan.className = 'font-semibold mr-2';
                wordDisplaySpan.innerHTML = `${displayWord} <span class="text-sm text-gray-500 font-normal font-mono">(${finalPhoneticWord})</span> <span class="text-xs text-blue-400 font-normal font-mono">[‡∏ê‡∏≤‡∏ô‡∏î‡∏¥‡∏ö: ${rawWordFormBeforeActiveChanges}]</span>`;
                if (randomMeaning) {
                     wordDisplaySpan.innerHTML += ` <span class="text-xs text-blue-500">‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á: ${randomMeaning}</span>`;
                }
                listItem.appendChild(wordDisplaySpan);

                const addButton = document.createElement('button');
                addButton.innerHTML = '‚ûï <span class="hidden sm:inline">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°</span>';
                addButton.className = 'ml-auto text-xs btn-secondary bg-green-400 hover:bg-green-500 px-2 py-1 rounded whitespace-nowrap';
                addButton.onclick = () => showWordModal(null, finalPhoneticWord, detailedPhonetics, randomMeaning); 
                listItem.appendChild(addButton);
                listElement.appendChild(listItem);
            }
        }
        
        function generateSyllable() {
            const ph = currentLanguage.phonology;
            if (ph.syllableStructures.length === 0) return { base: "err", phonetic: "err" };
            if (ph.consonants.length === 0 && !ph.allowVowelInitial) { 
                console.warn("Cannot generate syllable: No consonants defined and vowel initial not allowed.");
                return { base: "errC", phonetic: "errC" };
            }
            if (ph.vowels.length === 0) {
                 console.warn("Cannot generate syllable: No vowels defined.");
                return { base: "errV", phonetic: "errV" };
            }


            let attempts = 0;
            while (attempts < 100) { 
                const structureStr = ph.syllableStructures[Math.floor(Math.random() * ph.syllableStructures.length)];
                let syllableBase = ""; 
                let validSyllable = true;
                let tempStructure = structureStr;
                
                let onsetLength = 0;
                const onsetMatch = tempStructure.match(/^(C+|C)/); 
                if (onsetMatch) onsetLength = onsetMatch[0].length;

                if (onsetLength > 0) { 
                    const availableInitials = ph.allowedInitialConsonants.filter(c => ph.consonants.includes(c));
                    const availableClusters = ph.allowedConsonantClusters.filter(cl => 
                        cl.length <= ph.maxClusterLength && 
                        !ph.forbiddenConsonantClusters.includes(cl) && 
                        cl.split('').every(c => ph.consonants.includes(c)) && 
                        availableInitials.includes(cl[0]) 
                    );

                    if (onsetLength > 1) { 
                        const fittingClusters = availableClusters.filter(cl => cl.length === onsetLength);
                        if (fittingClusters.length > 0) {
                            syllableBase += fittingClusters[Math.floor(Math.random() * fittingClusters.length)];
                        } else { 
                            const shorterFittingClusters = availableClusters.filter(cl => cl.length < onsetLength && cl.length > 0);
                            if (shorterFittingClusters.length > 0) {
                                syllableBase += shorterFittingClusters[Math.floor(Math.random() * shorterFittingClusters.length)];
                            } else if (availableInitials.length > 0) {
                                syllableBase += availableInitials[Math.floor(Math.random() * availableInitials.length)];
                            } else { validSyllable = false; }
                        }
                    } else { 
                        if (availableInitials.length > 0) {
                            syllableBase += availableInitials[Math.floor(Math.random() * availableInitials.length)];
                        } else { validSyllable = false; }
                    }
                    if(validSyllable && onsetMatch) tempStructure = tempStructure.substring(syllableBase.length); 
                } else if (!ph.allowVowelInitial) { 
                    validSyllable = false;
                }
                
                if (validSyllable && ph.forbiddenInitialSounds.some(s => syllableBase.startsWith(s))) {
                     validSyllable = false;
                }

                if (validSyllable) { 
                    const vowelMatch = tempStructure.match(/^(V+|V)/); 
                    if (vowelMatch) {
                        const vowelSegment = vowelMatch[0];
                        for (let k = 0; k < vowelSegment.length; k++) {
                            if (ph.vowels.length > 0) {
                                syllableBase += ph.vowels[Math.floor(Math.random() * ph.vowels.length)];
                            } else { validSyllable = false; break; }
                        }
                        if(validSyllable) tempStructure = tempStructure.substring(vowelSegment.length);
                    } else if (!syllableBase.match(new RegExp(`[${ph.vowels.join('')}]`, 'i'))) { 
                         validSyllable = false; 
                    }
                }

                if (validSyllable && tempStructure.length > 0) { 
                    const codaStructure = tempStructure;
                    const availableFinals = ph.allowedFinalConsonants.filter(c => ph.consonants.includes(c));
                    const availableCodaClusters = ph.allowedCodaClusters.filter(cc => 
                        cc.split('').every(c => ph.consonants.includes(c)) &&
                        !ph.forbiddenConsonantClusters.includes(cc) 
                    );

                    if (ph.allowClusterCoda && codaStructure.length > 1) { 
                        const fittingCodaClusters = availableCodaClusters.filter(cc => cc.length === codaStructure.length);
                        if (fittingCodaClusters.length > 0) {
                            syllableBase += fittingCodaClusters[Math.floor(Math.random() * fittingCodaClusters.length)];
                        } else { 
                            for (let k = 0; k < codaStructure.length; k++) {
                                if (availableFinals.length > 0) syllableBase += availableFinals[Math.floor(Math.random() * availableFinals.length)];
                                else if (!ph.allowNoCoda) { validSyllable = false; break; }
                            }
                        }
                    } else { 
                        for (const codaC of codaStructure.split('')) {
                            if (codaC === 'C') {
                                if (availableFinals.length > 0) {
                                    syllableBase += availableFinals[Math.floor(Math.random() * availableFinals.length)];
                                } else if (!ph.allowNoCoda) { validSyllable = false; break; }
                            }
                        }
                    }
                }
                 if (!validSyllable) { attempts++; continue; }


                if (!ph.allowVowelInitial && ph.vowels.includes(syllableBase[0])) validSyllable = false;
                
                const lastChar = syllableBase.slice(-1);
                const lastSegmentIsConsonant = ph.consonants.includes(lastChar) || 
                                               (ph.allowedCodaClusters.some(cc => syllableBase.endsWith(cc)) && syllableBase.length > 1);

                if (lastSegmentIsConsonant && ph.forbiddenFinalSounds.some(s => syllableBase.endsWith(s))) {
                    validSyllable = false;
                }
                
                if (!ph.allowNoCoda && !lastSegmentIsConsonant) { 
                     validSyllable = false;
                }


                (ph.phonotactics || []).forEach(rule => {
                    if (!validSyllable) return;
                    if (rule.enabled && rule.type === "custom_regex" && rule.pattern) {
                        try { if (new RegExp(rule.pattern).test(syllableBase)) validSyllable = false; } 
                        catch(e) { console.warn("Invalid phonotactic regex:", rule.pattern, e); }
                    }
                });
                if (!validSyllable) { attempts++; continue; }

                let phoneticForm = syllableBase;
                const sortedActiveSCRules = [...ph.activeSoundChanges].sort((a,b) => a.order - b.order);
                sortedActiveSCRules.forEach(rule => {
                    phoneticForm = applyActiveSoundChangeRule(phoneticForm, rule);
                });
        
                let toneRepresentation = "";
                if (ph.hasTones && ph.tones.length > 0) {
                    const applicableTones = ph.tones.filter(tone => {
                        for (const tpRule of (ph.tonePhonotactics || [])) {
                             const initialPhonemesForForm = phoneticForm.match(new RegExp(`^(${ph.consonants.join('|')})*`))?.[0] || "";
                             const finalPhonemesForForm = phoneticForm.match(new RegExp(`(${ph.consonants.join('|')})*$ `))?.[0] || ""; 

                            const initialMatch = tpRule.initials.length === 0 || tpRule.initials.some(init => initialPhonemesForForm.includes(init));
                            const finalMatch = tpRule.finals.length === 0 || tpRule.finals.some(fin => finalPhonemesForForm.includes(fin));
                            
                            if (initialMatch && finalMatch && tpRule.forbiddenTones.includes(tone.number)) {
                                return false; 
                            }
                        }
                        return true; 
                    });

                    if (applicableTones.length > 0) {
                        const randomTone = applicableTones[Math.floor(Math.random() * applicableTones.length)];
                        toneRepresentation = randomTone.representation || "";
                        if (!toneRepresentation && randomTone.number >= 0 && randomTone.number <= 9) { 
                            const superscripts = ["‚Å∞", "¬π", "¬≤", "¬≥", "‚Å¥", "‚Åµ", "‚Å∂", "‚Å∑", "‚Å∏", "‚Åπ"];
                            toneRepresentation = superscripts[randomTone.number];
                        } else if (!toneRepresentation && randomTone.number > 0) { 
                            // Fallback for numbers > 9 or if representation is complex and not a single char
                            toneRepresentation = `^${randomTone.number}`; // Or handle differently
                        }
                    } 
                }
                phoneticForm += toneRepresentation; // Add tone marker to the end of the syllable's phonetic form
        
                return { base: syllableBase, phonetic: phoneticForm };
            }
        
            // Fallback if syllable generation fails after many attempts
            let fallbackSyllable = (ph.consonants[0] || "p") + (ph.vowels[0] || "a");
            console.warn("Syllable generation fallback after 100 attempts. Using:", fallbackSyllable);
            return { base: fallbackSyllable, phonetic: fallbackSyllable };
        }


        function hasConsonantCluster(text, consonantsList) {
            let consonantCount = 0;
            for (const char of text) {
                if (consonantsList.includes(char)) {
                    consonantCount++;
                    if (consonantCount > 1) return true; // Found a cluster of at least 2
                } else {
                    consonantCount = 0; // Reset count if non-consonant
                }
            }
            return false;
        }
        
        // Helper function to create a single rule step's UI
        function createRuleStepUI(step = { id: `step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', ruleValue: '' }, forNounPlural = false) {
            const stepDiv = document.createElement('div');
            stepDiv.className = 'p-2 mb-2 border rounded bg-purple-100 rule-step-item draggable-item'; // Added draggable-item
            stepDiv.dataset.stepId = step.id;
            stepDiv.dataset.order = step.order;
            stepDiv.setAttribute('draggable', true); // Make it draggable


            let valueInputHTML = '';
            const currentRuleValue = forNounPlural ? step.value : step.ruleValue; // Use step.value for noun plural

            if (step.ruleType === 'conditionalSuffix') {
                const parts = (currentRuleValue || 'N/A>N/A>N/A').split('>');
                valueInputHTML = `
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-1 mt-1">
                        <input type="text" value="${parts[0] || '*'}" placeholder="‡∏™‡∏£‡∏∞ (*=any)" class="p-1 border rounded text-xs rule-step-cond-vowel" title="‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡πÄ‡∏ä‡πà‡∏ô * ‡∏´‡∏£‡∏∑‡∏≠ a,i)">
                        <input type="text" value="${parts[1] || ''}" placeholder="‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞" class="p-1 border rounded text-xs rule-step-affix-after" title="‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞ (......)">
                        <input type="text" value="${parts[2] || ''}" placeholder="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏ó‡πâ‡∏≤‡∏¢" class="p-1 border rounded text-xs rule-step-final-suffix" title="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (‡πÄ‡∏ä‡πà‡∏ô ita)">
                    </div>`;
            } else {
                valueInputHTML = `<input type="text" value="${currentRuleValue || ''}" placeholder="‡∏Ñ‡πà‡∏≤" class="w-full p-1 border rounded text-xs rule-step-value">`;
            }

            stepDiv.innerHTML = `
                <div class="flex justify-between items-center mb-1">
                    <span class="text-xs font-semibold cursor-grab"><i class="fas fa-grip-vertical mr-1 text-gray-400"></i>‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${step.order + 1} (ID: ${step.id})</span>
                    <button type="button" class="text-xs text-red-500 hover:text-red-700 remove-rule-step-btn">&times; ‡∏•‡∏ö‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 items-end">
                    <div>
                        <label class="block text-xs">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Å‡∏é:</label>
                        <select class="w-full p-1 border rounded text-xs rule-step-type">
                            <option value="suffix" ${step.ruleType === 'suffix' ? 'selected' : ''}>‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢ (‡πÄ‡∏ï‡∏¥‡∏°‡∏ó‡πâ‡∏≤‡∏¢)</option>
                            <option value="prefix" ${step.ruleType === 'prefix' ? 'selected' : ''}>‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ (‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏ô‡πâ‡∏≤)</option>
                            <option value="infix" ${step.ruleType === 'infix' ? 'selected' : ''}>‡∏≠‡∏≤‡∏Ñ‡∏° (‡πÄ‡∏ï‡∏¥‡∏°‡∏Å‡∏•‡∏≤‡∏á)</option>
                            <option value="ablaut" ${step.ruleType === 'ablaut' ? 'selected' : ''}>‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞ (Ablaut)</option>
                            <option value="suppletion" ${step.ruleType === 'suppletion' ? 'selected' : ''}>‡∏£‡∏π‡∏õ‡∏û‡∏¥‡πÄ‡∏®‡∏© (Suppletion)</option>
                            <option value="conditionalSuffix" ${step.ruleType === 'conditionalSuffix' ? 'selected' : ''}>‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Conditional Suffix)</option>
                            <option value="none" ${step.ruleType === 'none' ? 'selected' : ''}>‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á</option>
                        </select>
                    </div>
                    <div class="rule-step-value-container">${valueInputHTML}</div>
                </div>
            `;

            stepDiv.querySelector('.rule-step-type').addEventListener('change', function() {
                const valueContainer = this.closest('.rule-step-item').querySelector('.rule-step-value-container');
                const selectedType = this.value;
                let newValueInputHTML = '';
                if (selectedType === 'conditionalSuffix') {
                     newValueInputHTML = `
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-1 mt-1">
                             <input type="text" value="*" placeholder="‡∏™‡∏£‡∏∞ (*=any)" class="p-1 border rounded text-xs rule-step-cond-vowel" title="‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡πÄ‡∏ä‡πà‡∏ô * ‡∏´‡∏£‡∏∑‡∏≠ a,i)">
                            <input type="text" placeholder="‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞" class="p-1 border rounded text-xs rule-step-affix-after" title="‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞ (......)">
                            <input type="text" placeholder="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏ó‡πâ‡∏≤‡∏¢" class="p-1 border rounded text-xs rule-step-final-suffix" title="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (‡πÄ‡∏ä‡πà‡∏ô ita)">
                        </div>`;
                } else {
                    newValueInputHTML = `<input type="text" placeholder="‡∏Ñ‡πà‡∏≤" class="w-full p-1 border rounded text-xs rule-step-value">`;
                }
                valueContainer.innerHTML = newValueInputHTML;
            });
            
            stepDiv.querySelector('.remove-rule-step-btn').addEventListener('click', function() {
                const stepItem = this.closest('.rule-step-item');
                const stepsContainer = stepItem.parentElement;
                stepItem.remove();
                
                // Re-number steps after removal
                const allStepItems = stepsContainer.querySelectorAll('.rule-step-item');
                allStepItems.forEach((s, i) => {
                    s.dataset.order = i;
                    s.querySelector('.font-semibold').innerHTML = `<i class="fas fa-grip-vertical mr-1 text-gray-400"></i>‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${i + 1} (ID: ${s.dataset.stepId})`;
                });
            });
            return stepDiv;
        }

        function setupRuleStepDragAndDrop(containerElementId) {
            const listContainer = document.getElementById(containerElementId);
            if (!listContainer) return;

            let draggedStep = null;

            listContainer.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('draggable-item')) {
                    draggedStep = e.target;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', e.target.dataset.stepId);
                    setTimeout(() => { if(draggedStep) draggedStep.style.opacity = '0.5'; }, 0);
                }
            });

            listContainer.addEventListener('dragend', (e) => {
                if (draggedStep) {
                    setTimeout(() => {
                        if(draggedStep) draggedStep.style.opacity = '1';
                        draggedStep = null;
                        // Update order in DOM and re-label
                        const allStepItems = listContainer.querySelectorAll('.rule-step-item');
                        allStepItems.forEach((s, i) => {
                            s.dataset.order = i; // Update data-order attribute
                            s.querySelector('.font-semibold').innerHTML = `<i class="fas fa-grip-vertical mr-1 text-gray-400"></i>‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${i + 1} (ID: ${s.dataset.stepId})`;
                        });

                    }, 0);
                }
            });

            listContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const targetItem = e.target.closest('.draggable-item');
                if (targetItem && draggedStep && targetItem !== draggedStep) {
                    const rect = targetItem.getBoundingClientRect();
                    const next = (e.clientY - rect.top) / (rect.bottom - rect.top) > 0.5;
                    if (next) {
                        listContainer.insertBefore(draggedStep, targetItem.nextSibling);
                    } else {
                        listContainer.insertBefore(draggedStep, targetItem);
                    }
                }
            });
        }


        function renderGrammarUI(container) {
            const grammar = currentLanguage.grammar;
            grammar.morphology = grammar.morphology || {}; 
            grammar.morphology.conjugationCategories = grammar.morphology.conjugationCategories || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.grammar.morphology.conjugationCategories));
            grammar.morphology.conjugationRules = grammar.morphology.conjugationRules || [];
            grammar.morphology.nounPluralization = grammar.morphology.nounPluralization || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.grammar.morphology.nounPluralization));
            if (!grammar.morphology.nounPluralization.ruleSteps) { // Ensure ruleSteps for nounPluralization
                grammar.morphology.nounPluralization.ruleSteps = JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.grammar.morphology.nounPluralization.ruleSteps));
            }
            grammar.partsOfSpeech = grammar.partsOfSpeech || [...DEFAULT_LANGUAGE_STATE.grammar.partsOfSpeech];
            grammar.genders = grammar.genders || [...DEFAULT_LANGUAGE_STATE.grammar.genders];
        
            const grammarContainerId = 'grammarTabSpecificContent';
            let grammarContainer = container.querySelector(`#${grammarContainerId}`);
            if (!grammarContainer) {
                grammarContainer = document.createElement('div');
                grammarContainer.id = grammarContainerId;
                container.appendChild(grammarContainer);
            }
            grammarContainer.innerHTML = ''; 
        
            const section = document.createElement('div');
            section.className = 'space-y-6 p-3 border border-blue-200 rounded-md bg-blue-50';
        
            createSelectInput(section, '‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (Basic Sentence Structure):', 'sentenceStructureSelectGrammar', grammar.sentenceStructure,
                ['SVO', 'SOV', 'VSO', 'VOS', 'OSV', 'OVS'].map(s => ({ value: s, text: s }))
            ).onchange = (e) => { grammar.sentenceStructure = e.target.value; saveData(); };
        
            createListInput(section, 'üè∑Ô∏è ‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥ (Parts of Speech)', grammar.partsOfSpeech, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥ (‡πÄ‡∏ä‡πà‡∏ô Noun, Noun:Animate)",
                (item) => { grammar.partsOfSpeech.push(item); renderGrammarUI(container); saveData(); },
                (index) => { grammar.partsOfSpeech.splice(index, 1); renderGrammarUI(container); saveData(); }
            );
        
            const genderWrapper = document.createElement('div');
            genderWrapper.className = 'p-3 border border-blue-300 rounded-md bg-white';
            genderWrapper.innerHTML = `<h4 class="font-semibold text-blue-700 mb-2">‡πÄ‡∏û‡∏®‡∏ó‡∏≤‡∏á‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå (Grammatical Gender)</h4>`;
            createCheckboxInput(genderWrapper, '‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏û‡∏®‡∏ó‡∏≤‡∏á‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå', 'hasGenderCheckboxGrammar', grammar.hasGender, '', 
                (e) => {
                    grammar.hasGender = e.target.checked;
                    renderGrammarUI(container); saveData();
                });
            if (grammar.hasGender) {
                createListInput(genderWrapper, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏®', grammar.genders, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏® (‡πÄ‡∏ä‡πà‡∏ô Masculine)",
                    (item) => { grammar.genders.push(item); renderGrammarUI(container); saveData(); },
                    (index) => { grammar.genders.splice(index, 1); renderGrammarUI(container); saveData(); }
                );
            }
            section.appendChild(genderWrapper);
        
            const conjugationSection = document.createElement('div');
            conjugationSection.className = 'p-3 border border-purple-300 rounded-md bg-purple-50';
            conjugationSection.innerHTML = `<h3 class="text-lg font-semibold text-purple-700 mb-3">‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥ (Inflections/Conjugations)</h3>
                                            <p class="text-xs text-gray-500 mb-2">‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡∏´‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô "‡∏£‡∏π‡∏õ‡πÅ‡∏£‡∏Å" ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÉ‡∏ô Grapheme Mappings ‡πÄ‡∏™‡∏°‡∏≠ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠</p>`;
        
            const catMgmtSection = document.createElement('div');
            catMgmtSection.innerHTML = `<h4 class="font-medium text-purple-600 mb-2">1. ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (Inflection Categories)</h4>`;
            
            const catsListContainer = document.createElement('div');
            catsListContainer.id = 'conjugationCategoriesListGrammar';
            (grammar.morphology.conjugationCategories).forEach(cat => {
                const catDiv = document.createElement('div');
                catDiv.className = 'p-2 mb-2 border rounded bg-white text-sm';
                catDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <strong>${cat.name}</strong>
                        <button class="text-xs text-red-500 hover:text-red-700" onclick="removeConjugationCategory('${cat.id}')">‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</button>
                    </div>
                    <p class="text-xs text-gray-600">‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö POS: ${cat.appliesToPOS.join(', ') || 'N/A'}</p>
                    <div class="mt-1">
                        <label class="text-xs font-medium">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢ (Options):</label>
                        <div class="flex flex-wrap gap-1 mt-1">
                            ${cat.options.map((opt, idx) => `
                                <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs flex items-center">
                                    ${opt}
                                    <button class="ml-1 text-purple-500 hover:text-purple-700" onclick="removeOptionFromConjugationCategory('${cat.id}', ${idx})">&times;</button>
                                </span>`).join('')}
                        </div>
                        <div class="flex gap-1 mt-1">
                            <input type="text" placeholder="‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢" class="p-1 border rounded text-xs flex-grow category-option-input-grammar" data-catid="${cat.id}">
                            <button class="text-xs btn-secondary bg-purple-400 px-1 py-0.5 rounded" onclick="addOptionToConjugationCategory('${cat.id}')">‡πÄ‡∏û‡∏¥‡πà‡∏°</button>
                        </div>
                    </div>
                `;
                catsListContainer.appendChild(catDiv);
            });
            catMgmtSection.appendChild(catsListContainer);
        
            const addCatForm = document.createElement('div');
            addCatForm.className = 'mt-2 p-2 border-t flex flex-wrap gap-2 items-end';
            addCatForm.innerHTML = `
               <div class="flex-grow min-w-[150px]"><label class="text-xs">‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÉ‡∏´‡∏°‡πà:</label><input type="text" id="newConjCategoryNameGrammar" placeholder="‡πÄ‡∏ä‡πà‡∏ô Tense, Number" class="w-full p-1 border rounded text-sm"></div>
                <div class="flex-grow min-w-[200px]">
                    <label class="text-xs">‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥:</label>
                    <div id="newConjCategoryPOSCheckboxesGrammar" class="grid grid-cols-2 sm:grid-cols-3 gap-1 p-1 border rounded bg-white max-h-24 overflow-y-auto">
                        ${currentLanguage.grammar.partsOfSpeech.map(pos => `
                            <div class="flex items-center">
                                <input type="checkbox" id="chk_pos_cat_${pos.replace(/\W/g, '')}" value="${pos}" class="h-3.5 w-3.5 mr-1 new-conj-cat-pos-chk">
                                <label for="chk_pos_cat_${pos.replace(/\W/g, '')}" class="text-xs">${pos}</label>
                            </div>`).join('')}
                    </div>
                </div>
                <button id="addConjugationCategoryBtnGrammar" class="btn-secondary bg-purple-500 px-2 py-1 rounded text-sm">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô</button>
            `;
            catMgmtSection.appendChild(addCatForm);
            conjugationSection.appendChild(catMgmtSection);
        
            const ruleDefSection = document.createElement('div');
            ruleDefSection.className = 'mt-4 pt-3 border-t border-purple-200';
            ruleDefSection.innerHTML = `<h4 class="font-medium text-purple-600 mb-2">2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥ (Inflection Rules)</h4>`;
            
            const addRuleForm = document.createElement('div');
            addRuleForm.className = 'p-3 mb-3 border rounded bg-white text-sm';
            addRuleForm.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 items-end mb-3">
                    <div><label class="block text-xs">‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Å‡∏é:</label><input type="text" id="infRuleDescGrammar" placeholder="‡πÄ‡∏ä‡πà‡∏ô Past Tense Verbs" class="w-full p-1 border rounded"></div>
                    <div><label class="block text-xs">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥ (POS):</label><select id="infRulePOSGrammar" class="w-full p-1 border rounded"></select></div>
                    <div><label class="block text-xs">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (Category):</label><select id="infRuleCategoryGrammar" class="w-full p-1 border rounded"></select></div>
                    <div class="lg:col-span-2"><label class="block text-xs">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢ (Option):</label><select id="infRuleOptionGrammar" class="w-full p-1 border rounded"></select></div>
                </div>
                <div class="mt-2 p-2 border-t border-purple-300">
                  <h5 class="text-sm font-semibold mb-1 text-purple-700">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (Rule Steps):</h5>
                  <div id="infRuleStepsContainerGrammar" class="space-y-2 rule-steps-list-container bg-purple-50 p-2 rounded">
                    <!-- Steps will be added here by JS -->
                  </div>
                  <button type="button" id="addNewInfRuleStepBtnGrammar" class="text-xs btn-secondary bg-purple-300 hover:bg-purple-400 text-purple-800 px-2 py-1 mt-2 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô</button>
                </div>
                <div class="mt-3 text-right"><button id="addInflectionRuleBtnGrammar" class="btn-primary bg-purple-600 px-3 py-1.5 rounded text-sm">‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô</button></div>
            `;
            ruleDefSection.appendChild(addRuleForm);

            const rulesListContainer = document.createElement('div');
            rulesListContainer.id = 'inflectionRulesListGrammar';
            rulesListContainer.className = 'max-h-60 overflow-y-auto';
            (grammar.morphology.conjugationRules).forEach(rule => {
                 const cat = grammar.morphology.conjugationCategories.find(c => c.id === rule.categoryId);
                 const stepsDisplay = (rule.ruleSteps || [])
                                         .sort((a,b) => a.order - b.order)
                                         .map(s => `${s.ruleType}:'${s.ruleValue}'`).join(' ‚Üí ');
                 rulesListContainer.innerHTML += `
                    <div class="p-2 mb-1 border rounded bg-white text-xs flex justify-between items-center">
                        <span><strong>${rule.description}</strong> (${rule.partOfSpeech} -> ${cat ? cat.name : 'N/A'}: ${rule.categoryOption} :: ${stepsDisplay || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô'})</span>
                        <button class="text-xs text-red-500 hover:text-red-700" onclick="removeConjugationRule('${rule.id}')">‡∏•‡∏ö</button>
                    </div>`;
            });
            ruleDefSection.appendChild(rulesListContainer);
            conjugationSection.appendChild(ruleDefSection);

            const testerSection = document.createElement('div');
            testerSection.className = 'mt-4 pt-3 border-t border-purple-200';
            testerSection.innerHTML = `
                <h4 class="font-medium text-purple-600 mb-2">3. ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥</h4>
                <div class="flex gap-2 mb-2">
                    <input type="text" id="conjugationTestWordGrammar" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏à‡∏≤‡∏Å‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏° (‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ ‡∏´‡∏£‡∏∑‡∏≠ ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô)" class="w-full p-1 border rounded text-sm" list="dictionaryWordsDatalistForConjTest">
                    <datalist id="dictionaryWordsDatalistForConjTest"></datalist>
                    <button id="conjugationTestBtnGrammar" class="btn-secondary bg-purple-500 px-2 py-1 rounded text-sm">‡∏ó‡∏î‡∏™‡∏≠‡∏ö</button>
                </div>
                <div id="conjugationTestResultGrammar" class="p-2 bg-white rounded border min-h-[50px] text-sm max-h-80 overflow-y-auto">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</div>
            `;
            conjugationSection.appendChild(testerSection);
            section.appendChild(conjugationSection);
        
            const nounPluralData = grammar.morphology.nounPluralization;
            const nounPluralSection = document.createElement('div');
            nounPluralSection.className = 'mt-4 pt-3 border-t border-blue-200'; 
            nounPluralSection.innerHTML = `
                <h4 class="font-semibold text-blue-700 mb-1">‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏≥‡∏ô‡∏≤‡∏°‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå (Noun Pluralization):</h4>
                <div class="p-2 border rounded bg-blue-100">
                    <h5 class="text-sm font-semibold mb-1 text-blue-700">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå (Pluralization Steps):</h5>
                    <div id="nounPluralStepsContainerGrammar" class="space-y-2 rule-steps-list-container bg-blue-50 p-2 rounded">
                        <!-- Noun plural steps will be added here by JS -->
                    </div>
                    <button type="button" id="addNewNounPluralStepBtnGrammar" class="text-xs btn-secondary bg-blue-300 hover:bg-blue-400 text-blue-800 px-2 py-1 mt-2 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô</button>
                    <div class="mt-2 text-right">
                        <button id="setNounPluralRuleBtnGrammar" class="btn-secondary bg-blue-400 hover:bg-blue-500 px-2 py-1 rounded-md text-xs">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏é‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå</button>
                    </div>
                </div>`;
            section.appendChild(nounPluralSection);
            
            grammarContainer.appendChild(section);
        
            populateInfRulePOSSelect();
            document.getElementById('infRulePOSGrammar').addEventListener('change', populateInfRuleCategorySelect);
            document.getElementById('infRuleCategoryGrammar').addEventListener('change', (e) => {
                populateInfRuleOptionSelect();
                const catName = e.target.options[e.target.selectedIndex]?.text || '';
                const descInput = document.getElementById('infRuleDescGrammar');
                if (descInput && (!descInput.value || grammar.morphology.conjugationCategories.some(c => descInput.value === c.name))) { 
                    descInput.value = catName;
                }
            });
            
            // Populate and set up general inflection rule steps UI
            const infRuleStepsContainer = document.getElementById('infRuleStepsContainerGrammar');
            if (infRuleStepsContainer) {
                 // Always start with one fresh step for adding a new rule
                 infRuleStepsContainer.innerHTML = ''; // Clear existing if any (should not be any for "add new")
                 infRuleStepsContainer.appendChild(createRuleStepUI({id: `step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', ruleValue: ''}));
                
                document.getElementById('addNewInfRuleStepBtnGrammar').addEventListener('click', () => {
                    const currentSteps = infRuleStepsContainer.querySelectorAll('.rule-step-item');
                    infRuleStepsContainer.appendChild(createRuleStepUI({id: `step_${nextRuleStepId++}`, order: currentSteps.length, ruleType: 'suffix', ruleValue: ''}));
                });
                setupRuleStepDragAndDrop('infRuleStepsContainerGrammar');
            }

            // Populate and set up noun pluralization steps UI
            const nounPluralStepsContainer = document.getElementById('nounPluralStepsContainerGrammar');
            if (nounPluralStepsContainer) {
                nounPluralStepsContainer.innerHTML = ''; // Clear first
                const pluralSteps = currentLanguage.grammar.morphology.nounPluralization.ruleSteps || 
                                    [{ id: `plural_step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', value: 's' }];
                if(pluralSteps.length === 0){ // Ensure at least one default step if array is empty
                     pluralSteps.push({ id: `plural_step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', value: 's' });
                }
                pluralSteps.sort((a,b) => a.order - b.order).forEach((step, index) => {
                    nounPluralStepsContainer.appendChild(createRuleStepUI({
                        id: step.id || `plural_step_${nextRuleStepId++}`,
                        order: index, // Re-assign order based on sorted array
                        ruleType: step.ruleType,
                        ruleValue: step.value // createRuleStepUI expects ruleValue, which is `value` for plural
                    }, true)); // true for forNounPlural
                });
                document.getElementById('addNewNounPluralStepBtnGrammar').addEventListener('click', () => {
                     const currentSteps = nounPluralStepsContainer.querySelectorAll('.rule-step-item');
                     nounPluralStepsContainer.appendChild(createRuleStepUI({id: `plural_step_${nextRuleStepId++}`, order: currentSteps.length, ruleType: 'suffix', ruleValue: ''}, true));
                });
                setupRuleStepDragAndDrop('nounPluralStepsContainerGrammar');
            }
            
            document.getElementById('addConjugationCategoryBtnGrammar').addEventListener('click', addConjugationCategory);
            document.getElementById('addInflectionRuleBtnGrammar').addEventListener('click', addInflectionRule);
            document.getElementById('setNounPluralRuleBtnGrammar').addEventListener('click', () => {
                const newRuleSteps = [];
                const stepElements = document.querySelectorAll('#nounPluralStepsContainerGrammar .rule-step-item');
                let errorOccurred = false;
                stepElements.forEach((stepEl, index) => { // Use index from DOM order for 'order'
                    if (errorOccurred) return;
                    const stepId = stepEl.dataset.stepId;
                    const ruleType = stepEl.querySelector('.rule-step-type').value;
                    let stepValue = '';
                    if (ruleType === 'conditionalSuffix') {
                        const condVowel = stepEl.querySelector('.rule-step-cond-vowel').value.trim();
                        const affixAfter = stepEl.querySelector('.rule-step-affix-after').value.trim();
                        const finalSuffix = stepEl.querySelector('.rule-step-final-suffix').value.trim();
                         if (!condVowel || !finalSuffix) {
                             alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏µ‡πà ${index + 1}: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á" ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç" ‡πÅ‡∏•‡∏∞ "‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢"`);
                             errorOccurred = true; return;
                         }
                        stepValue = `${condVowel}>${affixAfter}>${finalSuffix}`;
                    } else {
                        const valueInput = stepEl.querySelector('.rule-step-value');
                        if (valueInput) stepValue = valueInput.value.trim();
                        else console.warn("Could not find .rule-step-value for step type:", ruleType);
                    }
                     if (ruleType !== 'none' && !stepValue && !['ablaut', 'infix', 'suppletion'].includes(ruleType) && !(ruleType === 'conditionalSuffix' && stepValue.split('>')[0] && stepValue.split('>')[2])) {
                         alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏µ‡πà ${index + 1}: ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏Ñ‡πà‡∏≤" ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Å‡∏é '${ruleType}'`);
                         errorOccurred = true; return;
                     }
                    newRuleSteps.push({ id: stepId, order: index, ruleType: ruleType, value: stepValue }); // Store as 'value'
                });

                if (errorOccurred) return;

                if (newRuleSteps.length === 0) {
                     if (!confirm("‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? (‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏π‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå)")) {
                         return;
                     }
                }
                currentLanguage.grammar.morphology.nounPluralization = { ruleSteps: newRuleSteps };
                renderGrammarUI(container); 
                saveData(); 
            });
            document.getElementById('conjugationTestBtnGrammar').addEventListener('click', testConjugation);
            populateDictionaryWordsDatalist('dictionaryWordsDatalistForConjTest', false); 
        }


        function updateNounPluralValueInput() { // OBSOLETE with multi-step UI
            // This function is no longer needed as each step has its own value input logic
            // in createRuleStepUI. Kept here for reference if parts are useful elsewhere.
        }


        function updateInfRuleValueInput() { // OBSOLETE with multi-step UI
            // This function is no longer needed as each step has its own value input logic
            // in createRuleStepUI.
        }


        function populateDictionaryWordsDatalist(datalistId, useBaseFormForValue = false) {
            const datalist = document.getElementById(datalistId);
            if (!datalist) return;
            datalist.innerHTML = ''; 
            currentLanguage.lexicon.forEach(word => {
                const option = document.createElement('option');
                const orthographicDisplay = getOrthographicForm(word); 
                option.value = useBaseFormForValue ? word.word : orthographicDisplay; 
                option.textContent = `${orthographicDisplay} (${word.meaning}) [‡∏ê‡∏≤‡∏ô: ${word.word}]`;
                if (!useBaseFormForValue) { 
                    option.dataset.baseform = word.word;
                }
                option.dataset.wordid = word.id; 
                datalist.appendChild(option);
            });
        }
        
        function addConjugationCategory() {
            const nameInput = document.getElementById('newConjCategoryNameGrammar');
            const posCheckboxesContainer = document.getElementById('newConjCategoryPOSCheckboxesGrammar');
            const name = nameInput.value.trim();
            const selectedPOS = Array.from(posCheckboxesContainer.querySelectorAll('.new-conj-cat-pos-chk:checked')).map(chk => chk.value);
        
            if (name && selectedPOS.length > 0) {
                if (currentLanguage.grammar.morphology.conjugationCategories.some(c => c.name.toLowerCase() === name.toLowerCase())) {
                    alert(`‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏ä‡∏∑‡πà‡∏≠ "${name}" ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß`);
                    return;
                }
                const newCatId = `cat_${nextConjCategoryId++}`;
                currentLanguage.grammar.morphology.conjugationCategories.push({
                    id: newCatId,
                    name: name,
                    appliesToPOS: selectedPOS,
                    options: [] 
                });
                nameInput.value = ''; 
                posCheckboxesContainer.querySelectorAll('.new-conj-cat-pos-chk:checked').forEach(chk => chk.checked = false); 
                renderGrammarUI(tabContentContainer); 
                saveData();
            } else {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£');
            }
        }
        
        window.removeConjugationCategory = (catId) => {
            currentLanguage.grammar.morphology.conjugationCategories = currentLanguage.grammar.morphology.conjugationCategories.filter(c => c.id !== catId);
            currentLanguage.grammar.morphology.conjugationRules = currentLanguage.grammar.morphology.conjugationRules.filter(r => r.categoryId !== catId);
            renderGrammarUI(tabContentContainer);
            saveData();
        };
        
        window.addOptionToConjugationCategory = (catId) => {
            const cat = currentLanguage.grammar.morphology.conjugationCategories.find(c => c.id === catId);
            const input = document.querySelector(`.category-option-input-grammar[data-catid="${catId}"]`); 
            if (cat && input) {
                const optionValue = input.value.trim();
                if (optionValue && !cat.options.includes(optionValue)) { 
                    cat.options.push(optionValue);
                    input.value = ''; 
                    renderGrammarUI(tabContentContainer);
                    saveData();
                }
            }
        };
        
        window.removeOptionFromConjugationCategory = (catId, optionIndex) => {
            const cat = currentLanguage.grammar.morphology.conjugationCategories.find(c => c.id === catId);
            if (cat && cat.options[optionIndex] !== undefined) {
                const optionToRemove = cat.options[optionIndex];
                cat.options.splice(optionIndex, 1); 
                currentLanguage.grammar.morphology.conjugationRules = currentLanguage.grammar.morphology.conjugationRules.filter(r => !(r.categoryId === catId && r.categoryOption === optionToRemove));
                renderGrammarUI(tabContentContainer);
                saveData();
            }
        };
        
        function populateInfRulePOSSelect() {
            const select = document.getElementById('infRulePOSGrammar');
            if (!select) return;
            select.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥ --</option>';
            currentLanguage.grammar.partsOfSpeech.forEach(pos => {
                select.innerHTML += `<option value="${pos}">${pos}</option>`;
            });
            populateInfRuleCategorySelect(); 
        }
        
        function populateInfRuleCategorySelect() {
            const posSelect = document.getElementById('infRulePOSGrammar');
            const catSelect = document.getElementById('infRuleCategoryGrammar');
            if (!posSelect || !catSelect) return;
        
            const selectedPOS = posSelect.value;
            catSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó --</option>';
            currentLanguage.grammar.morphology.conjugationCategories.forEach(cat => {
                if (!selectedPOS || cat.appliesToPOS.includes(selectedPOS) || cat.appliesToPOS.some(appliedPOS => selectedPOS.startsWith(appliedPOS + ":"))) {
                    catSelect.innerHTML += `<option value="${cat.id}">${cat.name}</option>`;
                }
            });
            populateInfRuleOptionSelect(); 
        }
        
        function populateInfRuleOptionSelect() {
            const catSelect = document.getElementById('infRuleCategoryGrammar');
            const optSelect = document.getElementById('infRuleOptionGrammar');
            if (!catSelect || !optSelect) return;
        
            const selectedCatId = catSelect.value;
            optSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢ --</option>';
            const category = currentLanguage.grammar.morphology.conjugationCategories.find(c => c.id === selectedCatId);
            if (category) {
                category.options.forEach(opt => {
                    optSelect.innerHTML += `<option value="${opt}">${opt}</option>`;
                });
            }
        }
        
        function addInflectionRule() {
            const description = document.getElementById('infRuleDescGrammar').value.trim();
            const pos = document.getElementById('infRulePOSGrammar').value;
            const categoryId = document.getElementById('infRuleCategoryGrammar').value;
            const categoryOption = document.getElementById('infRuleOptionGrammar').value;

            if (!description || !pos || !categoryId || !categoryOption) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î, ‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥, ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó, ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢)');
                return;
            }

            const ruleSteps = [];
            const stepElements = document.querySelectorAll('#infRuleStepsContainerGrammar .rule-step-item');
            let errorInSteps = false;
            stepElements.forEach((stepEl, index) => {
                if(errorInSteps) return;
                const stepId = stepEl.dataset.stepId;
                const order = parseInt(stepEl.dataset.order); // Get order from data attribute
                const ruleType = stepEl.querySelector('.rule-step-type').value;
                let ruleValue = '';
                if (ruleType === 'conditionalSuffix') {
                    const condVowel = stepEl.querySelector('.rule-step-cond-vowel').value.trim();
                    const affixAfter = stepEl.querySelector('.rule-step-affix-after').value.trim();
                    const finalSuffix = stepEl.querySelector('.rule-step-final-suffix').value.trim();
                    if (!condVowel || !finalSuffix) {
                         alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${index + 1}: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á" ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç" ‡πÅ‡∏•‡∏∞ "‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢"`);
                         errorInSteps = true; return;
                    }
                    ruleValue = `${condVowel}>${affixAfter}>${finalSuffix}`;
                } else {
                    const valueInput = stepEl.querySelector('.rule-step-value');
                    if (valueInput) ruleValue = valueInput.value.trim();
                    else console.warn("Could not find .rule-step-value for step:", stepEl);
                }
                 if (ruleType !== 'none' && !ruleValue && !['ablaut', 'infix', 'suppletion'].includes(ruleType) && !(ruleType === 'conditionalSuffix' && ruleValue.split('>')[0] && ruleValue.split('>')[2])) {
                     alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${index + 1}: ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏Ñ‡πà‡∏≤" ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Å‡∏é '${ruleType}'`);
                     errorInSteps = true; return;
                 }
                ruleSteps.push({ id: stepId, order: order, ruleType, ruleValue });
            });

            if (errorInSteps) return;

            if (ruleSteps.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô"); return;
            }
            
            ruleSteps.sort((a,b) => a.order - b.order); // Ensure steps are sorted by their DOM order before saving

            const existingRuleIndex = currentLanguage.grammar.morphology.conjugationRules.findIndex(r =>
                r.partOfSpeech === pos && r.categoryId === categoryId && r.categoryOption === categoryOption
            );

            const newRuleData = {
                id: existingRuleIndex > -1 ? currentLanguage.grammar.morphology.conjugationRules[existingRuleIndex].id : `rule_${nextConjRuleId++}`,
                description, 
                partOfSpeech: pos, 
                categoryId, 
                categoryOption, 
                ruleSteps
            };

            if (existingRuleIndex > -1) {
                if (!confirm(`‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${pos} -> ${currentLanguage.grammar.morphology.conjugationCategories.find(c=>c.id === categoryId)?.name}:${categoryOption} ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (${currentLanguage.grammar.morphology.conjugationRules[existingRuleIndex].description}). ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`)) {
                    return;
                }
                currentLanguage.grammar.morphology.conjugationRules[existingRuleIndex] = newRuleData;
            } else {
                currentLanguage.grammar.morphology.conjugationRules.push(newRuleData);
            }
            
            document.getElementById('infRuleDescGrammar').value = '';
            const infRuleStepsContainer = document.getElementById('infRuleStepsContainerGrammar');
            if(infRuleStepsContainer) {
                infRuleStepsContainer.innerHTML = '';
                infRuleStepsContainer.appendChild(createRuleStepUI({id: `step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', ruleValue: ''}));
            }


            renderGrammarUI(tabContentContainer); 
            saveData();
        }
        
        window.removeConjugationRule = (ruleId) => {
            currentLanguage.grammar.morphology.conjugationRules = currentLanguage.grammar.morphology.conjugationRules.filter(r => r.id !== ruleId);
            renderGrammarUI(tabContentContainer);
            saveData();
        };

        // This function applies a single step of a rule
        function applyRuleStep(currentWord, stepRuleType, stepRuleValue) {
            let inflectedWord = currentWord;
            switch (stepRuleType) {
                case 'prefix': inflectedWord = stepRuleValue + currentWord; break;
                case 'suffix': inflectedWord = currentWord + stepRuleValue; break;
                case 'infix':
                    if (stepRuleValue.includes('>')) {
                        const parts = stepRuleValue.split('>');
                        const charToFind = parts[0]; const charToInsert = parts[1];
                        const idx = currentWord.lastIndexOf(charToFind);
                        if (idx !== -1) inflectedWord = currentWord.slice(0, idx + charToFind.length) + charToInsert + currentWord.slice(idx + charToFind.length);
                        else { // Fallback if charToFind is not present
                           const mid = Math.floor(currentWord.length / 2);
                           inflectedWord = currentWord.slice(0, mid) + stepRuleValue.replace(charToFind + ">", "") + currentWord.slice(mid);
                        }
                    } else { // Simple infix in the middle
                        const mid = Math.floor(currentWord.length / 2);
                        inflectedWord = currentWord.slice(0, mid) + stepRuleValue + currentWord.slice(mid);
                    }
                    break;
                case 'ablaut':
                    let tempWord = currentWord;
                    const changes = stepRuleValue.split(',').map(s => s.trim());
                    changes.forEach(change => {
                        if (change.includes('>')) {
                            const parts = change.split('>');
                            const fromVowel = parts[0].trim(); const toVowel = parts[1].trim();
                            const escapedFromVowel = fromVowel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            try { tempWord = tempWord.replace(new RegExp(escapedFromVowel, 'g'), toVowel); }
                            catch (e) { console.error("Error in ablaut regex:", e); }
                        }
                    });
                    inflectedWord = tempWord;
                    break;
                case 'suppletion': inflectedWord = stepRuleValue; break;
                case 'conditionalSuffix':
                    if (typeof stepRuleValue === 'string' && stepRuleValue.includes('>')) {
                        const parts = stepRuleValue.split('>');
                        if (parts.length === 3) {
                            const condVowelSpec = parts[0].trim();    // e.g., "*", "a", "i,e"
                            const epentheticSound = parts[1].trim(); // The "......" part, e.g., "n"
                            const finalSuffix = parts[2].trim();     // The main suffix, e.g., "ita"

                            let wordEndsWithQualifyingVowel = false;
                            const languageVowels = currentLanguage.phonology.vowels || [];

                            if (condVowelSpec === '*') { // Any vowel from the language's vowel inventory
                                wordEndsWithQualifyingVowel = languageVowels.some(v => currentWord.endsWith(v));
                            } else { // Specific vowel(s) listed in condVowelSpec
                                const specifiedConditionVowels = condVowelSpec.split(',').map(v => v.trim()).filter(Boolean);
                                wordEndsWithQualifyingVowel = specifiedConditionVowels.some(vCond => 
                                    currentWord.endsWith(vCond) && languageVowels.includes(vCond)
                                );
                            }

                            if (wordEndsWithQualifyingVowel) {
                                inflectedWord = currentWord + epentheticSound + finalSuffix;
                            } else {
                                // Word ends in a consonant, or a vowel not matching the specific condition
                                inflectedWord = currentWord + finalSuffix; // Apply final suffix directly
                            }
                        } else {
                            console.warn("Conditional suffix ruleValue format error:", stepRuleValue, "Expected 3 parts separated by '>'. Applying last part as suffix.");
                            inflectedWord = currentWord + (parts[parts.length-1] || ''); // Fallback
                        }
                    } else {
                         console.warn("Conditional suffix ruleValue is not a string or malformed:", stepRuleValue, "Attempting direct suffixation if string.");
                         if (typeof stepRuleValue === 'string') { // If it's just a string, treat as simple suffix
                            inflectedWord = currentWord + stepRuleValue;
                         }
                    }
                    break;
                case 'none': default: break; 
            }
            return inflectedWord;
        }

        function applyInflectionRuleDefinition(baseWord, ruleDefinition) {
            if (!ruleDefinition || !ruleDefinition.ruleSteps || ruleDefinition.ruleSteps.length === 0) {
                return baseWord;
            }
            let currentWordState = baseWord;
            const sortedSteps = [...ruleDefinition.ruleSteps].sort((a,b) => a.order - b.order);

            for (const step of sortedSteps) {
                const valueToUse = step.ruleValue !== undefined ? step.ruleValue : step.value;
                currentWordState = applyRuleStep(currentWordState, step.ruleType, valueToUse);
            }
            return currentWordState;
        }


        function testConjugation() {
            const wordInput = document.getElementById('conjugationTestWordGrammar');
            const resultDiv = document.getElementById('conjugationTestResultGrammar');
            const inputValue = wordInput.value.trim(); 
        
            if (!inputValue) {
                resultDiv.innerHTML = '<p class="text-red-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ ‡∏´‡∏£‡∏∑‡∏≠ ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô)</p>'; return;
            }
        
            let wordEntry = null;
            const selectedOpt = Array.from(document.getElementById('dictionaryWordsDatalistForConjTest').options).find(opt => opt.value === inputValue || opt.dataset.baseform === inputValue);
            if (selectedOpt && selectedOpt.dataset.wordid) {
                wordEntry = currentLanguage.lexicon.find(w => w.id === parseInt(selectedOpt.dataset.wordid));
            }
            // Fallback: Search by orthographic form or base phonemic form if datalist selection failed or wasn't used
            if (!wordEntry) {
                wordEntry = currentLanguage.lexicon.find(w => getOrthographicForm(w) === inputValue || w.word === inputValue);
            }
        
            if (!wordEntry) {
                resultDiv.innerHTML = `<p class="text-red-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "${inputValue}" ‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°</p>`; return;
            }
        
            const wordPOS = wordEntry.partOfSpeech;
            let htmlResult = `<h5 class="font-semibold">‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö: ${getOrthographicForm(wordEntry)} (${wordEntry.meaning}) - POS: ${wordPOS}</h5>`;
            
            htmlResult += `<div class="my-2"><strong>‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</strong> <select id="conjTestCategoryFilter" multiple class="w-full p-1 border rounded text-sm h-20">`;
            currentLanguage.grammar.morphology.conjugationCategories.forEach(cat => {
                if (cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"))) {
                     htmlResult += `<option value="${cat.id}" selected>${cat.name}</option>`; 
                }
            });
            htmlResult += `</select><button onclick="updateConjugationTestTable(${wordEntry.id})" class="text-xs btn-secondary mt-1">‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</button></div>`; 


            htmlResult += `<div id="conjugationTestTableContainer">`; 
            htmlResult += generateConjugationTableContent(wordEntry.id, null); 
            htmlResult += `</div>`;

            resultDiv.innerHTML = htmlResult;
            const filterSelect = document.getElementById('conjTestCategoryFilter');
            if(filterSelect) filterSelect.onchange = () => updateConjugationTestTable(wordEntry.id);
        }

        function updateConjugationTestTable(wordId) {
            const filterSelect = document.getElementById('conjTestCategoryFilter');
            const selectedCategoryIds = filterSelect ? Array.from(filterSelect.selectedOptions).map(opt => opt.value) : null;
            const tableContainer = document.getElementById('conjugationTestTableContainer');
            if (tableContainer) {
                tableContainer.innerHTML = generateConjugationTableContent(wordId, selectedCategoryIds);
            }
        }

        function generateConjugationTableContent(wordId, selectedCategoryIds = null) {
            const wordEntry = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
            if (!wordEntry) return '<p>Error: Word not found.</p>';

            const wordPOS = wordEntry.partOfSpeech;
            let tableContent = `<table class="min-w-full divide-y divide-gray-200 table-sm mt-2">
                                <thead class="bg-gray-50"><tr>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á)</th>
                                </tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            
            let foundApplicableCategory = false;
            let categoryColorIndex = 0; 
            const applicableCategories = currentLanguage.grammar.morphology.conjugationCategories.filter(cat => {
                if (selectedCategoryIds && !selectedCategoryIds.includes(cat.id)) return false; 
                return cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"));
            });


            applicableCategories.forEach(cat => {
                foundApplicableCategory = true;
                const categoryBgClass = `inflection-category-bg-${categoryColorIndex % 3}`; 
                cat.options.forEach((option, optIndex) => {
                    const manualInflectionKey = `${cat.id}_${option.replace(/\s+/g, '_')}`; 
                    const manualInflection = wordEntry.manualInflections ? wordEntry.manualInflections[manualInflectionKey] : null;
                    
                    let inflectedPhoneticForm = wordEntry.word; 
                    let inflectedOrthographicForm; // Will be determined below
                    let isManual = false;

                    if (manualInflection && manualInflection.phonetic) { 
                        inflectedPhoneticForm = manualInflection.phonetic;
                        // For manual overrides, customOrthography field of the manualInflection should be used if present.
                        // If not, transliterate the manual phonetic form (using first grapheme rule).
                        inflectedOrthographicForm = manualInflection.orthographic || getOrthographicForm({word: inflectedPhoneticForm, customOrthography: null}, true, true);
                        isManual = true;
                    } else {
                        const rule = currentLanguage.grammar.morphology.conjugationRules.find(r =>
                            (r.partOfSpeech === wordPOS || wordPOS.startsWith(r.partOfSpeech + ":")) && 
                            r.categoryId === cat.id && r.categoryOption === option
                        );
                        if (rule) { // Rule itself contains ruleSteps
                            inflectedPhoneticForm = applyInflectionRuleDefinition(wordEntry.word, rule); // Use the new function
                            // For rule-generated forms, use the first grapheme rule for consistency.
                            inflectedOrthographicForm = getOrthographicForm({word: inflectedPhoneticForm, customOrthography: null}, true, true);
                        } else {
                            // No rule, no manual override: show base form, transliterated with first grapheme rule.
                            inflectedPhoneticForm = wordEntry.word;
                            inflectedOrthographicForm = getOrthographicForm({word: wordEntry.word, customOrthography: null}, true, true);
                        }
                    }
                    
                    const formattedPhoneticDisplay = autoFormatDetailedPhonetics(inflectedPhoneticForm, currentLanguage.phonology);
                    
                    tableContent += `<tr class="${categoryBgClass}">
                                    <td class="px-2 py-1">${optIndex === 0 ? cat.name : ''}</td>
                                    <td class="px-2 py-1">${option} ${isManual ? '<em class="text-xs text-blue-500">(manual)</em>' : ''}</td>
                                    <td class="px-2 py-1 font-mono">${inflectedOrthographicForm}</td>
                                    <td class="px-2 py-1 font-mono text-gray-600">${formattedPhoneticDisplay}</td>
                                   </tr>`;
                });
                categoryColorIndex++;
            });
        
            if (!foundApplicableCategory) { 
                tableContent += `<tr><td colspan="4" class="text-center py-2">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ (${wordPOS}) ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</td></tr>`;
            }
            tableContent += `</tbody></table>`;
            return tableContent;
        }


        window.showWordConjugationModal = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;
            word.manualInflections = word.manualInflections || {}; 

            const wordPOS = word.partOfSpeech;
            let content = `<p class="text-sm mb-2">‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á): <strong class="font-mono">${word.word}</strong> | ‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ): <strong class="font-mono">${getOrthographicForm(word)}</strong></p>`;
            
            content += `<div class="my-2"><strong>‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</strong> <select id="conjModalCategoryFilter" multiple class="w-full p-1 border rounded text-sm h-20">`;
            currentLanguage.grammar.morphology.conjugationCategories.forEach(cat => {
                 if (cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"))) {
                     content += `<option value="${cat.id}" selected>${cat.name}</option>`;
                 }
            });
            content += `</select><button onclick="updateWordConjugationModalTable(${wordId})" class="text-xs btn-secondary mt-1">‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</button></div>`;

            content += `<div id="wordConjugationModalTableContainer">`; 
            content += generateWordConjugationModalTableContent(word.id, null); 
            content += `</div>`;
            
            genericModalTitle.textContent = `‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏á: ${getOrthographicForm(word)}`;
            genericModalContent.innerHTML = content;
            genericModalFooter.innerHTML = `<button id="saveConjugationOverridesBtn" class="btn-primary">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button> <button class="btn-secondary" onclick="closeGenericModal.click()">‡∏õ‡∏¥‡∏î</button>`;
            
            document.getElementById('saveConjugationOverridesBtn').onclick = () => {
                saveConjugationOverrides(wordId);
                genericModal.classList.add('hidden');
            };
            const filterSelect = document.getElementById('conjModalCategoryFilter');
            if(filterSelect) filterSelect.onchange = () => updateWordConjugationModalTable(wordId);

            wordDetailModal.classList.add('hidden'); 
            genericModal.classList.remove('hidden');
        };

        function updateWordConjugationModalTable(wordId) {
            const filterSelect = document.getElementById('conjModalCategoryFilter');
            const selectedCategoryIds = filterSelect ? Array.from(filterSelect.selectedOptions).map(opt => opt.value) : null;
            const tableContainer = document.getElementById('wordConjugationModalTableContainer');
            if (tableContainer) {
                tableContainer.innerHTML = generateWordConjugationModalTableContent(wordId, selectedCategoryIds);
            }
        }

        function generateWordConjugationModalTableContent(wordId, selectedCategoryIds = null) {
             const word = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
             if (!word) return '<p>Error: Word not found.</p>';
             word.manualInflections = word.manualInflections || {};
             const wordPOS = word.partOfSpeech;

             let tableContent = `<table class="min-w-full divide-y divide-gray-200 table-sm mt-2">
                                <thead class="bg-gray-100"><tr>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">Override</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á)</th>
                                </tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            
            let foundApplicableCategory = false;
            let categoryColorIndex = 0;
            const applicableCategories = currentLanguage.grammar.morphology.conjugationCategories.filter(cat => {
                if (selectedCategoryIds && !selectedCategoryIds.includes(cat.id)) return false;
                return cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"));
            });

            applicableCategories.forEach(cat => {
                foundApplicableCategory = true;
                const categoryBgClass = `inflection-category-bg-${categoryColorIndex % 3}`;

                cat.options.forEach((option, optIndex) => {
                    const manualInflectionKey = `${cat.id}_${option.replace(/\s+/g, '_')}`;
                    const currentManualOverride = word.manualInflections[manualInflectionKey];
                    
                    let ruleBasedPhonetic = word.word; 
                    const rule = currentLanguage.grammar.morphology.conjugationRules.find(r =>
                        (r.partOfSpeech === wordPOS || wordPOS.startsWith(r.partOfSpeech+":")) && 
                        r.categoryId === cat.id && r.categoryOption === option
                    );
                    if (rule) ruleBasedPhonetic = applyInflectionRuleDefinition(word.word, rule);
                    
                    // Rule-based orthographic form using the first grapheme rule for consistency.
                    const ruleBasedOrthographic = getOrthographicForm({word: ruleBasedPhonetic, customOrthography: null}, true, true);
                    
                    const initialOrthoValue = currentManualOverride?.orthographic || ruleBasedOrthographic;
                    const initialPhoneticValue = currentManualOverride?.phonetic || ruleBasedPhonetic; 
                    const displayPhoneticFormatted = autoFormatDetailedPhonetics(initialPhoneticValue, currentLanguage.phonology); 


                    tableContent += `<tr class="${categoryBgClass}">
                                    <td class="px-2 py-1 ${optIndex === 0 ? 'font-semibold text-purple-700' : ''}">${optIndex === 0 ? cat.name : ''}</td>
                                    <td class="px-2 py-1">${option}</td>
                                    <td class="px-2 py-1">
                                        <input type="checkbox" class="manual-override-chk h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500" data-key="${manualInflectionKey}" ${currentManualOverride ? 'checked' : ''} 
                                               onchange="toggleManualInflectionInputs(this, '${manualInflectionKey}', '${ruleBasedOrthographic}', '${ruleBasedPhonetic}', ${wordId})">
                                    </td>
                                    <td class="px-2 py-1">
                                        <input type="text" class="w-full p-0.5 border rounded text-xs font-mono manual-ortho-input" data-key="${manualInflectionKey}" 
                                               value="${initialOrthoValue}" ${!currentManualOverride ? 'disabled' : ''}>
                                    </td>
                                    <td class="px-2 py-1">
                                         <input type="text" class="w-full p-0.5 border rounded text-xs font-mono manual-phonetic-input" data-key="${manualInflectionKey}" 
                                               value="${initialPhoneticValue}" ${!currentManualOverride ? 'disabled' : ''} 
                                               placeholder="‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡∏î‡∏¥‡∏ö)" oninput="updateFormattedPhoneticDisplay(this, '${manualInflectionKey}')">
                                         <span class="text-xs text-gray-500 manual-phonetic-display" data-key="${manualInflectionKey}">${displayPhoneticFormatted}</span>
                                    </td>
                               </tr>`;
                });
                categoryColorIndex++;
            });

            if (!foundApplicableCategory) {
                 tableContent += `<tr><td colspan="5" class="text-center py-2">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ (${wordPOS}) ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</td></tr>`;
            }
            tableContent += `</tbody></table>`;
            return tableContent;
        }

        function updateFormattedPhoneticDisplay(inputElement, key) {
            const displaySpan = inputElement.parentElement.querySelector(`.manual-phonetic-display[data-key="${key}"]`);
            if (displaySpan) {
                displaySpan.textContent = autoFormatDetailedPhonetics(inputElement.value, currentLanguage.phonology);
            }
        }


        function toggleManualInflectionInputs(checkbox, key, ruleBasedOrthographic, ruleBasedPhonetic, wordId) {
            const row = checkbox.closest('tr');
            const orthoInput = row.querySelector(`.manual-ortho-input[data-key="${key}"]`);
            const phoneticInput = row.querySelector(`.manual-phonetic-input[data-key="${key}"]`);
            const phoneticDisplaySpan = phoneticInput.nextElementSibling; 

            if (checkbox.checked) {
                orthoInput.disabled = false;
                phoneticInput.disabled = false;
            } else {
                orthoInput.disabled = true;
                phoneticInput.disabled = true;
                orthoInput.value = ruleBasedOrthographic;
                phoneticInput.value = ruleBasedPhonetic; 
                if (phoneticDisplaySpan) phoneticDisplaySpan.textContent = autoFormatDetailedPhonetics(ruleBasedPhonetic, currentLanguage.phonology);
            }
        }
        
        function saveConjugationOverrides(wordId) {
            const word = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
            if (!word) return;
            word.manualInflections = word.manualInflections || {}; 

            genericModalContent.querySelectorAll('.manual-override-chk').forEach(chk => {
                const key = chk.dataset.key;
                if (chk.checked) { 
                    const orthoInput = genericModalContent.querySelector(`.manual-ortho-input[data-key="${key}"]`);
                    const phoneticInput = genericModalContent.querySelector(`.manual-phonetic-input[data-key="${key}"]`);
                    word.manualInflections[key] = {
                        orthographic: orthoInput.value.trim(),
                        phonetic: phoneticInput.value.trim() 
                    };
                } else { 
                    delete word.manualInflections[key]; 
                }
            });
            saveData();
            if (activeTab === 'dictionary') {
                 const searchInputEl = document.querySelector('#dictionaryTabSpecificContent input[type="text"][id^="dictionarySearch_"]');
                 const currentSearchTerm = searchInputEl ? searchInputEl.value.trim().toLowerCase() : "";
                 
                 if (currentSearchTerm.length > 0) {
                    const filtered = currentLanguage.lexicon.filter(entry =>
                        getOrthographicForm(entry).toLowerCase().includes(currentSearchTerm) || 
                        entry.word.toLowerCase().includes(currentSearchTerm) || 
                        entry.meaning.toLowerCase().includes(currentSearchTerm) ||
                        (entry.phonetics && autoFormatDetailedPhonetics(entry.phonetics, currentLanguage.phonology).toLowerCase().includes(currentSearchTerm)) || 
                        (entry.synonyms && entry.synonyms.some(s => s.toLowerCase().includes(currentSearchTerm)))
                    ).slice(0, 50); 
                    renderDictionaryTable(filtered);
                } else {
                    renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
                }
            }
        }



        function renderDictionaryUI(container) {
            currentLanguage.lexicon = currentLanguage.lexicon || [];
            const dictContainerId = 'dictionaryTabSpecificContent';
            let dictContainer = container.querySelector(`#${dictContainerId}`);
            if(!dictContainer){
                dictContainer = document.createElement('div');
                dictContainer.id = dictContainerId;
                container.appendChild(dictContainer);
            }
            dictContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-yellow-200 rounded-md bg-yellow-50';
            const searchId = `dictionarySearch_${Date.now()}`; 
            const suggestionsId = `autocompleteSuggestionsContainer_${Date.now()}`;

            section.innerHTML = `
                <div class="flex flex-wrap gap-4 mb-4 items-center">
                    <div class="relative flex-grow min-w-[200px]">
                        <input type="text" id="${searchId}" placeholder="üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ, ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô, ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢, ‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå)..." class="w-full p-2 border border-yellow-300 rounded-md">
                        <div id="${suggestionsId}" class="autocomplete-suggestions hidden bg-white border border-gray-300 rounded-md shadow-lg" style="width: calc(100% - 0px); top: 100%; left:0;"></div>
                    </div>
                     <button id="clearSearchBtnDict" class="btn-secondary bg-gray-400 hover:bg-gray-500 px-3 py-2 rounded-md text-sm">‡∏•‡πâ‡∏≤‡∏á</button>
                </div>
                <div class="flex flex-wrap gap-2 mb-4 items-center">
                    <button id="exportJsonBtnDict" class="btn-secondary bg-amber-400 hover:bg-amber-500 px-3 py-1 rounded-md text-sm"><i class="fas fa-file-export mr-1"></i>Export JSON</button>
                    <button id="exportCsvBtnDict" class="btn-secondary bg-amber-400 hover:bg-amber-500 px-3 py-1 rounded-md text-sm"><i class="fas fa-file-csv mr-1"></i>Export CSV</button>
                    <button id="showAddWordModalBtnDict" class="btn-primary bg-yellow-500 hover:bg-yellow-600 py-2 px-4 rounded-md ml-auto"><i class="fas fa-plus mr-1"></i>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà</button>
                </div>
                <div id="dictionaryTableContainer" class="overflow-x-auto">
                     <p class="text-center text-gray-500">‡∏û‡∏¥‡∏°‡∏û‡πå‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà (‡πÅ‡∏™‡∏î‡∏á ${currentLanguage.lexicon.length} ‡∏Ñ‡∏≥)</p>
                </div>`;
            dictContainer.appendChild(section);

            const searchInput = document.getElementById(searchId);
            const suggestionsContainer = document.getElementById(suggestionsId);

            const doSearch = () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                 if (searchTerm.length > 0) {
                    const filtered = currentLanguage.lexicon.filter(entry =>
                        getOrthographicForm(entry).toLowerCase().includes(searchTerm) || 
                        entry.word.toLowerCase().includes(searchTerm) || 
                        entry.meaning.toLowerCase().includes(searchTerm) ||
                        (entry.phonetics && entry.phonetics.toLowerCase().includes(searchTerm)) || 
                        (entry.synonyms && entry.synonyms.some(s => s.toLowerCase().includes(searchTerm)))
                    ).slice(0, 50); 
                    renderDictionaryTable(filtered);
                } else {
                    renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
                }
            };

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                if (searchTerm.length > 0) {
                    const suggestions = currentLanguage.lexicon
                        .filter(entry => 
                            getOrthographicForm(entry).toLowerCase().startsWith(searchTerm) || 
                            entry.word.toLowerCase().startsWith(searchTerm) || 
                            entry.meaning.toLowerCase().startsWith(searchTerm)
                        )
                        .slice(0, 10); 

                    suggestionsContainer.innerHTML = '';
                    if (suggestions.length > 0) {
                        suggestions.forEach(suggestion => {
                            const div = document.createElement('div');
                            div.textContent = `${getOrthographicForm(suggestion)} (${suggestion.meaning}) [${suggestion.word}]`;
                            div.className = 'autocomplete-suggestion p-2 hover:bg-gray-100 cursor-pointer';
                            div.onclick = () => {
                                searchInput.value = getOrthographicForm(suggestion); 
                                suggestionsContainer.classList.add('hidden');
                                doSearch(); 
                            };
                            suggestionsContainer.appendChild(div);
                        });
                        suggestionsContainer.classList.remove('hidden');
                    } else {
                        suggestionsContainer.classList.add('hidden');
                    }
                } else {
                    suggestionsContainer.classList.add('hidden');
                }
                doSearch(); 
            });

            document.getElementById('clearSearchBtnDict').addEventListener('click', () => {
                searchInput.value = '';
                suggestionsContainer.classList.add('hidden');
                renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
            });

            document.addEventListener('click', function(event) {
                if (searchInput && suggestionsContainer && !searchInput.contains(event.target) && !suggestionsContainer.contains(event.target)) {
                    suggestionsContainer.classList.add('hidden');
                }
            });

            document.getElementById('exportJsonBtnDict').addEventListener('click', exportDictionaryAsJSON);
            document.getElementById('exportCsvBtnDict').addEventListener('click', exportDictionaryAsCSV);
            document.getElementById('showAddWordModalBtnDict').addEventListener('click', () => showWordModal());

            renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
        }

        function renderDictionaryTable(lexiconSubset) {
            const container = document.getElementById('dictionaryTableContainer');
            if (!container) return;
            container.innerHTML = ''; 

            if (!lexiconSubset || lexiconSubset.length === 0) {
                container.innerHTML = `<p class="text-center text-gray-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${currentLanguage.lexicon.length} ‡∏Ñ‡∏≥)</p>`;
                return;
            }

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-yellow-300 bg-white shadow-sm rounded-lg';
            table.innerHTML = `
                <thead class="bg-yellow-100">
                    <tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á)</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î)</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider hidden sm:table-cell">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-yellow-200"></tbody>
            `;
            const tbody = table.querySelector('tbody');
            lexiconSubset.forEach(entry => {
                const row = tbody.insertRow();
                const displayWord = getOrthographicForm(entry); 
                row.innerHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-700 font-semibold"><a href="#" class="text-purple-600 hover:underline" onclick="event.preventDefault(); showWordDetailPopup(${entry.id})">${displayWord}</a></td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500 font-mono">${entry.word}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500 font-mono">${entry.phonetics || 'N/A'}</td>
                    <td class="px-4 py-2 text-sm text-gray-700">${entry.meaning}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${entry.partOfSpeech} ${entry.gender ? `(${entry.gender})` : ''}</td>
                    <td class="px-4 py-2 text-sm text-gray-500 hidden sm:table-cell">${entry.example || 'N/A'}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm">
                        <button class="text-indigo-500 hover:text-indigo-700 mr-1" title="‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå" onclick="showSynonymsModal(${entry.id})"><i class="fas fa-sync-alt"></i></button>
                        <button class="text-blue-500 hover:text-blue-700 mr-1" title="‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç" onclick="showWordModal(${entry.id})"><i class="fas fa-edit"></i></button>
                        <button class="text-red-500 hover:text-red-700" title="‡∏•‡∏ö" onclick="deleteWordFromDictionary(${entry.id})"><i class="fas fa-trash"></i></button>
                    </td>
                `;
            });
            container.appendChild(table);
            container.innerHTML += `<p class="text-xs text-gray-400 mt-1">‡πÅ‡∏™‡∏î‡∏á ${lexiconSubset.length} ‡∏à‡∏≤‡∏Å ${currentLanguage.lexicon.length} ‡∏Ñ‡∏≥</p>`;
        }
        
        window.showSynonymsModal = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;

            genericModalTitle.textContent = `‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå‡∏Ç‡∏≠‡∏á: ${getOrthographicForm(word)}`;
            let contentHtml = '';
            if (word.synonyms && word.synonyms.length > 0) {
                contentHtml += '<ul class="list-disc list-inside space-y-1">';
                word.synonyms.forEach(synonymText => {
                    const synonymEntry = currentLanguage.lexicon.find(w => w.word === synonymText || getOrthographicForm(w) === synonymText);
                    if (synonymEntry) {
                        contentHtml += `<li><strong>${getOrthographicForm(synonymEntry)}</strong> (${synonymEntry.meaning})</li>`;
                    } else {
                        contentHtml += `<li>${synonymText} (‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°)</li>`;
                    }
                });
                contentHtml += '</ul>';
            } else {
                contentHtml = '<p class="text-gray-500">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ</p>';
            }
            genericModalContent.innerHTML = contentHtml;
            genericModalFooter.innerHTML = `<button class="btn-secondary" onclick="closeGenericModal.click()">‡∏õ‡∏¥‡∏î</button>`;
            genericModal.classList.remove('hidden');
        };


        window.showWordDetailPopup = (wordId) => {
            const word = (currentLanguage.lexicon || []).find(w => w.id === wordId);
            if (!word) return;
        
            wordDetailTitle.textContent = getOrthographicForm(word);
            let contentHtml = '';
            const fields = [
                { label: '‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)', value: getOrthographicForm(word) },
                { label: '‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (Base Phonemic Form)', value: word.word },
                { label: '‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Detailed Phonetics)', value: word.phonetics },
                { label: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢ (Meaning)', value: word.meaning },
                { label: '‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥ (Part of Speech)', value: word.partOfSpeech },
            ];
            if (currentLanguage.grammar.hasGender && word.gender) {
                fields.push({ label: '‡πÄ‡∏û‡∏® (Gender)', value: word.gender });
            }
            fields.push(
                { label: '‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ (Example)', value: word.example },
                { label: '‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå (Synonyms)', value: word.synonyms ? word.synonyms.join(', ') : null }
            );
        
            fields.forEach(field => {
                if (field.value && field.value.toString().trim() !== '') {
                    contentHtml += `<div class="word-detail-popup-field"><strong class="text-purple-600">${field.label}:</strong> ${field.value}</div>`;
                }
            });
        
            if (word.etymology) {
                let etymologyHtml = '';
                if (word.etymology.notes) etymologyHtml += `<p class="text-xs"><strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ${word.etymology.notes}</p>`;
                if (word.etymology.roots && word.etymology.roots.length > 0) {
                    etymologyHtml += `<p class="mt-1 text-xs"><strong>‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå:</strong></p><ul class="list-disc list-inside ml-4 text-xs">`;
                    word.etymology.roots.forEach(root => {
                        if (root.wordId) {
                            const parentWord = currentLanguage.lexicon.find(w => w.id === root.wordId);
                            etymologyHtml += `<li>‡∏à‡∏≤‡∏Å: <strong>${parentWord ? getOrthographicForm(parentWord) : '‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏•‡∏ö'}</strong> <span class="font-mono text-xs text-gray-500">[‡∏ê‡∏≤‡∏ô: ${parentWord ? parentWord.word : 'N/A'}]</span></li>`;
                        } else if (root.customRoot) {
                            etymologyHtml += `<li>‡∏°‡∏≤‡∏à‡∏≤‡∏Å: <strong>${root.customRoot}</strong> (${root.sourceLang || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'})</li>`;
                        }
                    });
                    etymologyHtml += `</ul>`;
                }
                if (etymologyHtml) contentHtml += `<div class="word-detail-popup-field"><strong class="text-purple-600">‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (Etymology):</strong>${etymologyHtml}</div>`;
            }
        
            if (word.evolutionTimeline && word.evolutionTimeline.length > 0) {
                let evolutionHtml = `<p class="mt-1 text-xs"><strong>‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ï‡∏≤‡∏°‡∏¢‡∏∏‡∏Ñ:</strong></p><ul class="list-disc list-inside ml-4 text-xs">`;
                const sortedEras = [...currentLanguage.eras].sort((a,b) => (a.order || 0) - (b.order || 0));
                sortedEras.forEach(era => {
                    const evoEntry = word.evolutionTimeline.find(e => e.eraId === era.id);
                    if (evoEntry && (evoEntry.orthographicForm || evoEntry.phoneticForm)) {
                         evolutionHtml += `<li><strong>${era.name}:</strong> ${getOrthographicForm({word: evoEntry.phoneticForm, customOrthography: evoEntry.orthographicForm})} ${evoEntry.notes ? `(${evoEntry.notes})` : ''}</li>`;
                    }
                });
                evolutionHtml += `</ul>`;
                contentHtml += `<div class="word-detail-popup-field"><strong class="text-purple-600">‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥ (Evolution):</strong>${evolutionHtml}</div>`;
            }
        
            const hasDialectForms = word.dialectalForms && word.dialectalForms.length > 0;

            wordDetailContent.innerHTML = contentHtml || '<p class="text-gray-500">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°</p>';
        
            wordDetailButtons.innerHTML = `
                <button class="btn-secondary text-xs" onclick="openEtymologyTreeForWord(${word.id})"><i class="fas fa-seedling mr-1"></i> ‡∏î‡∏π‡∏ú‡∏±‡∏á‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤</button>
                <button class="btn-secondary text-xs" onclick="openEvolutionModalForWord(${word.id})"><i class="fas fa-history mr-1"></i> ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥</button>
                <button class="btn-secondary text-xs" onclick="openDialectModalForWord(${word.id})"><i class="fas fa-map-signs mr-1"></i> ${hasDialectForms ? '‡∏î‡∏π/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô' : '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô'}</button>
            `;
            
            const wordPOS = word.partOfSpeech;
            const canConjugate = currentLanguage.grammar.morphology.conjugationCategories.some(cat => cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":")));
            if (canConjugate) {
                const conjButton = document.createElement('button');
                conjButton.className = 'btn-secondary text-xs bg-purple-500 hover:bg-purple-600';
                conjButton.innerHTML = `<i class="fas fa-project-diagram mr-1"></i> ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥`;
                conjButton.onclick = () => showWordConjugationModal(word.id);
                wordDetailButtons.appendChild(conjButton);
            }
        
            wordDetailModal.classList.remove('hidden');
        };

        window.openEtymologyTreeForWord = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (word) {
                switchTab('etymology'); 
                setTimeout(() => { 
                    const searchInput = document.getElementById('etymologyWordSearch');
                    if(searchInput) {
                        searchInput.value = getOrthographicForm(word); 
                        document.getElementById('searchEtymologyBtn').click(); 
                    }
                }, 100); 
            }
            wordDetailModal.classList.add('hidden');
        };

        function autoFormatDetailedPhonetics(basePhonemicForm, phonologyData) {
            if (!basePhonemicForm || !phonologyData) return `/${basePhonemicForm || ''}/`;

            let wordToFormat = basePhonemicForm;
            if (wordToFormat.startsWith('/') && wordToFormat.endsWith('/')) {
                wordToFormat = wordToFormat.slice(1, -1);
            }
            if (wordToFormat.startsWith('[') && wordToFormat.endsWith(']')) {
                wordToFormat = wordToFormat.slice(1, -1);
            }
            wordToFormat = wordToFormat.replace(/\./g, ''); 

            const { syllableStructures, consonants, vowels, hasTones, tones } = phonologyData;
            if (!syllableStructures || syllableStructures.length === 0) return `/${wordToFormat}/`;

            let remainingWord = wordToFormat;
            let parsedSyllables = [];
            
            const toneMarkers = (hasTones && tones && tones.length > 0) ? 
                                tones.map(t => t.representation || (t.number >=0 && t.number <=9 ? ["‚Å∞","¬π","¬≤","¬≥","‚Å¥","‚Åµ","‚Å∂","‚Å∑","‚Å∏","‚Åπ"][t.number] : null))
                                     .filter(Boolean) 
                                     .sort((a,b) => b.length - a.length) 
                                     .map(tm => tm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')) 
                                     .join('|')
                                : null;
            const toneRegexSuffixGlobal = toneMarkers ? new RegExp(`(${toneMarkers})$`) : null;
            const allPhonemesSorted = [...consonants, ...vowels].sort((a, b) => b.length - a.length);


            while (remainingWord.length > 0) {
                let longestMatchThisSyllable = '';
                let matchedStructureStr = '';

                for (const struct of syllableStructures.sort((a, b) => b.length - a.length)) {
                    let currentSyllableCandidate = '';
                    let tempRemaining = remainingWord;
                    let possibleSyllable = true;

                    for (const charType of struct) { 
                        let phonemeFoundForCharType = false;
                        const inventoryToSearch = (charType === 'C' ? consonants : vowels).sort((a, b) => b.length - a.length);
                        
                        for (const phon of inventoryToSearch) {
                            if (tempRemaining.startsWith(phon)) {
                                currentSyllableCandidate += phon;
                                tempRemaining = tempRemaining.substring(phon.length);
                                phonemeFoundForCharType = true;
                                break;
                            }
                        }
                        if (!phonemeFoundForCharType) { possibleSyllable = false; break; }
                    }

                    if (possibleSyllable) {
                        let toneForThisSyllable = "";
                        if (toneRegexSuffixGlobal && tempRemaining.length > 0) {
                            const toneMatch = tempRemaining.match(new RegExp(`^(${toneMarkers})`));
                            if (toneMatch) {
                                toneForThisSyllable = toneMatch[0];
                                currentSyllableCandidate += toneForThisSyllable;
                            }
                        }
                        if (currentSyllableCandidate.length > longestMatchThisSyllable.length) {
                            longestMatchThisSyllable = currentSyllableCandidate;
                            matchedStructureStr = struct; 
                        }
                    }
                }


                if (longestMatchThisSyllable.length > 0) {
                    parsedSyllables.push(longestMatchThisSyllable);
                    remainingWord = remainingWord.substring(longestMatchThisSyllable.length);
                } else {
                    let fallbackConsumed = false;
                    for (const phon of allPhonemesSorted) {
                         if (remainingWord.startsWith(phon)) {
                            parsedSyllables.push(phon);
                            remainingWord = remainingWord.substring(phon.length);
                            fallbackConsumed = true; break;
                        }
                    }
                     if (!fallbackConsumed && toneRegexSuffixGlobal && remainingWord.length > 0) { 
                        const toneMatch = remainingWord.match(new RegExp(`^(${toneMarkers})`));
                        if (toneMatch) {
                            parsedSyllables.push(toneMatch[0]);
                            remainingWord = remainingWord.substring(toneMatch[0].length);
                            fallbackConsumed = true;
                        }
                    }
                    if (!fallbackConsumed && remainingWord.length > 0) {
                        parsedSyllables.push(remainingWord[0]); 
                        remainingWord = remainingWord.substring(1);
                    }
                }
            }
            
            if (parsedSyllables.length > 0) return `/${parsedSyllables.join('.')}/`;
            return `/${basePhonemicForm}/`; 
        }


        window.showWordModal = (wordId = null, generatedWordPhoneticForm = null, generatedPhoneticsDetail = null, generatedMeaning = null) => {
            const existingWord = wordId ? currentLanguage.lexicon.find(w => w.id === wordId) : null;
            const modalId = 'wordEditModal';
            let modal = document.getElementById(modalId);
            if (modal) modal.remove(); 

            modal = document.createElement('div');
            modal.id = modalId;
            modal.className = 'fixed inset-0 z-[70] flex items-center justify-center modal p-4'; 

            const initialWordValue = existingWord ? existingWord.word : (generatedWordPhoneticForm || '');
            const initialCustomOrthography = existingWord ? (existingWord.customOrthography || '') : ''; // Ensure it's a string
            
            let initialPhonetics;
            if (existingWord && existingWord.phonetics) { initialPhonetics = existingWord.phonetics; } 
            else if (generatedPhoneticsDetail) { initialPhonetics = generatedPhoneticsDetail; } 
            else { initialPhonetics = autoFormatDetailedPhonetics(initialWordValue, currentLanguage.phonology); }


            let initialMeaning;
            if (existingWord) { initialMeaning = existingWord.meaning; } 
            else { 
                if (generatedMeaning) initialMeaning = generatedMeaning;
                else { 
                    if (apiThaiMeaningsDatabase.length > 0) initialMeaning = apiThaiMeaningsDatabase[Math.floor(Math.random() * apiThaiMeaningsDatabase.length)];
                    else if (localThaiMeaningsDatabase.length > 0) initialMeaning = localThaiMeaningsDatabase[Math.floor(Math.random() * localThaiMeaningsDatabase.length)];
                    else initialMeaning = '';
                }
            }

            const initialPartOfSpeech = existingWord ? existingWord.partOfSpeech : (currentLanguage.grammar.partsOfSpeech[0] || '‡∏ô‡∏≤‡∏°');
            const initialGender = existingWord ? existingWord.gender : (currentLanguage.grammar.hasGender && currentLanguage.grammar.genders.length > 0 ? currentLanguage.grammar.genders[0] : '');
            const initialExample = existingWord ? existingWord.example : '';
            const initialSynonyms = existingWord && existingWord.synonyms ? existingWord.synonyms.join(', ') : '';
            const initialEtymologyNotes = existingWord && existingWord.etymology ? existingWord.etymology.notes : '';

            let posOptionsHtml = '';
            currentLanguage.grammar.partsOfSpeech.forEach(pos => {
                posOptionsHtml += `<option value="${pos}" ${pos === initialPartOfSpeech ? 'selected' : ''}>${pos}</option>`;
            });

            let genderOptionsHtml = '';
             if (currentLanguage.grammar.hasGender && currentLanguage.grammar.genders && currentLanguage.grammar.genders.length > 0) {
                currentLanguage.grammar.genders.forEach(g => {
                    genderOptionsHtml += `<option value="${g}" ${g === initialGender ? 'selected' : ''}>${g}</option>`;
                });
            }

            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                    <h3 class="text-xl font-bold mb-4">${existingWord ? '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå: ' + getOrthographicForm(existingWord) : '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà'}</h3>
                    <p class="text-xs text-gray-500 mb-2">‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô) ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏Å‡∏é Active Sound Changes ‡πÅ‡∏•‡∏∞‡∏£‡∏ß‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÅ‡∏•‡πâ‡∏ß (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)</p>
                    <div class="space-y-3">
                        <div><label class="block text-sm font-medium">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á):</label><input type="text" id="modalWord" value="${initialWordValue}" class="w-full p-2 border rounded-md font-mono"></div>
                        <div><label class="block text-sm font-medium">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ - ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£):</label><input type="text" id="modalCustomOrthography" value="${initialCustomOrthography}" class="w-full p-2 border rounded-md font-mono" placeholder="‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏Å‡∏é‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"></div>
                        <div><label class="block text-sm font-medium">‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phonetics - ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î):</label><input type="text" id="modalPhonetics" value="${initialPhonetics}" class="w-full p-2 border rounded-md font-mono" placeholder="/‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå1.‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå2/"></div>
                        <div><label class="block text-sm font-medium">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢:</label><input type="text" id="modalMeaning" value="${initialMeaning}" class="w-full p-2 border rounded-md"></div>
                        <div>
                            <label class="block text-sm font-medium">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥:</label>
                            <select id="modalPartOfSpeech" class="w-full p-2 border rounded-md">${posOptionsHtml}</select>
                        </div>
                        ${currentLanguage.grammar.hasGender ? `
                        <div id="modalGenderSection" class="${initialPartOfSpeech.toLowerCase().includes('‡∏ô‡∏≤‡∏°') ? '' : 'hidden'}">
                            <label class="block text-sm font-medium">‡πÄ‡∏û‡∏®:</label>
                            <select id="modalGender" class="w-full p-2 border rounded-md">${genderOptionsHtml}</select>
                        </div>` : ''}
                        <div><label class="block text-sm font-medium">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ:</label><textarea id="modalExample" class="w-full p-2 border rounded-md">${initialExample}</textarea></div>
                        <div><label class="block text-sm font-medium">‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå (Synonyms - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ):</label><input type="text" id="modalSynonyms" value="${initialSynonyms}" class="w-full p-2 border rounded-md"></div>
                        <div id="etymologySectionModal">
                            <label class="block text-sm font-medium mb-1">‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (Etymology):</label>
                            <div id="etymologyRootsContainerModal" class="space-y-2 mb-2"></div>
                            <button id="addEtymologyRootModalBtn" class="text-xs btn-secondary bg-purple-400 hover:bg-purple-500 px-2 py-1 rounded-md">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå</button>
                            <div class="mt-2"><label class="block text-sm font-medium">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤:</label><textarea id="modalEtymologyNotes" class="w-full p-2 border rounded-md">${initialEtymologyNotes}</textarea></div>
                        </div>
                    </div>
                    <div class="mt-6 flex justify-end space-x-3">
                        <button id="cancelWordModalBtn" class="btn-secondary bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded-md">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
                        <button id="saveWordModalBtn" class="btn-primary px-4 py-2 rounded-md">${existingWord ? '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á' : '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå'}</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);

            const modalWordInput = modal.querySelector('#modalWord');
            const modalPhoneticsInput = modal.querySelector('#modalPhonetics');
            const modalCustomOrthographyInput = modal.querySelector('#modalCustomOrthography');

            const updateDerivedForms = () => {
                const basePhonemic = modalWordInput.value;
                modalPhoneticsInput.value = autoFormatDetailedPhonetics(basePhonemic, currentLanguage.phonology);
            };
            modalWordInput.addEventListener('input', updateDerivedForms);
            modalWordInput.addEventListener('change', updateDerivedForms);


            const modalPosSelect = modal.querySelector('#modalPartOfSpeech');
            const modalGenderSection = modal.querySelector('#modalGenderSection');
            if (modalPosSelect && modalGenderSection) {
                modalPosSelect.onchange = (e) => {
                    modalGenderSection.classList.toggle('hidden', !e.target.value.toLowerCase().includes('‡∏ô‡∏≤‡∏°'));
                };
            }

            const etymologyRootsContainerModal = modal.querySelector('#etymologyRootsContainerModal');
            let tempEtymologyRoots = existingWord && existingWord.etymology && existingWord.etymology.roots ? JSON.parse(JSON.stringify(existingWord.etymology.roots)) : [];

            const renderEtymologyRootsModal = () => {
                etymologyRootsContainerModal.innerHTML = '';
                const wordOptionsForRootDatalistId = `wordRootDatalist_${Date.now()}`;
                let datalistOptions = '';
                currentLanguage.lexicon.forEach(w => { 
                     if (!existingWord || w.id !== existingWord.id) { 
                         datalistOptions += `<option value="${w.word}" data-id="${w.id}">${getOrthographicForm(w)} (${w.meaning})</option>`;
                     }
                });
                etymologyRootsContainerModal.innerHTML += `<datalist id="${wordOptionsForRootDatalistId}">${datalistOptions}</datalist>`;


                tempEtymologyRoots.forEach((root, index) => {
                    const rootDiv = document.createElement('div');
                    rootDiv.className = 'flex items-center gap-2 p-2 border rounded bg-purple-50 flex-wrap sm:flex-nowrap';

                    const wordInput = document.createElement('input');
                    wordInput.type = 'text';
                    wordInput.setAttribute('list', wordOptionsForRootDatalistId);
                    wordInput.placeholder = '-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥ / ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏£‡∏≤‡∏Å‡πÄ‡∏≠‡∏á (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á) --';
                    wordInput.className = 'p-1 border rounded text-sm flex-grow modal-etymology-root-word w-full sm:w-auto mb-1 sm:mb-0 font-mono';
                    if(root.wordId){
                        const parentWord = currentLanguage.lexicon.find(w => w.id === root.wordId);
                        if(parentWord) wordInput.value = parentWord.word; 
                    } else if (root.customRoot) {
                        wordInput.value = root.customRoot;
                    }

                    const sourceLangInput = document.createElement('input');
                    sourceLangInput.type = 'text';
                    sourceLangInput.placeholder = '‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á)';
                    sourceLangInput.className = `p-1 border rounded text-sm modal-etymology-source-lang w-full sm:w-auto mb-1 sm:mb-0 ${root.wordId ? 'hidden': ''}`;
                    sourceLangInput.value = root.sourceLang || '';

                    wordInput.onchange = (e) => { 
                        const selectedOpt = Array.from(document.getElementById(wordOptionsForRootDatalistId).options).find(opt => opt.value === e.target.value);
                        if (selectedOpt) {
                            tempEtymologyRoots[index].wordId = parseInt(selectedOpt.dataset.id);
                            tempEtymologyRoots[index].customRoot = ''; 
                            tempEtymologyRoots[index].sourceLang = '';
                            sourceLangInput.classList.add('hidden');
                            sourceLangInput.value = '';
                        } else { 
                            tempEtymologyRoots[index].wordId = null;
                            tempEtymologyRoots[index].customRoot = e.target.value; 
                            sourceLangInput.classList.remove('hidden');
                        }
                    };
                    sourceLangInput.oninput = (e) => { if(tempEtymologyRoots[index]) tempEtymologyRoots[index].sourceLang = e.target.value; };

                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '‡∏•‡∏ö';
                   removeBtn.className = 'text-xs bg-red-400 hover:bg-red-500 text-white px-2 py-1 rounded h-fit';
                    removeBtn.onclick = () => { tempEtymologyRoots.splice(index,1); renderEtymologyRootsModal(); };

                    rootDiv.appendChild(wordInput);
                    rootDiv.appendChild(sourceLangInput);
                    rootDiv.appendChild(removeBtn);
                    etymologyRootsContainerModal.appendChild(rootDiv);
                });
            };
            renderEtymologyRootsModal();

            modal.querySelector('#addEtymologyRootModalBtn').onclick = () => {
                tempEtymologyRoots.push({ wordId: null, customRoot: '', sourceLang: '' });
                renderEtymologyRootsModal();
            };

            modal.querySelector('#cancelWordModalBtn').onclick = () => modal.remove();
            modal.querySelector('#saveWordModalBtn').onclick = () => {
                const updatedWord = {
                    id: existingWord ? existingWord.id : nextWordId,
                    word: modal.querySelector('#modalWord').value.trim(), 
                    customOrthography: modal.querySelector('#modalCustomOrthography').value.trim() || null, // Set to null if empty
                    phonetics: modal.querySelector('#modalPhonetics').value.trim(), 
                    meaning: modal.querySelector('#modalMeaning').value.trim(),
                    partOfSpeech: modal.querySelector('#modalPartOfSpeech').value,
                    gender: currentLanguage.grammar.hasGender && modal.querySelector('#modalGenderSection') && !modal.querySelector('#modalGenderSection').classList.contains('hidden') ? modal.querySelector('#modalGender').value : '',
                    example: modal.querySelector('#modalExample').value.trim(),
                    synonyms: modal.querySelector('#modalSynonyms').value.split(',').map(s => s.trim()).filter(s => s),
                    etymology: {
                        roots: tempEtymologyRoots.filter(r => r.wordId || (r.customRoot && r.customRoot.trim() !== '')), 
                        notes: modal.querySelector('#modalEtymologyNotes').value.trim()
                    },
                    evolutionTimeline: (existingWord && existingWord.evolutionTimeline) ? existingWord.evolutionTimeline : [], 
                    dialectalForms: (existingWord && existingWord.dialectalForms) ? existingWord.dialectalForms : [] 
                };

                if (!updatedWord.word || !updatedWord.meaning || !updatedWord.partOfSpeech) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á), ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢, ‡πÅ‡∏•‡∏∞‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥'); return;
                }

                if (existingWord) {
                    const index = currentLanguage.lexicon.findIndex(w => w.id === wordId);
                    currentLanguage.lexicon[index] = updatedWord;
                } else {
                    currentLanguage.lexicon.push(updatedWord);
                    nextWordId = calculateNextWordId(currentLanguage.lexicon); 
                }
                modal.remove();
                if (activeTab === 'dictionary') renderDictionaryUI(tabContentContainer);
                else if (activeTab === 'etymology') renderEtymologyUI(tabContentContainer); 
                saveData();
            };
        };

        window.deleteWordFromDictionary = (wordId) => {
            if (confirm('‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ? ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ô‡∏µ‡πâ‡∏≠‡∏≤‡∏à‡∏™‡πà‡∏á‡∏ú‡∏•‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏≠‡∏∑‡πà‡∏ô')) {
                currentLanguage.lexicon = currentLanguage.lexicon.filter(w => w.id !== wordId);
                currentLanguage.lexicon.forEach(word => { 
                    if (word.etymology && word.etymology.roots) {
                        word.etymology.roots = word.etymology.roots.filter(root => root.wordId !== wordId);
                    }
                });
                nextWordId = calculateNextWordId(currentLanguage.lexicon); 
                if (activeTab === 'dictionary') renderDictionaryUI(tabContentContainer);
                else if (activeTab === 'etymology') renderEtymologyUI(tabContentContainer); 
                saveData();
            }
        };

        function exportDictionaryAsJSON() {
            const jsonData = JSON.stringify(currentLanguage.lexicon, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `${currentLanguage.name}_dictionary.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function exportDictionaryAsCSV() {
            if (!currentLanguage.lexicon || currentLanguage.lexicon.length === 0) { alert("‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤"); return; }
            const headers = ['ID', 'Word(BasePhonemic)', 'Word(Orthographic)', 'CustomOrthography', 'Phonetics(Detailed)', 'Meaning', 'PartOfSpeech', 'Gender', 'Example', 'Synonyms', 'EtymologyRoots', 'EtymologyNotes'];
            const rows = currentLanguage.lexicon.map(entry => [
                entry.id, entry.word, getOrthographicForm(entry, false), entry.customOrthography || '', entry.phonetics, entry.meaning,
                entry.partOfSpeech, entry.gender || '', entry.example,
                entry.synonyms ? entry.synonyms.join(';') : '', 
                entry.etymology && entry.etymology.roots ? entry.etymology.roots.map(r => r.wordId ? `id:${r.wordId}` : `${r.customRoot}(${r.sourceLang})`).join(' | ') : '',
                entry.etymology ? entry.etymology.notes : ''
            ]);
            let csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n"
                           + rows.map(e => e.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(",")).join("\n"); 
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri); link.setAttribute("download", `${currentLanguage.name}_dictionary.csv`);
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        }

        function renderOrthographyUI(container) {
            const ortho = currentLanguage.orthography;
            ortho.customSymbols = ortho.customSymbols || [];
            ortho.displayTonesInOrthography = ortho.displayTonesInOrthography === undefined ? true : ortho.displayTonesInOrthography;


            const orthographyContainerId = 'orthographyTabSpecificContent';
            let orthographyContainer = container.querySelector(`#${orthographyContainerId}`);
            if(!orthographyContainer){
                orthographyContainer = document.createElement('div');
                orthographyContainer.id = orthographyContainerId;
                container.appendChild(orthographyContainer);
            }
            orthographyContainer.innerHTML = '';


            const section = document.createElement('div');
            section.className = 'space-y-4 p-3 border border-indigo-200 rounded-md bg-indigo-50';
            const soundDatalistId = 'phonemeSuggestionsDatalistOrtho';
            let soundOptionsHtml = [...new Set([...currentLanguage.phonology.consonants, ...currentLanguage.phonology.vowels])].map(p => `<option value="${p}"></option>`).join('');

            section.innerHTML = `<datalist id="${soundDatalistId}">${soundOptionsHtml}</datalist>`;
  createSelectInput(section, '‚úíÔ∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Writing System):', 'writingSystemSelectOrtho', ortho.writingSystem,
                [{value: 'latin', text: '‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏•‡∏∞‡∏ï‡∏¥‡∏ô (A-Z) (‡∏≠‡∏≤‡∏à‡πÉ‡∏ä‡πâ Grapheme Mappings ‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á)'}, {value: 'custom', text: '‡πÉ‡∏ä‡πâ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á (Custom Symbols)'}]
            ).onchange = (e) => {
                ortho.writingSystem = e.target.value;
                renderOrthographyUI(container); 
                saveData();
            };
            
            if (currentLanguage.phonology.hasTones) {
                 createCheckboxInput(section, '‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏π‡∏õ‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ (Display Tones in Orthography)', 'displayTonesCheckboxOrtho', ortho.displayTonesInOrthography, 
                 '‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå ‡πÅ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á', 
                 (e) => {
                    ortho.displayTonesInOrthography = e.target.checked;
                    saveData();
                 });
            }


            const customSymbolsSection = document.createElement('div');
            customSymbolsSection.id = 'customSymbolsSectionOrtho';
            customSymbolsSection.className = `${ortho.writingSystem === 'custom' ? '' : 'hidden'}`; 
            const helpTextForCustomSymbols = ortho.writingSystem === 'custom' 
                ? '‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏≠‡∏á' 
                : '‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡∏∞‡∏ï‡∏¥‡∏ô ‡πÇ‡∏î‡∏¢‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏à‡∏∞‡πÉ‡∏ä‡πâ Grapheme Mappings ‡∏à‡∏≤‡∏Å‡πÅ‡∏ó‡πá‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á ‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏•‡∏∞‡∏ï‡∏¥‡∏ô‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô';

            const customSymbolListContainer = document.createElement('div'); 
            customSymbolListContainer.id = 'customSymbolListOrtho';
            customSymbolListContainer.className = 'space-y-2 mb-2 max-h-60 overflow-y-auto p-2 bg-white rounded border';

            const addSymbolForm = `
                <label class="block text-sm font-medium text-indigo-700 mb-1">‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á (Custom Symbols):</label>
                <p class="text-xs text-gray-500 mb-1">${helpTextForCustomSymbols}</p>
                ${customSymbolListContainer.outerHTML} 
                <div class="flex gap-2 items-center flex-wrap p-2 border rounded bg-indigo-100">
                    <input type="text" id="customSymbolSoundOrtho" list="${soundDatalistId}" placeholder="‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏ä‡πà‡∏ô k, sh, a)" class="p-1 border rounded-md text-sm flex-grow sm:flex-grow-0">
                    <input type="text" id="customSymbolCharOrtho" placeholder="‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå (‡πÄ‡∏ä‡πà‡∏ô ‚ö∂, ‚ú∂)" class="p-1 border rounded-md text-sm flex-grow sm:flex-grow-0">
                    <button id="addCustomSymbolBtnOrtho" class="btn-secondary bg-indigo-400 hover:bg-indigo-500 px-2 py-1 rounded-md text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå</button>
                </div>`;
            customSymbolsSection.innerHTML = addSymbolForm;
            section.appendChild(customSymbolsSection);

            const renderCustomSymbolsListLocal = () => {
                const listEl = section.querySelector('#customSymbolListOrtho'); 
                if (!listEl) return;
                listEl.innerHTML = ''; 
                (ortho.customSymbols || []).forEach((sym, index) => {
                    listEl.innerHTML += `<div class="flex items-center justify-between p-1 bg-white rounded border border-indigo-100 text-sm">
                        <span>‡πÄ‡∏™‡∏µ‡∏¢‡∏á '${sym.sound}' <i class="fas fa-arrow-right mx-1"></i> ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå '${sym.symbol}'</span>
                        <button class="text-xs text-red-500 hover:text-red-700" onclick="removeCustomSymbol(${index})">&times; ‡∏•‡∏ö</button></div>`;
                });
                if (!ortho.customSymbols || ortho.customSymbols.length === 0) {
                    listEl.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á</p>';
                }
            };

            renderCustomSymbolsListLocal(); 
            const addBtn = section.querySelector('#addCustomSymbolBtnOrtho');
            if (addBtn) { 
                 addBtn.onclick = () => {
                    const soundInput = section.querySelector('#customSymbolSoundOrtho');
                    const symbolInput = section.querySelector('#customSymbolCharOrtho');
                    const sound = soundInput.value.trim();
                    const symbol = symbolInput.value.trim();
                    if (sound && symbol) {
                        if (ortho.customSymbols.some(s => s.sound === sound)) { 
                            alert(`‡πÄ‡∏™‡∏µ‡∏¢‡∏á '${sound}' ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô`);
                            return;
                        }
                        ortho.customSymbols.push({ sound, symbol });
                        soundInput.value = ''; symbolInput.value = '';
                        renderCustomSymbolsListLocal(); 
                        saveData();
                    }
                };
            }
            

            createSelectInput(section, '‚ÜîÔ∏è ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Writing Direction):', 'writingDirectionSelectOrtho', ortho.direction,
                [{value: 'ltr', text: '‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏Ç‡∏ß‡∏≤'}, {value: 'rtl', text: '‡∏Ç‡∏ß‡∏≤‡πÑ‡∏õ‡∏ã‡πâ‡∏≤‡∏¢'}, {value: 'ttb', text: '‡∏ö‡∏ô‡∏•‡∏á‡∏•‡πà‡∏≤‡∏á'}]
            ).onchange = (e) => { ortho.direction = e.target.value; saveData(); };

            const translitDemoSection = document.createElement('div');
            translitDemoSection.innerHTML = `
                <label class="block text-sm font-medium text-indigo-700">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏±‡∏Å‡∏©‡∏£:</label>
                <input type="text" id="orthoTestWord" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á)" class="w-full p-2 border border-indigo-300 rounded-md mb-1 font-mono">
                <button id="transliterateBtnOrtho" class="btn-primary bg-indigo-500 hover:bg-indigo-600 px-3 py-1 rounded-md text-sm">‡πÅ‡∏õ‡∏•‡∏á</button>
                <p id="transliteratedOutputOrtho" class="mt-2 p-2 bg-white rounded border border-indigo-200 text-lg min-h-[2.5em] font-mono"></p>`;
            section.appendChild(translitDemoSection);

            const transliterateBtn = section.querySelector('#transliterateBtnOrtho');
            if (transliterateBtn) { 
                 transliterateBtn.onclick = () => {
                    const word = section.querySelector('#orthoTestWord').value.trim(); 
                    const outputP = section.querySelector('#transliteratedOutputOrtho');
                    if (!word) { outputP.textContent = '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥'; return; }
                    outputP.textContent = transliterateWordToSymbols(word);
                    outputP.style.direction = (ortho.direction === 'rtl' ? 'rtl' : 'ltr');
                    outputP.style.writingMode = (ortho.direction === 'ttb' ? 'vertical-rl' : 'horizontal-tb');
                };
            }
            orthographyContainer.appendChild(section);
        }

        window.removeCustomSymbol = (index) => {
            currentLanguage.orthography.customSymbols.splice(index, 1);
            const listEl = document.getElementById('customSymbolListOrtho'); 
            if (listEl) { 
                listEl.innerHTML = ''; 
                (currentLanguage.orthography.customSymbols || []).forEach((sym, idx) => {
                    listEl.innerHTML += `<div class="flex items-center justify-between p-1 bg-white rounded border border-indigo-100 text-sm">
                        <span>‡πÄ‡∏™‡∏µ‡∏¢‡∏á '${sym.sound}' <i class="fas fa-arrow-right mx-1"></i> ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå '${sym.symbol}'</span>
                        <button class="text-xs text-red-500 hover:text-red-700" onclick="removeCustomSymbol(${idx})">&times; ‡∏•‡∏ö</button></div>`;
                });
                 if (currentLanguage.orthography.customSymbols.length === 0 && listEl) { 
                    listEl.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á</p>';
                }
            }
            saveData();
        };

        function renderEtymologyUI(container) {
            const etymologyContainerId = 'etymologyTabSpecificContent';
            let etymologyContainer = container.querySelector(`#${etymologyContainerId}`);
            if(!etymologyContainer){
                etymologyContainer = document.createElement('div');
                etymologyContainer.id = etymologyContainerId;
                container.appendChild(etymologyContainer);
            }
            etymologyContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-teal-200 rounded-md bg-teal-50 space-y-4';
            const etymologyDatalistId = `dictionaryWordsForEtymologyDatalist_${Date.now()}`;
            let datalistOptions = '';
            (currentLanguage.lexicon || []).forEach(w => { 
                datalistOptions += `<option value="${transliterateWordToSymbols(w.word)}" data-baseform="${w.word}">${w.meaning} [‡∏ê‡∏≤‡∏ô: ${w.word}]</option>`;
            });

            section.innerHTML = `
                <datalist id="${etymologyDatalistId}">${datalistOptions}</datalist>
                <div>
                    <label for="etymologyWordSearch" class="block text-sm font-medium text-teal-700">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏û‡∏¥‡∏°‡∏û‡πå‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô ‡∏´‡∏£‡∏∑‡∏≠ ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á):</label>
                    <div class="flex gap-2">
                        <input type="text" id="etymologyWordSearch" list="${etymologyDatalistId}" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥..." class="flex-grow p-2 border border-teal-300 rounded-md">
                        <button id="searchEtymologyBtn" class="btn-primary bg-teal-500 hover:bg-teal-600 px-3 py-1 rounded-md text-sm">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</button>
                    </div>
                </div>
                <div id="etymologyResults" class="p-3 bg-white rounded-md shadow min-h-[100px]">
                    <p class="text-center text-gray-400">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
                </div>
                <h4 class="font-semibold text-teal-700 pt-2 border-t border-teal-200">‡∏ú‡∏±‡∏á‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (Etymology Tree):</h4>
                <div id="wordEtymologyTreeChart" class="pedigree-chart p-2 bg-white rounded-md shadow min-h-[150px] max-h-[500px] overflow-auto">
                    <p class="text-center text-gray-400">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏ú‡∏±‡∏á</p>
                </div>
            `;
            etymologyContainer.appendChild(section);

            const wordSearchInput = section.querySelector('#etymologyWordSearch');
            const searchBtn = section.querySelector('#searchEtymologyBtn');

            const performSearch = () => {
                const searchTerm = wordSearchInput.value.trim();
                let wordEntry;
                const selectedOpt = Array.from(section.querySelector(`#${etymologyDatalistId}`).options).find(opt => opt.value === searchTerm);
                if (selectedOpt && selectedOpt.dataset.baseform) {
                     wordEntry = (currentLanguage.lexicon || []).find(w => w.word === selectedOpt.dataset.baseform);
                } else { 
                     wordEntry = (currentLanguage.lexicon || []).find(w => w.word === searchTerm || transliterateWordToSymbols(w.word) === searchTerm);
                }
                displayEtymologyForWord(wordEntry ? wordEntry.id : null, searchTerm);
            };

            searchBtn.addEventListener('click', performSearch);
            wordSearchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') performSearch(); });
        }

        function displayEtymologyForWord(wordId, originalSearchTerm) {
            const resultsContainer = document.getElementById('etymologyResults'); 
            const treeChartContainer = document.getElementById('wordEtymologyTreeChart');
            if(!resultsContainer || !treeChartContainer) return;

            resultsContainer.innerHTML = ''; treeChartContainer.innerHTML = '';

             const wordEntry = wordId ? (currentLanguage.lexicon || []).find(w => w.id === wordId) : null;

             if (!wordEntry) {
                resultsContainer.innerHTML = `<p class="text-red-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "${originalSearchTerm}" ‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°</p>`;
                return;
            }

            let resultHTML = `<h3 class="text-lg font-semibold text-teal-600">${transliterateWordToSymbols(wordEntry.word)} <span class="text-sm text-gray-500 font-mono">(${wordEntry.word})</span></h3>`;
            resultHTML += `<p class="text-sm text-gray-600"><strong>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢:</strong> ${wordEntry.meaning}</p>`;
            if (wordEntry.etymology && (wordEntry.etymology.roots && wordEntry.etymology.roots.length > 0 || wordEntry.etymology.notes)) {
                if (wordEntry.etymology.notes) resultHTML += `<p class="text-sm mt-1"><strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ${wordEntry.etymology.notes}</p>`;
                if (wordEntry.etymology.roots && wordEntry.etymology.roots.length > 0) {
                    resultHTML += `<h4 class="text-md font-medium mt-2 text-teal-500">‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á:</h4><ul class="list-disc list-inside ml-4 text-sm">`;
                    wordEntry.etymology.roots.forEach(root => {
                        if (root.wordId) {
                            const parentWord = (currentLanguage.lexicon || []).find(w => w.id === root.wordId);
                            resultHTML += `<li>‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤: <strong>${parentWord ? transliterateWordToSymbols(parentWord.word) : '‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏•‡∏ö'}</strong> <span class="font-mono text-xs text-gray-500">[${parentWord ? parentWord.word : 'N/A'}]</span></li>`;
                        } else if (root.customRoot) {
                            resultHTML += `<li>‡∏°‡∏≤‡∏à‡∏≤‡∏Å: <strong>${root.customRoot}</strong> (‡∏†‡∏≤‡∏©‡∏≤: ${root.sourceLang || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'})</li>`;
                        }
                    });
                    resultHTML += `</ul>`;
                }
            } else {
                resultHTML += `<p class="text-sm text-gray-500 mt-1">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ</p>`;
            }
            resultsContainer.innerHTML = resultHTML;
            treeChartContainer.appendChild(buildEtymologyTreeRecursive(wordEntry, new Set(), wordEntry.id, true)); 
        }

        function buildEtymologyTreeRecursive(wordEntry, visited = new Set(), searchedWordId = null, isRootOfSearch = false) {
            if (!wordEntry || visited.has(wordEntry.id)) {
                const emptyNode = document.createElement('ul');
                if (wordEntry && visited.has(wordEntry.id)) { 
                     const li = document.createElement('li');
                     li.innerHTML = `<span class="pedigree-node italic text-xs">‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏ã‡πâ‡∏≥: ${transliterateWordToSymbols(wordEntry.word)}</span>`;
                     emptyNode.appendChild(li);
                }
                return emptyNode;
            }
            visited.add(wordEntry.id);

            const ul = document.createElement('ul');
            const li = document.createElement('li');

            let nodeClass = 'pedigree-node';
            if (wordEntry.id === searchedWordId && isRootOfSearch) { 
                nodeClass += ' searched font-bold'; 
            }
            li.innerHTML = `<span class="${nodeClass}">${transliterateWordToSymbols(wordEntry.word)}</span> <span class="text-xs text-gray-500 font-mono">(${wordEntry.word})</span> <span class="text-xs text-gray-500">(${wordEntry.meaning})</span>`;

            if (wordEntry.etymology && wordEntry.etymology.roots && wordEntry.etymology.roots.length > 0) {
                const ancestorsUl = document.createElement('ul');
                wordEntry.etymology.roots.forEach(root => {
                    if (root.wordId) {
                        const parentWord = (currentLanguage.lexicon || []).find(w => w.id === root.wordId);
                        if (parentWord) {
                            ancestorsUl.appendChild(buildEtymologyTreeRecursive(parentWord, new Set(visited), searchedWordId, false)); 
                        }
                    } else if (root.customRoot) {
                        const customLi = document.createElement('li');
                        customLi.innerHTML = `<span class="pedigree-node text-sm"><i>${root.customRoot}</i> (${root.sourceLang || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'})</span>`;
                        ancestorsUl.appendChild(customLi);
                    }
                });
                 if (ancestorsUl.hasChildNodes()) li.appendChild(ancestorsUl);
            }

            const descendants = currentLanguage.lexicon.filter(w => w.etymology && w.etymology.roots && w.etymology.roots.some(r => r.wordId === wordEntry.id));
            if (descendants.length > 0 && isRootOfSearch) { 
                const descendantsUl = document.createElement('ul');
                descendants.forEach(descWord => {
                     if (!visited.has(descWord.id)) { 
                        descendantsUl.appendChild(buildEtymologyTreeRecursive(descWord, new Set(visited), searchedWordId, false));
                     }
                });
                if (descendantsUl.hasChildNodes()) {
                    const descendantsContainerLi = document.createElement('li'); 
                    descendantsContainerLi.innerHTML = `<span class="text-xs text-teal-600 block mt-1">‡∏Ñ‡∏≥‡∏™‡∏∑‡∏ö‡∏ó‡∏≠‡∏î (Descendants):</span>`;
                    descendantsContainerLi.appendChild(descendantsUl);
                    li.appendChild(descendantsContainerLi);
                }
            }
            ul.appendChild(li);
            return ul;
        }

        function renderEvolutionUI(container) {
            currentLanguage.eras = currentLanguage.eras || [...DEFAULT_LANGUAGE_STATE.eras];
            currentLanguage.eras.forEach(era => { 
                era.soundChangeRules = era.soundChangeRules || [];
            });

            const evolutionContainerId = 'evolutionTabSpecificContent';
            let evolutionContainer = container.querySelector(`#${evolutionContainerId}`);
            if(!evolutionContainer){
                evolutionContainer = document.createElement('div');
                evolutionContainer.id = evolutionContainerId;
                container.appendChild(evolutionContainer);
            }
            evolutionContainer.innerHTML = '';


            const section = document.createElement('div');
            section.className = 'p-3 border border-cyan-200 rounded-md bg-cyan-50 space-y-4';

            const erasSection = document.createElement('div');
            erasSection.innerHTML = `<h4 class="font-semibold text-cyan-700 mb-2">üï∞Ô∏è ‡∏¢‡∏∏‡∏Ñ‡∏ó‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (Historical Eras)</h4>`;
            const erasItemList = document.createElement('div');
            erasItemList.id = 'erasListContainerEvolution'; 
            (currentLanguage.eras.sort((a,b) => (a.order || 0) - (b.order || 0))).forEach((era) => {
                const eraItemDiv = document.createElement('div');
                eraItemDiv.className = 'p-3 mb-2 bg-white rounded border border-cyan-100 shadow-sm';
                eraItemDiv.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <span class="font-medium">${era.name} (Order: ${era.order || 0})</span>
                        <div>
                            <input type="number" value="${era.order || 0}" class="w-16 p-1 border rounded text-xs mr-2 era-order-input-evolution" data-eraid="${era.id}">
                            <button class="text-xs text-blue-500 hover:text-blue-700 mr-1" onclick="toggleEraSoundChanges('${era.id}')">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏é‡πÄ‡∏™‡∏µ‡∏¢‡∏á</button>
                            <button class="text-xs text-red-500 hover:text-red-700" onclick="removeEra('${era.id}')">‡∏•‡∏ö</button>
                        </div>
                    </div>
                    <div id="soundChangesForEra_${era.id}" class="hidden mt-2 p-2 border-t border-cyan-200 bg-cyan-50 rounded">
                        <h5 class="text-sm font-semibold text-cyan-600 mb-1">‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏¢‡∏∏‡∏Ñ ${era.name}):</h5>
                        <div id="rulesListEra_${era.id}" class="space-y-1 text-xs mb-2 max-h-40 overflow-y-auto">
                            ${(era.soundChangeRules || []).map((rule, ruleIdx) => `
                                <div class="flex justify-between items-center p-1 bg-white rounded border">
                                    <span>'${rule.from}' <i class="fas fa-arrow-right mx-1"></i> '${rule.to}' ${rule.context ? '('+rule.context+')' : ''} (${rule.description || 'N/A'})</span>
                                    <button class="text-red-400 hover:text-red-600" onclick="removeSoundChangeRuleFromEra('${era.id}', ${ruleIdx})">&times;</button>
                                </div>`).join('') || '<p class="text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é</p>'}
                        </div>
                        <div class="flex gap-1 items-end flex-wrap">
                            <input type="text" placeholder="‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á" class="p-1 border rounded text-xs era-sc-from-evolution" data-eraid="${era.id}" style="width:80px;">
                            <input type="text" placeholder="‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á" class="p-1 border rounded text-xs era-sc-to-evolution" data-eraid="${era.id}" style="width:80px;">
                            <input type="text" placeholder="‡∏ö‡∏£‡∏¥‡∏ö‡∏ó (‡πÄ‡∏ä‡πà‡∏ô V_V)" class="p-1 border rounded text-xs era-sc-context-evolution" data-eraid="${era.id}" style="width:100px;">
                            <input type="text" placeholder="‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏" class="p-1 border rounded text-xs era-sc-desc-evolution flex-grow" data-eraid="${era.id}">
                            <button class="btn-secondary bg-cyan-300 text-cyan-800 px-2 py-1 rounded text-xs" onclick="addSoundChangeRuleToEra('${era.id}')">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é</button>
                        </div>
                    </div>
                `;
                erasItemList.appendChild(eraItemDiv);
            });
            erasSection.appendChild(erasItemList);
            erasSection.innerHTML += `
                <div class="flex gap-2 mt-3 items-center p-2 border-t">
                    <input type="text" id="newEraNameEvolution" placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏¢‡∏∏‡∏Ñ‡πÉ‡∏´‡∏°‡πà" class="p-1 border rounded-md text-sm flex-grow">
                    <input type="number" id="newEraOrderEvolution" placeholder="‡∏•‡∏≥‡∏î‡∏±‡∏ö" value="${currentLanguage.eras.length}" class="p-1 border rounded-md text-sm w-20">
                    <button id="addEraBtnEvolution" class="btn-secondary bg-cyan-400 px-2 py-1 rounded-md text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏¢‡∏∏‡∏Ñ</button>
                </div>`;
            section.appendChild(erasSection);
            evolutionContainer.appendChild(section);

            document.getElementById('addEraBtnEvolution').onclick = () => {
                const name = document.getElementById('newEraNameEvolution').value.trim();
                const order = parseInt(document.getElementById('newEraOrderEvolution').value);
                if (name) {
                    currentLanguage.eras.push({ id: `era_${Date.now()}`, name, order: isNaN(order) ? currentLanguage.eras.length : order, soundChangeRules: [] });
                    renderEvolutionUI(container); saveData();
                }
            };
            evolutionContainer.querySelectorAll('.era-order-input-evolution').forEach(input => {
                input.onchange = (e) => {
                    const era = currentLanguage.eras.find(er => er.id === e.target.dataset.eraid);
                    if(era) era.order = parseInt(e.target.value);
                    renderEvolutionUI(container); saveData(); 
                };
            });
        }

        window.toggleEraSoundChanges = (eraId) => {
            const section = document.getElementById(`soundChangesForEra_${eraId}`);
            if (section) section.classList.toggle('hidden');
        };

        window.addSoundChangeRuleToEra = (eraId) => {
            const era = currentLanguage.eras.find(e => e.id === eraId);
            if (!era) return;
            const fromInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-from-evolution`);
            const toInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-to-evolution`);
            const contextInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-context-evolution`);
            const descInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-desc-evolution`);

            const from = fromInput.value.trim();
            const to = toInput.value.trim();
            const context = contextInput.value.trim();
            const description = descInput.value.trim();

            if (from) {  
                era.soundChangeRules.push({ from, to, context, description });
                fromInput.value = ''; toInput.value = ''; contextInput.value = ''; descInput.value = ''; 
                renderEvolutionUI(tabContentContainer); 
                saveData();
                setTimeout(() => {
                    const eraSection = document.getElementById(`soundChangesForEra_${eraId}`);
                    if (eraSection && eraSection.classList.contains('hidden')) { 
                        eraSection.classList.remove('hidden');
                    }
                },0);
            }
        };

        window.removeSoundChangeRuleFromEra = (eraId, ruleIndex) => {
            const era = currentLanguage.eras.find(e => e.id === eraId);
            if (era && era.soundChangeRules && era.soundChangeRules[ruleIndex]) {
                era.soundChangeRules.splice(ruleIndex, 1);
                renderEvolutionUI(tabContentContainer); saveData();
                 setTimeout(() => { 
                    const eraSection = document.getElementById(`soundChangesForEra_${eraId}`);
                    if (eraSection && eraSection.classList.contains('hidden')) { 
                        eraSection.classList.remove('hidden');
                    }
                },0);
            }
        };

        window.removeEra = (eraId) => {
            currentLanguage.eras = currentLanguage.eras.filter(e => e.id !== eraId);
            currentLanguage.lexicon.forEach(word => {
                if (word.evolutionTimeline) {
                    word.evolutionTimeline = word.evolutionTimeline.filter(ev => ev.eraId !== eraId);
                }
            });
            renderEvolutionUI(tabContentContainer); saveData();
        };

        function applyInterEraSoundChanges(text, rules) { 
            let newText = text;
            if (rules && rules.length > 0) {
                rules.forEach(rule => {
                    try {
                         const regex = convertContextualRuleToRegex(rule.from, rule.to, rule.context);
                         newText = newText.replace(regex, rule.to); 
                    } catch (e) {
                        console.warn("Invalid regex in sound change rule:", rule, e);
                    }
                });
            }
            return newText;
        }
        
        function convertContextualRuleToRegex(from, to, contextStr) {
            const V = '[aeiouAEIOU√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√ø…ô√¶…î]'; 
            const C = '[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ≈ã É íŒ∏√∞ î à…ñ…≥ Ç ê√ß ù…∏Œ≤…±‚±±…æ…Ω…≤≈ã…¥ Äƒß ï…¨…Æ…∞]'; 
            
            let escFrom = from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            let pre = '', post = '';

            if (contextStr) {
                const parts = contextStr.split('_');
                if (parts.length === 2) {
                    if (parts[0] === '#') pre = '^';
                    else if (parts[0] === 'V') pre = `(?<=${V})`;
                    else if (parts[0] === 'C') pre = `(?<=${C})`;
                    else if (parts[0]) pre = `(?<=${parts[0].replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;

                    if (parts[1] === '#') post = '$';
                    else if (parts[1] === 'V') post = `(?=${V})`;
                    else if (parts[1] === 'C') post = `(?=${C})`;
                    else if (parts[1]) post = `(?=${parts[1].replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;
                }
            }
            return new RegExp(pre + escFrom + post, 'g');
        }


        window.openEvolutionModalForWord = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;
            word.evolutionTimeline = word.evolutionTimeline || []; 

            genericModalTitle.textContent = `‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥: ${transliterateWordToSymbols(word.word)} [${word.word}]`;
            let content = `<p class="text-sm mb-2">‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≤‡∏ô‡∏¢‡∏∏‡∏Ñ‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á): <strong class="font-mono">${word.word}</strong>, ‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ê‡∏≤‡∏ô (‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î): <strong class="font-mono">${word.phonetics || 'N/A'}</strong></p>`;

            const sortedEras = [...currentLanguage.eras].sort((a,b) => (a.order || 0) - (b.order || 0));

            sortedEras.forEach((era, eraIndex) => {
                const existingEvo = word.evolutionTimeline.find(e => e.eraId === era.id);
                let initialPhonetic = existingEvo?.phoneticForm || '';
                let initialOrthographic = existingEvo?.orthographicForm || '';

                if (eraIndex === 0 && !existingEvo) { 
                    initialPhonetic = word.word; 
                    initialOrthographic = transliterateWordToSymbols(initialPhonetic); 
                }

                content += `
                <div class="p-3 border rounded bg-gray-50 mb-2 evo-era-entry" data-eraid="${era.id}">
                    <div class="flex justify-between items-center">
                        <h5 class="font-semibold text-purple-600">${era.name}</h5>
                        ${eraIndex > 0 ? `<button class="text-xs btn-secondary bg-cyan-500 hover:bg-cyan-600 px-2 py-1 rounded" onclick="autoGenerateForEra('${word.id}', '${era.id}', '${sortedEras[eraIndex-1].id}')">‡∏®‡∏±‡∏û‡∏ó‡πå‡∏à‡∏≤‡∏Å‡∏¢‡∏∏‡∏Ñ '${sortedEras[eraIndex-1].name}'</button>` : ''}
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-1">
                        <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phonetic):</label><input type="text" class="w-full p-1 border rounded text-sm evo-phonetic font-mono" value="${initialPhonetic}"></div>
                        <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Orthographic):</label><input type="text" class="w-full p-1 border rounded text-sm evo-orthographic font-mono" value="${initialOrthographic}"></div>
                    </div>
                    <div><label class="text-xs mt-1">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</label><textarea class="w-full p-1 border rounded text-sm evo-notes" rows="1">${existingEvo?.notes || ''}</textarea></div>
                </div>`;
            });
            genericModalContent.innerHTML = content;

            genericModalFooter.innerHTML = `<button id="saveEvolutionChangesBtnModal" class="btn-primary">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á</button>`;
            document.getElementById('saveEvolutionChangesBtnModal').onclick = () => {
                const newEvolutionTimeline = [];
                genericModalContent.querySelectorAll('.evo-era-entry').forEach(entryDiv => {
                    const eraId = entryDiv.dataset.eraid;
                    const phoneticInput = entryDiv.querySelector(`.evo-phonetic`);
                    const orthographicInput = entryDiv.querySelector(`.evo-orthographic`);
                    const notesInput = entryDiv.querySelector(`.evo-notes`);
                    if (phoneticInput.value.trim() || orthographicInput.value.trim() || notesInput.value.trim()) {
                         newEvolutionTimeline.push({
                            eraId: eraId,
                            phoneticForm: phoneticInput.value.trim(),
                            orthographicForm: orthographicInput.value.trim(),
                            notes: notesInput.value.trim()
                        });
                    }
                });
                word.evolutionTimeline = newEvolutionTimeline;
                saveData();
                genericModal.classList.add('hidden');
                if (activeTab === 'dictionary') showWordDetailPopup(wordId); 
                else if (activeTab === 'evolution') renderEvolutionUI(tabContentContainer); 
            };
            wordDetailModal.classList.add('hidden'); 
            genericModal.classList.remove('hidden');
        };

        window.autoGenerateForEra = (wordId, currentEraId, previousEraId) => {
            const word = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
            const currentEra = currentLanguage.eras.find(e => e.id === currentEraId);
            if (!word || !currentEra) return;

            let previousPhoneticForm = '';
            const previousEraEntryDivModal = genericModalContent.querySelector(`.evo-era-entry[data-eraid="${previousEraId}"] .evo-phonetic`);
            if (previousEraEntryDivModal && previousEraEntryDivModal.value.trim()) {
                 previousPhoneticForm = previousEraEntryDivModal.value.trim();
            } else { 
                const previousEvoEntry = word.evolutionTimeline.find(e => e.eraId === previousEraId); 
                if (previousEvoEntry && previousEvoEntry.phoneticForm) {
                    previousPhoneticForm = previousEvoEntry.phoneticForm;
                } else { 
                    const sortedEras = [...currentLanguage.eras].sort((a,b) => (a.order || 0) - (b.order || 0));
                    if (sortedEras.length > 0 && sortedEras[0].id === previousEraId) {
                        previousPhoneticForm = word.word; 
                    }
                }
            }
            
            if (!previousPhoneticForm) {
                alert(`‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏∏‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ (${currentLanguage.eras.find(e=>e.id === previousEraId)?.name || previousEraId}). ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏∏‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏•‡∏±‡∏Å`);
                return;
            }

            const rules = currentEra.soundChangeRules || [];
            const newPhoneticForm = applyInterEraSoundChanges(previousPhoneticForm, rules);

            const currentEraEntryDivModal = genericModalContent.querySelector(`.evo-era-entry[data-eraid="${currentEraId}"]`);
            if (currentEraEntryDivModal) {
                currentEraEntryDivModal.querySelector('.evo-phonetic').value = newPhoneticForm;
                currentEraEntryDivModal.querySelector('.evo-orthographic').value = transliterateWordToSymbols(newPhoneticForm); 
            }
        };

        function applyDialectSoundChanges(text, rules) { 
            return applyInterEraSoundChanges(text, rules); // Reusing the same logic for now
        }

        function renderDialectsUI(container) {
            currentLanguage.regions = currentLanguage.regions || [...DEFAULT_LANGUAGE_STATE.regions];
            currentLanguage.dialectSoundChanges = currentLanguage.dialectSoundChanges || {};
             currentLanguage.regions.forEach(region => {
                if (!currentLanguage.dialectSoundChanges[region]) {
                    currentLanguage.dialectSoundChanges[region] = [];
                }
            });

            const dialectsContainerId = 'dialectsTabSpecificContent';
            let dialectsContainer = container.querySelector(`#${dialectsContainerId}`);
            if(!dialectsContainer){
                dialectsContainer = document.createElement('div');
                dialectsContainer.id = dialectsContainerId;
                container.appendChild(dialectsContainer);
            }
            dialectsContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-lime-200 rounded-md bg-lime-50 space-y-4';

            createListInput(section, 'üåç ‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô (Dialect Regions)', currentLanguage.regions, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ (‡πÄ‡∏ä‡πà‡∏ô Northern, Capital City)",
                (item) => { 
                    if (!currentLanguage.regions.includes(item)) {
                        currentLanguage.regions.push(item); 
                        if (!currentLanguage.dialectSoundChanges[item]) {
                           currentLanguage.dialectSoundChanges[item] = []; 
                        }
                        renderDialectsUI(container); 
                        saveData(); 
                    } else {
                        alert("‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");
                    }
                },
                (index) => {
                    const regionNameToRemove = currentLanguage.regions[index];
                    currentLanguage.regions.splice(index, 1);
                    delete currentLanguage.dialectSoundChanges[regionNameToRemove]; 
                    currentLanguage.lexicon.forEach(word => {
                        if (word.dialectalForms) {
                            word.dialectalForms = word.dialectalForms.filter(df => df.regionName !== regionNameToRemove);
                        }
                    });
                    renderDialectsUI(container); 
                    saveData(); 
                }
            );

            const rulesSection = document.createElement('div');
            rulesSection.innerHTML = `<h4 class="font-semibold text-lime-700 mt-4 mb-2">‚öôÔ∏è ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô:</h4>`;
            if (currentLanguage.regions.length > 0) {
                currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(region => { 
                    const safeRegionIdPart = region.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const regionRulesDiv = document.createElement('div');
                    regionRulesDiv.className = 'p-3 mb-2 bg-white rounded border border-lime-100 shadow-sm';
                    regionRulesDiv.innerHTML = `
                        <div class="flex items-center justify-between mb-2">
                            <h5 class="font-medium text-lime-600">${region}</h5>
                            <button class="text-xs text-blue-500 hover:text-blue-700" onclick="toggleRegionRulesDisplay('rulesForRegion_${safeRegionIdPart}')">‡πÅ‡∏™‡∏î‡∏á/‡∏ã‡πà‡∏≠‡∏ô‡∏Å‡∏é</button>
                        </div>
                        <div id="rulesForRegion_${safeRegionIdPart}" class="hidden mt-2 p-2 border-t border-lime-200 bg-lime-50 rounded">
                            <div id="rulesListForRegion_${safeRegionIdPart}" class="space-y-1 text-xs mb-2 max-h-40 overflow-y-auto"></div>
                            <div class="flex gap-1 items-end flex-wrap">
                                <input type="text" placeholder="‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå" class="p-1 border rounded text-xs region-sc-from" data-region="${region}" style="width:100px;">
                                <input type="text" placeholder="‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå" class="p-1 border rounded text-xs region-sc-to" data-region="${region}" style="width:100px;">
                                <input type="text" placeholder="‡∏ö‡∏£‡∏¥‡∏ö‡∏ó (‡πÄ‡∏ä‡πà‡∏ô V_V)" class="p-1 border rounded text-xs region-sc-context flex-grow" data-region="${region}" style="min-width:100px;">
                                <input type="text" placeholder="‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏" class="p-1 border rounded text-xs region-sc-desc flex-grow" data-region="${region}" style="min-width:100px;">
                                <button class="btn-secondary bg-lime-300 text-lime-800 px-2 py-1 rounded text-xs" onclick="addSoundChangeRuleToRegion('${region}')">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é</button>
                            </div>
                        </div>
                    `;
                    rulesSection.appendChild(regionRulesDiv);
                    renderRegionSoundRulesList(region, `rulesListForRegion_${safeRegionIdPart}`);
                });
                 if(currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').length === 0){
                     rulesSection.innerHTML += `<p class="text-sm text-gray-500">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏≠‡∏∑‡πà‡∏ô‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å 'Standard' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é</p>`;
                 }
            } else {
                rulesSection.innerHTML += `<p class="text-sm text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∂‡∏á‡∏à‡∏∞‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÑ‡∏î‡πâ</p>`;
            }
            section.appendChild(rulesSection);

            const comparisonSection = document.createElement('div');
            comparisonSection.className = 'mt-4 pt-3 border-t border-lime-200';
            const wordSearchId = `dialectWordSearch_${Date.now()}`;
            const wordSearchDatalistId = `dialectWordDatalist_${Date.now()}`;
            let datalistOptions = '';
            (currentLanguage.lexicon || []).forEach(w => { 
                datalistOptions += `<option value="${transliterateWordToSymbols(w.word)}" data-wordid="${w.id}" data-baseform="${w.word}">${w.meaning} [‡∏ê‡∏≤‡∏ô: ${w.word}]</option>`;
            });

            comparisonSection.innerHTML = `
                <h4 class="font-semibold text-lime-700 mb-2">üìä ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô:</h4>
                <datalist id="${wordSearchDatalistId}">${datalistOptions}</datalist>
                <div class="flex gap-2 items-center mb-2">
                    <input type="text" id="${wordSearchId}" list="${wordSearchDatalistId}" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏à‡∏≤‡∏Å‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°..." class="flex-grow p-2 border border-lime-300 rounded-md">
                    <button id="searchDialectComparisonBtn" class="btn-primary bg-lime-500 hover:bg-lime-600 px-3 py-1 rounded-md text-sm">‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö</button>
                </div>
                <div id="dialectComparisonTableContainer" class="overflow-x-auto bg-white p-2 rounded shadow min-h-[100px]">
                    <p class="text-center text-gray-400">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö</p>
                </div>
            `;
            section.appendChild(comparisonSection);
            const searchBtn = comparisonSection.querySelector('#searchDialectComparisonBtn');
            if (searchBtn) {
                searchBtn.addEventListener('click', () => {
                    const searchInput = document.getElementById(wordSearchId);
                    const searchTerm = searchInput.value.trim();
                    let wordEntry;
                    const selectedOpt = Array.from(document.getElementById(wordSearchDatalistId).options).find(opt => opt.value === searchTerm && opt.dataset.wordid);

                    if (selectedOpt) {
                        wordEntry = (currentLanguage.lexicon || []).find(w => w.id === parseInt(selectedOpt.dataset.wordid));
                    } else { 
                        const baseFormFromDatalist = Array.from(document.getElementById(wordSearchDatalistId).options).find(opt => opt.value === searchTerm)?.dataset.baseform;
                        if (baseFormFromDatalist) {
                             wordEntry = (currentLanguage.lexicon || []).find(w => w.word === baseFormFromDatalist);
                        } else { 
                            wordEntry = (currentLanguage.lexicon || []).find(w => w.word === searchTerm || transliterateWordToSymbols(w.word) === searchTerm || w.meaning.toLowerCase().includes(searchTerm.toLowerCase()));
                        }
                    }

                    if (wordEntry) {
                        displayDialectComparisonTable(wordEntry);
                    } else {
                        document.getElementById('dialectComparisonTableContainer').innerHTML = '<p class="text-red-500 text-center">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå</p>';
                    }
                });
            }

            const dialectWordList = document.createElement('div');
            dialectWordList.innerHTML = `<h4 class="font-semibold text-lime-700 mt-4 pt-3 border-t border-lime-200 mb-2">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡πÅ‡∏•‡πâ‡∏ß:</h4>`;
            const ul = document.createElement('ul');
            ul.className = 'list-disc list-inside max-h-60 overflow-y-auto bg-white p-2 rounded shadow text-sm';
            let count = 0;
            currentLanguage.lexicon.forEach(word => {
                if (word.dialectalForms && word.dialectalForms.length > 0) {
                    count++;
                    const li = document.createElement('li');
                    li.className = 'p-1 hover:bg-lime-100 cursor-pointer';
                    li.innerHTML = `${transliterateWordToSymbols(word.word)} <span class="text-xs text-gray-500">(${word.meaning})</span> - <button class="text-xs text-blue-500" onclick="openDialectModalForWord(${word.id})">‡∏î‡∏π/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç (${word.dialectalForms.length} ‡∏ñ‡∏¥‡πà‡∏ô)</button>`;
                    ul.appendChild(li);
                }
            });
            if(count === 0) ul.innerHTML = `<li class="text-sm text-gray-500 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô</li>`;
            dialectWordList.appendChild(ul);
            section.appendChild(dialectWordList);

            dialectsContainer.appendChild(section);
        }

        window.toggleRegionRulesDisplay = (divId) => {
            const element = document.getElementById(divId);
            if (element) {
                element.classList.toggle('hidden');
            }
        };

        function renderRegionSoundRulesList(regionName, listContainerId) {
            const rulesListContainer = document.getElementById(listContainerId);
            if (!rulesListContainer) return; 
            
            rulesListContainer.innerHTML = ''; 
            const rules = currentLanguage.dialectSoundChanges[regionName] || [];

            if (rules.length === 0) {
                rulesListContainer.innerHTML = '<p class="text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏ô‡∏µ‡πâ</p>';
                return;
            }

            rules.forEach((rule, index) => {
                const ruleDiv = document.createElement('div');
                ruleDiv.className = 'flex justify-between items-center p-1 bg-white rounded border border-lime-50';
                ruleDiv.innerHTML = `
                    <span>'${rule.from}' <i class="fas fa-arrow-right mx-1"></i> '${rule.to}' ${rule.context ? '('+rule.context+')' : ''} ${rule.description ? `(${rule.description})` : ''}</span>
                    <button class="text-red-400 hover:text-red-600 text-xs" onclick="removeSoundChangeRuleFromRegion('${regionName}', ${index})">&times; ‡∏•‡∏ö</button>
                `;
                rulesListContainer.appendChild(ruleDiv);
            });
        }
        
        window.addSoundChangeRuleToRegion = (regionName) => {
            const fromInput = document.querySelector(`.region-sc-from[data-region="${regionName}"]`);
            const toInput = document.querySelector(`.region-sc-to[data-region="${regionName}"]`);
            const contextInput = document.querySelector(`.region-sc-context[data-region="${regionName}"]`);
            const descInput = document.querySelector(`.region-sc-desc[data-region="${regionName}"]`);

            if (!fromInput || !toInput || !descInput || !contextInput) {
                console.error("Could not find input fields for region:", regionName);
                return;
            }

            const from = fromInput.value.trim();
            const to = toInput.value.trim(); 
            const context = contextInput.value.trim();
            const description = descInput.value.trim();

            if (from) { 
                if (!currentLanguage.dialectSoundChanges[regionName]) {
                    currentLanguage.dialectSoundChanges[regionName] = [];
                }
                currentLanguage.dialectSoundChanges[regionName].push({ from, to, context, description });
                
                fromInput.value = '';
                toInput.value = '';
                contextInput.value = '';
                descInput.value = '';
                
                const safeRegionIdPart = regionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                renderRegionSoundRulesList(regionName, `rulesListForRegion_${safeRegionIdPart}`);
                saveData();
                setTimeout(() => {
                    const regionSection = document.getElementById(`rulesForRegion_${safeRegionIdPart}`);
                    if (regionSection && regionSection.classList.contains('hidden')) { 
                        regionSection.classList.remove('hidden');
                    }
                },0);
            } else {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å '‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á' ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢");
            }
        };

        window.removeSoundChangeRuleFromRegion = (regionName, ruleIndex) => {
            if (currentLanguage.dialectSoundChanges[regionName] && currentLanguage.dialectSoundChanges[regionName][ruleIndex]) {
                currentLanguage.dialectSoundChanges[regionName].splice(ruleIndex, 1);
                const safeRegionIdPart = regionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                renderRegionSoundRulesList(regionName, `rulesListForRegion_${safeRegionIdPart}`);
                saveData();
                setTimeout(() => { 
                    const regionSection = document.getElementById(`rulesForRegion_${safeRegionIdPart}`);
                    if (regionSection && regionSection.classList.contains('hidden')) { 
                        regionSection.classList.remove('hidden');
                    }
                },0);
            }
        };

        function displayDialectComparisonTable(wordEntry) {
            const container = document.getElementById('dialectComparisonTableContainer');
            if (!container || !wordEntry) return;

            container.innerHTML = ''; 

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-lime-300 bg-white shadow-sm rounded-lg text-sm';
            
            let headerHtml = `<tr>
                <th class="px-3 py-2 text-left text-xs font-medium text-lime-700 uppercase">‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞</th>
                <th class="px-3 py-2 text-left text-xs font-medium text-lime-700 uppercase">‡∏†‡∏≤‡∏©‡∏≤‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô<br>(${transliterateWordToSymbols(wordEntry.word)})</th>`;
            currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(region => {
                headerHtml += `<th class="px-3 py-2 text-left text-xs font-medium text-lime-700 uppercase">${region}</th>`;
            });
            headerHtml += `</tr>`;
            table.innerHTML = `<thead class="bg-lime-100">${headerHtml}</thead><tbody></tbody>`;
            const tbody = table.querySelector('tbody');

            let orthoRow = `<tr><td class="px-3 py-2 font-medium">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô</td><td class="px-3 py-2 font-mono">${transliterateWordToSymbols(wordEntry.word)}</td>`;
            let phoneticRow = `<tr><td class="px-3 py-2 font-medium">‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á</td><td class="px-3 py-2 font-mono">${wordEntry.word}</td>`; // word.word is base phonemic

            currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(region => {
                const manualForm = (wordEntry.dialectalForms || []).find(df => df.regionName === region);
                let dialectOrthographic = '<span class="text-gray-400">-</span>';
                let dialectPhonetic = '<span class="text-gray-400">-</span>';
                let source = '<span class="text-xs text-gray-400">(‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏)</span>';
                const basePhoneticForDialect = wordEntry.word; // Use base phonemic form for rule application

                if (manualForm && (manualForm.orthographic || manualForm.phonetic)) {
                    dialectPhonetic = manualForm.phonetic || manualForm.orthographic; // Prefer phonetic if available
                    dialectOrthographic = manualForm.orthographic ? transliterateWordToSymbols(manualForm.orthographic) : transliterateWordToSymbols(dialectPhonetic);
                    source = '<span class="text-xs text-blue-500">(‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á)</span>';
                } else {
                    const rules = currentLanguage.dialectSoundChanges[region] || [];
                    if (rules.length > 0 && basePhoneticForDialect) {
                        const generatedPhonetic = applyDialectSoundChanges(basePhoneticForDialect, rules);
                        dialectPhonetic = generatedPhonetic;
                        dialectOrthographic = transliterateWordToSymbols(generatedPhonetic);
                        source = `<span class="text-xs text-green-500">(‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏é)</span>`;
                    }
                }
                orthoRow += `<td class="px-3 py-2 font-mono">${dialectOrthographic} ${source}</td>`;
                phoneticRow += `<td class="px-3 py-2 font-mono">${dialectPhonetic}</td>`;
            });
            orthoRow += `</tr>`;
            phoneticRow += `</tr>`;

            tbody.innerHTML = orthoRow + phoneticRow;
            container.appendChild(table);
            container.innerHTML += `<div class="text-right mt-2"><button class="text-xs btn-secondary" onclick="openDialectModalForWord(${wordEntry.id})">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î</button></div>`;
        }

        window.openDialectModalForWord = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;
            word.dialectalForms = word.dialectalForms || []; 

            genericModalTitle.textContent = `‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥: ${transliterateWordToSymbols(word.word)}`;
            let content = `<p class="text-sm mb-2">‡πÄ‡∏û‡∏¥‡πà‡∏°/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô: <strong>${word.meaning}</strong> (‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô: <strong class="font-mono">${word.word}</strong>)</p>`;

            content += `<div id="dialectFormsContainerModal" class="space-y-3">`; 
            word.dialectalForms.forEach((df, index) => {
                content += renderDialectFormEntry(df, index, wordId); 
            });
            content += `</div>`;
            content += `<button id="addNewDialectFormBtnModal" class="mt-3 text-sm btn-secondary bg-lime-400"><i class="fas fa-plus mr-1"></i>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà</button>`;

            genericModalContent.innerHTML = content;

            document.getElementById('addNewDialectFormBtnModal').onclick = () => {
                if (currentLanguage.regions.length > 0) {
                    let defaultNewRegion = currentLanguage.regions.find(r => r.toLowerCase() !== 'standard' && !word.dialectalForms.some(df => df.regionName === r));
                    if (!defaultNewRegion) defaultNewRegion = currentLanguage.regions.find(r => r.toLowerCase() !== 'standard') || currentLanguage.regions.find(r => r !== 'Standard') || currentLanguage.regions[0];
                    
                    if (!defaultNewRegion || defaultNewRegion.toLowerCase() === 'standard' && currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').length === 0) {
                        alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà 'Standard' ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÅ‡∏´‡πà‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà Standard");
                        return;
                    }

                     word.dialectalForms.push({
                        regionName: defaultNewRegion, 
                        phonetic: '', orthographic: '', meaning_diff: ''
                    });
                    const formsContainer = document.getElementById('dialectFormsContainerModal');
                    formsContainer.innerHTML = ''; 
                     word.dialectalForms.forEach((df, index) => {
                        formsContainer.innerHTML += renderDialectFormEntry(df, index, wordId); 
                    });
                    attachDialectFormListeners(wordId); 
                } else {
                    alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö '‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô' ‡∏Å‡πà‡∏≠‡∏ô");
                }
            };

            genericModalFooter.innerHTML = `<button id="saveDialectChangesBtnModal" class="btn-primary">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á</button>`;
            document.getElementById('saveDialectChangesBtnModal').onclick = () => {
                const updatedDialectForms = [];
                const formElements = genericModalContent.querySelectorAll('.dialect-form-entry');
                formElements.forEach(formEl => {
                    const region = formEl.querySelector('.dialect-region').value;
                    const phonetic = formEl.querySelector('.dialect-phonetic').value.trim();
                    const orthographic = formEl.querySelector('.dialect-orthographic').value.trim();
                    const meaningDiff = formEl.querySelector('.dialect-meaning').value.trim();
                    if (region && (phonetic || orthographic || meaningDiff)) { 
                        updatedDialectForms.push({ regionName: region, phonetic, orthographic, meaning_diff: meaningDiff });
                    }
                });
                word.dialectalForms = updatedDialectForms;
                saveData();
                genericModal.classList.add('hidden');
                 if (activeTab === 'dictionary') {
                     wordDetailModal.classList.add('hidden'); 
                     showWordDetailPopup(wordId); 
                 } else if (activeTab === 'dialects') {
                     renderDialectsUI(tabContentContainer);
                      const activeSearchInput = document.querySelector('#dialectsTabSpecificContent input[type="text"][id^="dialectWordSearch_"]');
                      if(activeSearchInput && activeSearchInput.value){
                        const searchTerm = activeSearchInput.value.trim();
                        let activeWordEntry;
                        const selectedOpt = Array.from(document.querySelector(`datalist[id^="dialectWordDatalist_"]`).options).find(opt => opt.value === searchTerm && opt.dataset.wordid);
                        if (selectedOpt) activeWordEntry = currentLanguage.lexicon.find(w => w.id === parseInt(selectedOpt.dataset.wordid));
                        else activeWordEntry = currentLanguage.lexicon.find(w => transliterateWordToSymbols(w.word) === searchTerm || w.word === searchTerm);
                        if(activeWordEntry) displayDialectComparisonTable(activeWordEntry);
                      }
                 }
            };
            attachDialectFormListeners(wordId); 
            wordDetailModal.classList.add('hidden'); 
            genericModal.classList.remove('hidden');
        };

        function renderDialectFormEntry(dialectForm, index, wordId) { 
            let regionOptions = '';
            const word = currentLanguage.lexicon.find(w => w.id === wordId); 
            const standardPhonetics = word ? (word.word) : ''; // word.word is base phonemic

            currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(r => { // Only offer non-standard regions here
                regionOptions += `<option value="${r}" ${dialectForm.regionName === r ? 'selected' : ''}>${r}</option>`;
            });
            if (currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').length === 0) {
                regionOptions = '<option value="">-- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô) --</option>';
            }
            return `
            <div class="p-3 border rounded bg-gray-50 dialect-form-entry" data-index="${index}">
                <div class="flex justify-between items-center mb-1 flex-wrap">
                    <select class="p-1 border rounded text-sm dialect-region flex-grow mb-1 sm:mb-0 mr-0 sm:mr-2">${regionOptions}</select>
                    <div class="flex gap-2">
                        <button class="text-xs btn-secondary bg-cyan-400 hover:bg-cyan-500 text-white px-1.5 py-0.5 rounded" onclick="generateDialectFormForRegionInModal(${wordId}, ${index})">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏é</button>
                        <button class="text-xs text-red-500 hover:text-red-700 remove-dialect-form-btn" data-index="${index}"><i class="fas fa-trash"></i> ‡∏•‡∏ö</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-1">
                    <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phonetic):</label><input type="text" class="w-full p-1 border rounded text-sm dialect-phonetic font-mono" value="${dialectForm.phonetic || ''}"></div>
                    <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Orthographic):</label><input type="text" class="w-full p-1 border rounded text-sm dialect-orthographic font-mono" value="${dialectForm.orthographic || ''}"></div>
                </div>
                <div><label class="text-xs mt-1">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢ (‡∏ñ‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô):</label><input type="text" class="w-full p-1 border rounded text-sm dialect-meaning" value="${dialectForm.meaning_diff || ''}"></div>
            </div>`;
        }

        window.generateDialectFormForRegionInModal = (wordId, formEntryIndex) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;

            const formEntryDiv = genericModalContent.querySelectorAll('.dialect-form-entry')[formEntryIndex];
            if (!formEntryDiv) return;

            const regionName = formEntryDiv.querySelector('.dialect-region').value;
            if (!regionName) { alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ"); return; }

            const rules = currentLanguage.dialectSoundChanges[regionName] || [];
            const basePhonetic = word.word; 

            if (!basePhonetic) {
                alert("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ");
                return;
            }

            const generatedPhonetic = applyDialectSoundChanges(basePhonetic, rules);
            const generatedOrthographic = transliterateWordToSymbols(generatedPhonetic);

            formEntryDiv.querySelector('.dialect-phonetic').value = generatedPhonetic;
            formEntryDiv.querySelector('.dialect-orthographic').value = generatedOrthographic;
        };

        function attachDialectFormListeners(wordId) {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            document.querySelectorAll('.remove-dialect-form-btn').forEach(btn => {
                const newBtn = btn.cloneNode(true); 
                btn.parentNode.replaceChild(newBtn, btn);

                newBtn.onclick = (e) => {
                    e.stopPropagation(); 
                    const indexToRemove = parseInt(e.currentTarget.dataset.index);
                    if (word && word.dialectalForms && word.dialectalForms[indexToRemove] !== undefined) {
                        word.dialectalForms.splice(indexToRemove, 1);
                        
                        const formsContainer = document.getElementById('dialectFormsContainerModal'); 
                        if (formsContainer) {
                            formsContainer.innerHTML = '';
                            word.dialectalForms.forEach((df, idx) => { 
                                formsContainer.innerHTML += renderDialectFormEntry(df, idx, wordId);
                            });
                            attachDialectFormListeners(wordId); 
                        }
                    }
                };
            });

            genericModalContent.querySelectorAll('.dialect-form-entry').forEach((entryDiv, index) => {
                const regionSelect = entryDiv.querySelector('.dialect-region');
                if(regionSelect && word && word.dialectalForms[index]) {
                    regionSelect.onchange = (e) => {
                         if(word.dialectalForms[index]) word.dialectalForms[index].regionName = e.target.value;
                    };
                }
            });
        }

        function renderLangFamilyUI(container) {
            currentLanguage.languageFamily = currentLanguage.languageFamily || { externalNodes: [] };
            currentLanguage.languageFamily.externalNodes = currentLanguage.languageFamily.externalNodes || [];

            const langFamilyContainerId = 'langFamilyTabSpecificContent';
            let langFamilyContainer = container.querySelector(`#${langFamilyContainerId}`);
            if(!langFamilyContainer){
                langFamilyContainer = document.createElement('div');
                langFamilyContainer.id = langFamilyContainerId;
                container.appendChild(langFamilyContainer);
            }
            langFamilyContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-pink-200 rounded-md bg-pink-50 space-y-4';
            
            const externalNodesSection = document.createElement('div');
            externalNodesSection.innerHTML = `<h4 class="font-semibold text-pink-700 mb-2">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å (External Languages/Proto-Languages)</h4>`;
            const extNodesList = document.createElement('div');
            extNodesList.id = 'externalLangNodesListLangFamily';
            extNodesList.className = 'max-h-40 overflow-y-auto space-y-1';
            (currentLanguage.languageFamily.externalNodes).forEach(extNode => {
                extNodesList.innerHTML += `
                    <div class="flex items-center justify-between p-2 mb-1 border rounded bg-white text-sm">
                            fetch('https:(extNode.parentId) || 'N/A'})</span>
                        <div>
                            <button class="text-xs text-blue-500 hover:text-blue-700 mr-1" onclick="editExternalLangNode('${extNode.id}')">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
                            <button class="text-xs text-red-500 hover:text-red-700" onclick="removeExternalLangNode('${extNode.id}')">‡∏•‡∏ö</button>
                        </div>
                    </div>`;
            });
            externalNodesSection.appendChild(extNodesList);
            externalNodesSection.innerHTML += `
                <div class="flex gap-2 mt-2 items-end p-2 border-t flex-wrap">
                    <input type="text" id="newExternalNodeNameLangFamily" placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å" class="p-1 border rounded text-sm flex-grow min-w-[150px]">
                    <select id="newExternalNodeParentLangFamily" class="p-1 border rounded text-sm flex-grow min-w-[150px]"></select>
                    <button id="addExternalNodeBtnLangFamily" class="btn-secondary bg-pink-400 px-2 py-1 rounded text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å</button>
                </div>
            `;
            section.appendChild(externalNodesSection);


            section.innerHTML += `
                <h4 class="font-semibold text-pink-700 mt-4 pt-3 border-t border-pink-200 mb-2">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á</h4>
                <div id="langFamilyConfigArea" class="mb-4 p-2 bg-white rounded shadow"></div>
                <h4 class="font-semibold text-pink-700">‡∏ú‡∏±‡∏á‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤ (Language Family Tree):</h4>
                <div id="langFamilyTreeContainer" class="pedigree-chart p-2 bg-white rounded shadow min-h-[150px] max-h-[500px] overflow-auto">
                    <p class="text-center text-gray-400">‡∏ú‡∏±‡∏á‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏°‡πà</p>
                </div>`;
            langFamilyContainer.appendChild(section);
            
            populateParentSelectForExternalNode('newExternalNodeParentLangFamily');
            document.getElementById('addExternalNodeBtnLangFamily').addEventListener('click', addExternalLangNode);

            renderLanguageFamilyConfig(); 
            renderLanguageFamilyTree();
        }

        function getParentNameForNode(parentId) {
            if (!parentId) return null;
            const conlangParent = allLanguages.find(l => l.name === parentId);
            if (conlangParent) return conlangParent.name;
            const externalParent = currentLanguage.languageFamily.externalNodes.find(n => n.id === parentId);
            if (externalParent) return externalParent.name;
            return parentId; 
        }
        
        function populateParentSelectForExternalNode(selectElementId, currentExtNodeIdToExclude = null) {
            const select = document.getElementById(selectElementId);
            if (!select) return;
            select.innerHTML = '<option value="">-- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÅ‡∏°‡πà (‡∏£‡∏≤‡∏Å) --</option>';
            allLanguages.forEach(lang => {
                 select.innerHTML += `<option value="${lang.name}">${lang.name} (Conlang)</option>`;
            });
            currentLanguage.languageFamily.externalNodes.forEach(extNode => {
                if (extNode.id !== currentExtNodeIdToExclude) { 
                    select.innerHTML += `<option value="${extNode.id}">${extNode.name} (External)</option>`;
                }
            });
        }

        function addExternalLangNode() {
            const nameInput = document.getElementById('newExternalNodeNameLangFamily');
            const parentSelect = document.getElementById('newExternalNodeParentLangFamily');
            const name = nameInput.value.trim();
            const parentId = parentSelect.value || null;

            if (name) {
                if (currentLanguage.languageFamily.externalNodes.some(n => n.name.toLowerCase() === name.toLowerCase()) || allLanguages.some(l => l.name.toLowerCase() === name.toLowerCase())) {
                    alert(`‡∏ä‡∏∑‡πà‡∏≠ "${name}" ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß (‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å)`);
                    return;
                }
                const newNodeId = `ext_${nextExternalNodeId++}`;
                currentLanguage.languageFamily.externalNodes.push({ id: newNodeId, name, parentId });
                nameInput.value = '';
                parentSelect.value = '';
                renderLangFamilyUI(tabContentContainer); 
                saveData();
            } else {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å');
            }
        }
        window.editExternalLangNode = (nodeId) => {
            alert(`‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å (ID: ${nodeId}) ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏±‡∏í‡∏ô‡∏≤`);
        }

        window.removeExternalLangNode = (nodeId) => {
            currentLanguage.languageFamily.externalNodes = currentLanguage.languageFamily.externalNodes.filter(n => n.id !== nodeId);
            allLanguages.forEach(lang => {
                if (lang.parentLangName === nodeId) lang.parentLangName = null;
            });
            currentLanguage.languageFamily.externalNodes.forEach(extNode => {
                if (extNode.parentId === nodeId) extNode.parentId = null;
            });
            renderLangFamilyUI(tabContentContainer);
            saveData();
        };

        function renderLanguageFamilyConfig() { 
            const configArea = document.getElementById('langFamilyConfigArea');
             if(!configArea) return; 
            configArea.innerHTML = '';
            allLanguages.forEach(lang => {
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 mb-1 border rounded bg-gray-50 text-sm';
                const label = document.createElement('span');
                label.textContent = `${lang.name}: ‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏°‡πà (Parent) -> `;
                const select = document.createElement('select');
                select.className = 'p-1 border rounded text-sm parent-lang-select-for-conlang';
                select.dataset.conlangName = lang.name;
                select.innerHTML = '<option value="">-- ‡πÑ‡∏°‡πà‡∏°‡∏µ --</option>';
                
                allLanguages.filter(l => l.name !== lang.name).forEach(parentOption => { 
                    select.innerHTML += `<option value="${parentOption.name}" ${lang.parentLangName === parentOption.name ? 'selected' : ''}>${parentOption.name} (Conlang)</option>`;
                });
                (currentLanguage.languageFamily.externalNodes || []).forEach(extNode => {
                     select.innerHTML += `<option value="${extNode.id}" ${lang.parentLangName === extNode.id ? 'selected' : ''}>${extNode.name} (External)</option>`;
                });

                select.onchange = (e) => {
                    const targetLang = allLanguages.find(l => l.name === e.target.dataset.conlangName);
                    if (targetLang) {
                        targetLang.parentLangName = e.target.value || null; 
                        saveData(); 
                        renderLanguageFamilyTree(); 
                    }
                };
                div.appendChild(label);
                div.appendChild(select);
                configArea.appendChild(div);
            });
        }

        function renderLanguageFamilyTree() {
            const treeContainer = document.getElementById('langFamilyTreeContainer');
            if (!treeContainer) return;
            treeContainer.innerHTML = '';
        
            const allNodes = [
                ...allLanguages.map(l => ({ id: l.name, name: l.name, parentId: l.parentLangName, type: 'conlang' })),
                ...(currentLanguage.languageFamily.externalNodes || []).map(n => ({ ...n, type: 'external' }))
            ];
        
            const roots = allNodes.filter(node => !node.parentId || !allNodes.some(potentialParent => potentialParent.id === node.parentId));
        
            if (roots.length === 0 && allNodes.length > 0) {
                treeContainer.innerHTML = '<p class="text-red-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏Å‡∏Ç‡∏≠‡∏á‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏• ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡∏ß‡∏ô‡∏ã‡πâ‡∏≥</p>';
                allNodes.forEach(node => treeContainer.appendChild(buildLangFamilyNodeRecursive(node, allNodes, new Set())));
                return;
            }
            roots.forEach(rootNode => {
                treeContainer.appendChild(buildLangFamilyNodeRecursive(rootNode, allNodes, new Set()));
            });
            if (treeContainer.children.length === 0) {
                treeContainer.innerHTML = '<p class="text-center text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏î‡πÜ</p>';
            }
        }
        
        function buildLangFamilyNodeRecursive(node, allNodes, visited) {
            if (visited.has(node.id)) { 
                const li = document.createElement('li');
                li.innerHTML = `<span class="pedigree-node italic text-xs text-red-500">‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏ã‡πâ‡∏≥ (Cycle): ${node.name}</span>`;
                const ul = document.createElement('ul');
                ul.appendChild(li);
                return ul;
            }
            visited.add(node.id);
        
            const ul = document.createElement('ul');
            const li = document.createElement('li');
            const nodeClass = node.type === 'external' ? 'pedigree-node external-node' : 'pedigree-node';
            li.innerHTML = `<span class="${nodeClass} font-semibold">${node.name}</span>`;
        
            const children = allNodes.filter(childNode => childNode.parentId === node.id);
            if (children.length > 0) {
                const childrenUl = document.createElement('ul');
                children.forEach(childNode => {
                    childrenUl.appendChild(buildLangFamilyNodeRecursive(childNode, allNodes, new Set(visited))); 
                });
                li.appendChild(childrenUl);
            }
            ul.appendChild(li);
            return ul;
        }
        
        function renderSoundChangesInterLangUI(container) {
            const soundChangesContainerId = 'soundChangesTabSpecificContent';
            let soundChangesContainer = container.querySelector(`#${soundChangesContainerId}`);
            if(!soundChangesContainer){
                soundChangesContainer = document.createElement('div');
                soundChangesContainer.id = soundChangesContainerId;
                container.appendChild(soundChangesContainer);
            }
            soundChangesContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-orange-200 rounded-md bg-orange-50 space-y-4';
            
            section.innerHTML = `
                <p class="text-sm text-gray-600">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏©‡∏£ ‡∏à‡∏≤‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏´‡∏ô‡∏∂‡πà‡∏á (‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á) ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏´‡∏ô‡∏∂‡πà‡∏á (‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á) ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="sourceLangSelectSC" class="block text-sm font-medium text-orange-700">‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (Source):</label>
                        <select id="sourceLangSelectSC" class="w-full p-2 border rounded-md"></select>
                    </div>
                    <div>
                        <label for="targetLangSelectSC" class="block text-sm font-medium text-orange-700">‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á (Target):</label>
                        <select id="targetLangSelectSC" class="w-full p-2 border rounded-md"></select>
                    </div>
                </div>
                <div id="interLangRulesDisplayAreaSC" class="p-3 bg-white rounded shadow">
                    <h4 class="font-semibold text-orange-700 mb-2">‡∏ä‡∏∏‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å):</h4>
                    <div id="currentInterLangRulesListSC" class="text-sm space-y-1 mb-2"></div>
                    <div class="flex gap-2 items-end flex-wrap border-t pt-2 mt-2">
                        <input type="text" id="interLangRuleFromSC" placeholder="‡∏à‡∏≤‡∏Å (‡πÄ‡∏ä‡πà‡∏ô p)" class="p-1 border rounded text-sm w-24">
                        <input type="text" id="interLangRuleToSC" placeholder="‡πÄ‡∏õ‡πá‡∏ô (‡πÄ‡∏ä‡πà‡∏ô f)" class="p-1 border rounded text-sm w-24">
                        <input type="text" id="interLangRuleContextSC" placeholder="‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡πÄ‡∏ä‡πà‡∏ô V_V, #_)" class="p-1 border rounded text-sm flex-grow">
                        <input type="text" id="interLangRuleDescSC" placeholder="‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢" class="p-1 border rounded text-sm flex-grow">
                        <button id="addInterLangRuleBtnSC" class="btn-secondary bg-orange-400 text-sm px-2 py-1 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é</button>
                    </div>
                </div>
                <div class="mt-4 p-3 bg-white rounded shadow">
                    <h4 class="font-semibold text-orange-700 mb-2">‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏é:</h4>
                    <label for="sourceWordInputSC" class="block text-sm">‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏à‡∏≤‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡∏£‡∏π‡∏õ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á):</label>
                    <input type="text" id="sourceWordInputSC" class="w-full p-2 border rounded-md mb-2">
                    <button id="applyInterLangRulesBtnSC" class="btn-primary bg-orange-500 text-sm px-3 py-1 rounded">‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡∏Å‡∏é</button>
                    <p class="mt-2"><strong>‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á:</strong> <span id="targetWordOutputSC" class="font-mono"></span></p>
                </div>
            `;
            soundChangesContainer.appendChild(section);

            const sourceSelect = section.querySelector('#sourceLangSelectSC');
            const targetSelect = section.querySelector('#targetLangSelectSC');
            sourceSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>';
            targetSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>';
            allLanguages.forEach(lang => {
                sourceSelect.innerHTML += `<option value="${lang.name}">${lang.name}</option>`;
                targetSelect.innerHTML += `<option value="${lang.name}">${lang.name}</option>`;
            });

            sourceSelect.addEventListener('change', renderInterLangRulesForPair);
            targetSelect.addEventListener('change', renderInterLangRulesForPair);
            document.getElementById('addInterLangRuleBtnSC').addEventListener('click', addInterLangRule);
            document.getElementById('applyInterLangRulesBtnSC').addEventListener('click', applyInterLangRulesTest);
            renderInterLangRulesForPair(); 
        }

        function getActiveInterLangPair() {
            const sourceLangName = document.getElementById('sourceLangSelectSC')?.value;
            const targetLangName = document.getElementById('targetLangSelectSC')?.value;
            if (!sourceLangName || !targetLangName || sourceLangName === targetLangName) return null;
            
            return globalInterLangRules.find(p => p.sourceLangName === sourceLangName && p.targetLangName === targetLangName);
        }
        
        function renderInterLangRulesForPair() {
            const rulesListDiv = document.getElementById('currentInterLangRulesListSC');
            if (!rulesListDiv) return; 
            rulesListDiv.innerHTML = '<p class="text-xs text-gray-400">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏é</p>';
            
            const pair = getActiveInterLangPair();
            if (pair && pair.rules) {
                rulesListDiv.innerHTML = ''; 
                if (pair.rules.length === 0) {
                    rulesListDiv.innerHTML = '<p class="text-xs text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ</p>';
                }
                pair.rules.forEach((rule, index) => {
                    rulesListDiv.innerHTML += `
                        <div class="flex justify-between items-center p-1 border-b">
                            <span>'${rule.from}' <i class="fas fa-arrow-right mx-1"></i> '${rule.to}' ${rule.context ? `(${rule.context})` : ''} ${rule.description ? `- ${rule.description}` : ''}</span>
                            <button class="text-xs text-red-400 hover:text-red-600" onclick="removeInterLangRule(${index})">&times;</button>
                        </div>`;
                });
            }
        }

        function addInterLangRule() {
            const sourceLangName = document.getElementById('sourceLangSelectSC').value;
            const targetLangName = document.getElementById('targetLangSelectSC').value;

            if (!sourceLangName || !targetLangName) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á"); return;
            }
            if (sourceLangName === targetLangName) {
                alert("‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô"); return;
            }

            const from = document.getElementById('interLangRuleFromSC').value.trim();
            const to = document.getElementById('interLangRuleToSC').value.trim(); 
            const context = document.getElementById('interLangRuleContextSC').value.trim();
            const description = document.getElementById('interLangRuleDescSC').value.trim();

            if (!from) { alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å '‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏≠‡∏±‡∏Å‡∏©‡∏£'"); return; }

            let pair = globalInterLangRules.find(p => p.sourceLangName === sourceLangName && p.targetLangName === targetLangName);
            if (!pair) {
                const pairId = `il_pair_${nextInterLangPairId++}`; 
                pair = { id: pairId, sourceLangName, targetLangName, rules: [] };
                globalInterLangRules.push(pair);
            }
            
            pair.rules.push({ from, to, context, description });
            saveData(); 
            renderInterLangRulesForPair();

            document.getElementById('interLangRuleFromSC').value = '';
            document.getElementById('interLangRuleToSC').value = '';
            document.getElementById('interLangRuleContextSC').value = '';
            document.getElementById('interLangRuleDescSC').value = '';
        }

        window.removeInterLangRule = (ruleIndex) => {
            const pair = getActiveInterLangPair();
            if (pair && pair.rules && pair.rules[ruleIndex] !== undefined) {
                pair.rules.splice(ruleIndex, 1);
                saveData();
                renderInterLangRulesForPair();
            }
        };

        function applyInterLangRulesTest() {
            const sourceWord = document.getElementById('sourceWordInputSC').value.trim();
            const targetOutputSpan = document.getElementById('targetWordOutputSC');
            if (!sourceWord) { targetOutputSpan.textContent = "(‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥)"; return; }

            const pair = getActiveInterLangPair();
            if (!pair || !pair.rules || pair.rules.length === 0) {
                targetOutputSpan.textContent = "(‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡πà‡∏†‡∏≤‡∏©‡∏≤)";
                return;
            }

            let changedWord = sourceWord;
            pair.rules.forEach(rule => {
                try {
                    const regexPattern = rule.context ? 
                        convertContextToRegex(rule.from, rule.context) : 
                        new RegExp(rule.from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'); 

                    changedWord = changedWord.replace(regexPattern, rule.to);
                } catch (e) {
                    console.warn(`Error applying rule: From "${rule.from}", To "${rule.to}", Context "${rule.context}". Error: ${e.message}`);
                }
            });
            targetOutputSpan.textContent = changedWord;
        }

        function convertContextToRegex(from, contextStr) {
            const V = '[aeiouAEIOU√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√ø]'; 
            const C = '[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]'; 

            let pattern = from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
            
            if (contextStr.startsWith('#_')) { 
                pattern = '^' + pattern;
                contextStr = contextStr.substring(2); 
            }
            if (contextStr.endsWith('_#')) { 
                pattern = pattern + '$';
                contextStr = contextStr.substring(0, contextStr.length - 2); 
            }
            if (contextStr === 'V_V') {
                return new RegExp(`(?<=${V})${pattern}(?=${V})`, 'g');
            }
             if (contextStr.startsWith('C_')) {
                pattern = `(?<=${C})${pattern}`;
                contextStr = contextStr.substring(2);
            }
            if (contextStr.endsWith('_C')) {
                pattern = `${pattern}(?=${C})`;
                contextStr = contextStr.substring(0, contextStr.length-2);
            }
            return new RegExp(pattern, 'g');
        }

        function renderToolsUI(container) {
            const toolsContainerId = 'toolsTabSpecificContent';
            let toolsContainer = container.querySelector(`#${toolsContainerId}`);
            if(!toolsContainer){
                toolsContainer = document.createElement('div');
                toolsContainer.id = toolsContainerId;
                container.appendChild(toolsContainer);
            }
            toolsContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-gray-300 rounded-md bg-gray-100 space-y-6';

            const translatorSection = document.createElement('div');
            translatorSection.className = 'p-3 bg-white rounded shadow';
            translatorSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üåç ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤ (‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡πà‡∏≤‡∏¢)</h4>
                <textarea id="translatorInputTools" class="w-full p-2 border rounded-md mb-2" rows="3" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© ‡∏´‡∏£‡∏∑‡∏≠ ‡πÑ‡∏ó‡∏¢) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•..."></textarea>
                <div class="flex gap-2 mb-2 items-center">
                    <select id="translateFromLangTools" class="p-2 border rounded-md">
                        <option value="th">‡πÑ‡∏ó‡∏¢</option><option value="en">‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©</option>
                    </select>
                    <span> <i class="fas fa-arrow-right mx-1"></i> <strong id="translatorTargetLangNameTools">${transliterateWordToSymbols(currentLanguage.name || '‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì')}</strong></span>
                </div>
                <button id="translateButtonTools" class="btn-primary bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded-md text-sm">‡πÅ‡∏õ‡∏•</button>
                <div class="mt-2"><strong>‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:</strong><p id="translatorOutputTools" class="p-2 bg-gray-50 rounded border min-h-[40px]"></p></div>`;
            section.appendChild(translatorSection);

             const nameGenSection = document.createElement('div');
             nameGenSection.className = 'p-3 bg-white rounded shadow';
             nameGenSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üë§üó∫Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠ (‡∏Ñ‡∏ô, ‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà)</h4>
                <div class="flex gap-2 mb-2 items-center flex-wrap">
                    <label for="nameTypeSelectTools" class="text-sm">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</label>
                    <select id="nameTypeSelectTools" class="p-1 border rounded-md text-sm"><option value="person">‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏ô</option><option value="place">‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà</option></select>
                    <label for="numNamesToGenerateTools" class="text-sm ml-2">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô:</label>
                    <input type="number" id="numNamesToGenerateTools" value="3" min="1" max="10" class="w-16 p-1 border rounded-md text-sm">
                    <button id="generateNamesButtonTools" class="btn-primary bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded-md text-sm">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠</button>
                </div>
                <ul id="generatedNamesListTools" class="list-disc list-inside text-sm min-h-[40px] p-2 bg-gray-50 rounded border"></ul>`;
            section.appendChild(nameGenSection);

            const sentenceGenSection = document.createElement('div');
            sentenceGenSection.className = 'p-3 bg-white rounded shadow';
            sentenceGenSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üìù ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</h4>
                <div><label class="text-sm">‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ:</label> <select id="sentenceStructureForGenTools" class="p-1 border rounded text-sm"></select></div>
                <button id="generateSentenceBtnTools" class="btn-primary bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded-md text-sm my-2">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ</button>
                <div class="mt-1">
                    <label class="text-sm">‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á (<span class="font-mono">${transliterateWordToSymbols(currentLanguage.name || '‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì')}</span>):</label>
                    <textarea id="generatedConlangSentenceTools" class="w-full p-1 border rounded text-sm" rows="2" readonly></textarea>
                </div>
                <div class="mt-1">
                    <label class="text-sm">‡∏Ñ‡∏≥‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì):</label>
                    <textarea id="generatedThaiTranslationTools" class="w-full p-1 border rounded text-sm" rows="2" readonly></textarea>
                </div>`;
            section.appendChild(sentenceGenSection);

            const dataMgmtSection = document.createElement('div');
            dataMgmtSection.className = 'p-3 bg-white rounded shadow';
            dataMgmtSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üíæ ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Import/Export)</h4>
                <div class="flex flex-wrap gap-2">
                    <button id="exportCurrentLangBtnTools" class="btn-secondary text-sm"><i class="fas fa-download mr-1"></i>Export ‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (JSON)</button>
                    <button id="exportAllLangsBtnTools" class="btn-secondary text-sm"><i class="fas fa-archive mr-1"></i>Export ‡∏ó‡∏∏‡∏Å‡∏†‡∏≤‡∏©‡∏≤ (JSON)</button>
                    <div>
                        <label for="importAllLangsFileTools" class="btn-secondary text-sm cursor-pointer"><i class="fas fa-upload mr-1"></i>Import ‡∏ó‡∏∏‡∏Å‡∏†‡∏≤‡∏©‡∏≤ (JSON)</label>
                        <input type="file" id="importAllLangsFileTools" class="hidden" accept=".json">
                    </div>
                </div>
                <p class="text-xs text-gray-500 mt-1">‡∏Å‡∏≤‡∏£ Import ‡∏à‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà</p>`;
            section.appendChild(dataMgmtSection);

            toolsContainer.appendChild(section);

            document.getElementById('translatorTargetLangNameTools').textContent = transliterateWordToSymbols(currentLanguage.name || '‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì');
            document.getElementById('translateButtonTools').addEventListener('click', translateText);
            document.getElementById('generateNamesButtonTools').addEventListener('click', generateNames);

            const sentenceStructSelect = document.getElementById('sentenceStructureForGenTools');
            sentenceStructSelect.innerHTML = ''; 
            ['SVO', 'SOV', 'VSO', 'VOS', 'OSV', 'OVS'].forEach(s => sentenceStructSelect.innerHTML += `<option value="${s}" ${s === currentLanguage.grammar.sentenceStructure ? 'selected' : ''}>${s}</option>`);
            sentenceStructSelect.value = currentLanguage.grammar.sentenceStructure; 
            document.getElementById('generateSentenceBtnTools').addEventListener('click', generateSentence);

            document.getElementById('exportCurrentLangBtnTools').addEventListener('click', () => exportDataAsJSON(currentLanguage, `${currentLanguage.name || 'current_language'}_data.json`));
            document.getElementById('exportAllLangsBtnTools').addEventListener('click', () => {
                 const dataToExport = {
                    allLanguages: allLanguages,
                    globalInterLangRules: globalInterLangRules 
                };
                exportDataAsJSON(dataToExport, 'all_languages_and_rules_backup.json');
            });
            document.getElementById('importAllLangsFileTools').addEventListener('change', importAllLanguagesData);
        }

        function translateText() { 
            const input = document.getElementById('translatorInputTools').value.toLowerCase().trim();
            const fromLang = document.getElementById('translateFromLangTools').value; 
            const outputP = document.getElementById('translatorOutputTools');
            if (!input) { outputP.textContent = ''; return; }

            let translatedText = '';
            const wordsToTranslate = input.split(/\s+/);
            wordsToTranslate.forEach(wordToTranslate => {
                let foundEntry = null;
                if (fromLang === 'th') { 
                    foundEntry = currentLanguage.lexicon.find(entry => entry.meaning.toLowerCase() === wordToTranslate);
                } else if (fromLang === 'en') { 
                     foundEntry = currentLanguage.lexicon.find(entry =>
                        (entry.synonyms && entry.synonyms.some(s => s.toLowerCase() === wordToTranslate)) ||
                        entry.meaning.toLowerCase().includes(wordToTranslate) 
                    );
                }
                if (foundEntry) {
                    translatedText += (fromLang === 'th' || fromLang === 'en' ? transliterateWordToSymbols(foundEntry.word) : foundEntry.meaning) + ' ';
                } else {
                    translatedText += `(${wordToTranslate}?) `; 
                }
            });
            outputP.textContent = translatedText.trim();
        }

        function generateNames() { 
            const nameType = document.getElementById('nameTypeSelectTools').value;
            const numNames = parseInt(document.getElementById('numNamesToGenerateTools').value);
            const listElement = document.getElementById('generatedNamesListTools');
            listElement.innerHTML = '';

            if (currentLanguage.phonology.consonants.length === 0 || currentLanguage.phonology.vowels.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏™‡∏£‡∏∞‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô"); return;
            }
            for (let i = 0; i < numNames; i++) {
                const numSyll = (nameType === 'person') ? Math.floor(Math.random() * 2) + 2 : Math.floor(Math.random() * 3) + 2;  
                let nameForm = '';
                for (let j = 0; j < numSyll; j++) { nameForm += generateSyllable(); }
                nameForm = nameForm.charAt(0).toUpperCase() + nameForm.slice(1); 
                const displayName = transliterateWordToSymbols(nameForm);
                listElement.innerHTML += `<li class="text-sm">${displayName} <span class="text-xs text-gray-400">(${nameForm})</span></li>`;
            }
        }

        function generateSentence() {
            const structure = document.getElementById('sentenceStructureForGenTools').value;
            const conlangOutput = document.getElementById('generatedConlangSentenceTools');
            const thaiOutput = document.getElementById('generatedThaiTranslationTools');

            if (currentLanguage.lexicon.length === 0) {
                conlangOutput.value = "(‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤)";
                thaiOutput.value = ""; return;
            }

            let conlangSentence = [];
            let thaiSentence = [];

            const getWordByPOS = (targetPOS) => {
                let candidates = currentLanguage.lexicon.filter(w => w.partOfSpeech.toLowerCase() === targetPOS.toLowerCase());
                if (candidates.length === 0) {
                    candidates = currentLanguage.lexicon.filter(w => w.partOfSpeech.toLowerCase().startsWith(targetPOS.toLowerCase()));
                }
                 if (candidates.length === 0 && targetPOS.toLowerCase() === '‡∏ô‡∏≤‡∏°') { 
                    candidates = currentLanguage.lexicon;
                }
                if (candidates.length === 0 && targetPOS.toLowerCase() === '‡∏Å‡∏£‡∏¥‡∏¢‡∏≤') { 
                    candidates = currentLanguage.lexicon;
                }
                if (candidates.length > 0) return candidates[Math.floor(Math.random() * candidates.length)];
                return null; 
            };

            for (const part of structure) { 
                let wordEntry = null;
                if (part === 'S' || part === 'O') wordEntry = getWordByPOS('‡∏ô‡∏≤‡∏°');
                else if (part === 'V') wordEntry = getWordByPOS('‡∏Å‡∏£‡∏¥‡∏¢‡∏≤');
                
                if (wordEntry) {
                    let wordForm = wordEntry.word;
                    conlangSentence.push(transliterateWordToSymbols(wordForm));
                    thaiSentence.push(wordEntry.meaning);
                } else {
                    conlangSentence.push(`(${part}?)`); 
                    thaiSentence.push(`(${part}?)`);
                }
            }
            conlangOutput.value = conlangSentence.join(' ');
            thaiOutput.value = thaiSentence.join(' ');
        }

        function exportDataAsJSON(data, filename) {
            const jsonData = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function importAllLanguagesData(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedPayload = JSON.parse(e.target.result);
                        let importedLanguagesArray;
                        let importedGlobalRules = [];

                        if (Array.isArray(importedPayload)) { 
                            importedLanguagesArray = importedPayload;
                            console.warn("Importing old format (array of languages).");
                        } else if (importedPayload && Array.isArray(importedPayload.allLanguages)) { 
                            importedLanguagesArray = importedPayload.allLanguages;
                            if (Array.isArray(importedPayload.globalInterLangRules)) {
                                importedGlobalRules = importedPayload.globalInterLangRules;
                            }
                        } else {
                             alert('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                            return;
                        }

                        if (importedLanguagesArray.every(lang => lang.hasOwnProperty('name'))) {
                           if (confirm(`‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (${importedLanguagesArray.length} ‡∏†‡∏≤‡∏©‡∏≤)? ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î!`)) {
                                allLanguages = []; 
                                globalInterLangRules = importedGlobalRules; 

                                importedLanguagesArray.forEach(importedLang => {
                                    allLanguages.push(ensureDeepStructure(importedLang, DEFAULT_LANGUAGE_STATE));
                                });

                                if (allLanguages.length > 0) {
                                    switchLanguage(allLanguages[0].name); 
                                } else { 
                                    currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE);
                                    nextWordId = 1;
                                    updateUI(); 
                                }
                                saveData(); 
                                alert('‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
                            }
                        } else {
                            alert('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: language objects ‡∏ö‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏°‡∏µ property "name"');
                        }
                    } catch (error) {
                        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå JSON: ' + error.message);
                        console.error("Import error:", error);
                    }
                };
                reader.readAsText(file);
                event.target.value = null; 
            }
        }

        function renderWordEvolutionUI(container) {
            const evolutionContainer = document.createElement('div');
            evolutionContainer.className = 'p-3 border rounded bg-gray-50';

            evolutionContainer.innerHTML = `
                <h3 class="text-lg font-semibold mb-3">‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥</h3>
                <div class="mb-3">
                    <label class="block text-sm font-medium">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢‡∏ê‡∏≤‡∏ô:</label>
                    <select id="baseEraSelect" class="p-1 border rounded text-sm">
                        ${currentLanguage.evolution.eras.map(era => `<option value="${era.id}">${era.name}</option>`).join('')}
                    </select>
                </div>
                <div class="mb-3">
                    <label class="block text-sm font-medium">‡∏£‡∏∞‡∏ö‡∏∏‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô:</label>
                    <select id="wordEraSelect" class="p-1 border rounded text-sm">
                        ${currentLanguage.evolution.eras.map(era => `<option value="${era.id}">${era.name}</option>`).join('')}
                    </select>
                </div>
                <div id="wordEvolutionTree" class="p-3 border rounded bg-white"></div>
            `;

            container.appendChild(evolutionContainer);
            document.getElementById('baseEraSelect').addEventListener('change', updateBaseEra);
            document.getElementById('wordEraSelect').addEventListener('change', updateWordEra);
            renderEvolutionTree();
        }

        function updateBaseEra() {
            const baseEraId = document.getElementById('baseEraSelect').value;
            currentLanguage.evolution.baseEra = baseEraId;
            saveData();
            renderEvolutionTree();
        }

        function updateWordEra() {
            const wordEraId = document.getElementById('wordEraSelect').value;
            currentLanguage.evolution.wordEra = wordEraId;
            saveData();
            renderEvolutionTree();
        }

        function renderEvolutionTree() {
            const treeContainer = document.getElementById('wordEvolutionTree');
            if (!treeContainer) return;

            const baseEra = currentLanguage.evolution.eras.find(e => e.id === currentLanguage.evolution.baseEra);
            const wordEra = currentLanguage.evolution.eras.find(e => e.id === currentLanguage.evolution.wordEra);

            if (!baseEra || !wordEra) {
                treeContainer.innerHTML = '<p class="text-sm text-red-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢‡∏ê‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô</p>';
                return;
            }

            treeContainer.innerHTML = `<p class="text-sm">Tree Diagram: ${baseEra.name} ‚Üí ${wordEra.name}</p>`;
            // Add logic to generate and display the actual tree diagram here
        }
        function submitWordTypeForm() {
            const checkboxes = document.querySelectorAll('input[name="wordType"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            alert("‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥: " + selectedTypes.join(", "));
        }

        
    </script>
</body>
</html>
